# 문서 3. 고급 패턴 I: 인증/운영 (S2.2-S2.3)

> 이 문서는 **Stage 2 전반부** 용이다.
> 전제:
>
> * Stage 1 (S2.0-S2.1) 완료
> * Spring Boot Controller/Service/Repository 패턴 이해
> * JWT 인증 구현 경험
> * 이제 **팀 기반 RBAC**, **배치 작업**, **캐싱**, **외부 API 연동**을 익힐 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* S2.0-S2.1 완료 (Spring Boot 기초 + CRUD + JWT)
* Spring Data JPA 사용 경험
* @PreAuthorize 개념 이해 가능

### 이 문서의 목표

1. **팀 기반 RBAC** 구현 (S2.2)
2. **배치 작업**으로 통계 집계 (S2.3)
3. **캐싱**으로 성능 개선 (S2.3)
4. **외부 HTTP API** 안전하게 호출 (S2.3)

### 이 문서가 다루는 범위

* **S2.2**: Team & Role-Based Access Control
* **S2.3**: Batch Jobs, Stats, Cache, External API

**다루지 않는 범위** (다음 문서 4에서):

* S2.4: Elasticsearch Search
* S2.5: Kafka Async Events
* S2.6: Production Infrastructure

---

## 1. S2.2: Team & RBAC

### 1.1 목표

* 팀/역할 도메인 설계
* @PreAuthorize + 커스텀 표현식으로 권한 체크
* 401 (미인증) / 403 (권한 없음) / 404 (리소스 없음) 구분

### 1.2 도메인 모델

**Team.java**:

```java
package com.example.training.team.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "teams")
public class Team {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @OneToMany(mappedBy = "team", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TeamMember> members = new ArrayList<>();

    @Column(nullable = false)
    private LocalDateTime createdAt;

    protected Team() {}

    public Team(String name, String description) {
        this.name = name;
        this.description = description;
        this.createdAt = LocalDateTime.now();
    }

    public void addMember(TeamMember member) {
        members.add(member);
        member.setTeam(this);
    }

    // Getters
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public List<TeamMember> getMembers() { return members; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

**TeamMember.java**:

```java
package com.example.training.team.domain;

import com.example.training.user.domain.User;
import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "team_members",
       uniqueConstraints = @UniqueConstraint(columnNames = {"team_id", "user_id"}))
public class TeamMember {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TeamRole role;

    @Column(nullable = false)
    private LocalDateTime joinedAt;

    protected TeamMember() {}

    public TeamMember(Team team, User user, TeamRole role) {
        this.team = team;
        this.user = user;
        this.role = role;
        this.joinedAt = LocalDateTime.now();
    }

    public void updateRole(TeamRole newRole) {
        this.role = newRole;
    }

    // Getters & Setter
    public Long getId() { return id; }
    public Team getTeam() { return team; }
    public User getUser() { return user; }
    public TeamRole getRole() { return role; }
    public LocalDateTime getJoinedAt() { return joinedAt; }

    void setTeam(Team team) { this.team = team; }
}
```

**TeamRole.java**:

```java
package com.example.training.team.domain;

public enum TeamRole {
    OWNER,      // 팀 삭제, 멤버 역할 변경
    MANAGER,    // 멤버 추가/제거
    MEMBER      // 읽기만 가능
}
```

**WorkspaceItem.java** (팀 리소스 예시):

```java
package com.example.training.team.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "workspace_items")
public class WorkspaceItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Column(nullable = false)
    private LocalDateTime createdAt;

    protected WorkspaceItem() {}

    public WorkspaceItem(Team team, String title, String content) {
        this.team = team;
        this.title = title;
        this.content = content;
        this.createdAt = LocalDateTime.now();
    }

    // Getters
    public Long getId() { return id; }
    public Team getTeam() { return team; }
    public String getTitle() { return title; }
    public String getContent() { return content; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

### 1.3 RBAC 구현

**TeamMemberRepository.java**:

```java
package com.example.training.team.repository;

import com.example.training.team.domain.TeamMember;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.Optional;

public interface TeamMemberRepository extends JpaRepository<TeamMember, Long> {

    @Query("SELECT tm FROM TeamMember tm WHERE tm.team.id = :teamId AND tm.user.id = :userId")
    Optional<TeamMember> findByTeamIdAndUserId(Long teamId, Long userId);

    boolean existsByTeamIdAndUserId(Long teamId, Long userId);
}
```

**TeamSecurityService.java** (권한 체크 로직):

```java
package com.example.training.team.service;

import com.example.training.team.domain.TeamMember;
import com.example.training.team.domain.TeamRole;
import com.example.training.team.repository.TeamMemberRepository;
import org.springframework.stereotype.Service;

@Service
public class TeamSecurityService {
    private final TeamMemberRepository teamMemberRepository;

    public TeamSecurityService(TeamMemberRepository teamMemberRepository) {
        this.teamMemberRepository = teamMemberRepository;
    }

    public boolean isTeamMember(Long userId, Long teamId) {
        return teamMemberRepository.existsByTeamIdAndUserId(teamId, userId);
    }

    public boolean hasRole(Long userId, Long teamId, TeamRole requiredRole) {
        TeamMember member = teamMemberRepository.findByTeamIdAndUserId(teamId, userId)
            .orElse(null);

        if (member == null) return false;

        return hasPermission(member.getRole(), requiredRole);
    }

    private boolean hasPermission(TeamRole userRole, TeamRole requiredRole) {
        return switch (userRole) {
            case OWNER -> true;  // OWNER는 모든 권한
            case MANAGER -> requiredRole != TeamRole.OWNER;
            case MEMBER -> requiredRole == TeamRole.MEMBER;
        };
    }
}
```

**SecurityConfig.java** (Method Security 활성화):

```java
package com.example.training.common.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

@Configuration
@EnableMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
    // @PreAuthorize, @PostAuthorize 활성화
}
```

**TeamController.java** (권한 체크 적용):

```java
package com.example.training.team.controller;

import com.example.training.team.dto.AddMemberDto;
import com.example.training.team.dto.CreateTeamDto;
import com.example.training.team.dto.TeamResponse;
import com.example.training.team.service.TeamService;
import com.example.training.user.domain.User;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/teams")
public class TeamController {
    private final TeamService teamService;

    public TeamController(TeamService teamService) {
        this.teamService = teamService;
    }

    @PostMapping
    public TeamResponse createTeam(
        @Valid @RequestBody CreateTeamDto dto,
        @AuthenticationPrincipal User user
    ) {
        return teamService.createTeam(dto, user);
    }

    @PostMapping("/{teamId}/members")
    @PreAuthorize("@teamSecurityService.hasRole(#user.id, #teamId, T(com.example.training.team.domain.TeamRole).MANAGER)")
    public void addMember(
        @PathVariable Long teamId,
        @Valid @RequestBody AddMemberDto dto,
        @AuthenticationPrincipal User user
    ) {
        teamService.addMember(teamId, dto);
    }

    @GetMapping("/{teamId}")
    @PreAuthorize("@teamSecurityService.isTeamMember(#user.id, #teamId)")
    public TeamResponse getTeam(
        @PathVariable Long teamId,
        @AuthenticationPrincipal User user
    ) {
        return teamService.getTeam(teamId);
    }
}
```

**@PreAuthorize 설명**:
- `@teamSecurityService`: Spring Bean 이름
- `#user.id`: 메서드 파라미터 참조
- `T(...)`: 클래스 타입 참조

---

## 2. S2.3: Batch Jobs, Stats, Cache, External API

### 2.1 배치 작업

**@EnableScheduling**:

```java
package com.example.training;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**DailyIssueStats.java**:

```java
package com.example.training.stats.domain;

import jakarta.persistence.*;
import java.time.LocalDate;

@Entity
@Table(name = "daily_issue_stats",
       uniqueConstraints = @UniqueConstraint(columnNames = "date"))
public class DailyIssueStats {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private LocalDate date;

    @Column(nullable = false)
    private Long issuesCreated = 0L;

    @Column(nullable = false)
    private Long issuesResolved = 0L;

    @Column(nullable = false)
    private Long commentsCreated = 0L;

    protected DailyIssueStats() {}

    public DailyIssueStats(LocalDate date, Long issuesCreated, Long issuesResolved, Long commentsCreated) {
        this.date = date;
        this.issuesCreated = issuesCreated;
        this.issuesResolved = issuesResolved;
        this.commentsCreated = commentsCreated;
    }

    // Getters
    public Long getId() { return id; }
    public LocalDate getDate() { return date; }
    public Long getIssuesCreated() { return issuesCreated; }
    public Long getIssuesResolved() { return issuesResolved; }
    public Long getCommentsCreated() { return commentsCreated; }
}
```

**StatsScheduler.java**:

```java
package com.example.training.stats.scheduler;

import com.example.training.stats.service.StatsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDate;

@Component
public class StatsScheduler {
    private static final Logger logger = LoggerFactory.getLogger(StatsScheduler.class);
    private final StatsService statsService;

    public StatsScheduler(StatsService statsService) {
        this.statsService = statsService;
    }

    // 매일 새벽 3시 실행
    @Scheduled(cron = "0 0 3 * * *")
    public void aggregateDailyStats() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        logger.info("Starting daily stats aggregation for {}", yesterday);

        try {
            statsService.aggregateDaily(yesterday);
            logger.info("Daily stats aggregation completed for {}", yesterday);
        } catch (Exception e) {
            logger.error("Failed to aggregate daily stats for {}", yesterday, e);
        }
    }
}
```

**cron 표현식**:
- `초 분 시 일 월 요일`
- `0 0 3 * * *`: 매일 새벽 3시 0분 0초

**StatsService.java**:

```java
package com.example.training.stats.service;

import com.example.training.comment.repository.CommentRepository;
import com.example.training.issue.domain.IssueStatus;
import com.example.training.issue.repository.IssueRepository;
import com.example.training.stats.domain.DailyIssueStats;
import com.example.training.stats.repository.DailyIssueStatsRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Service
public class StatsService {
    private final IssueRepository issueRepository;
    private final CommentRepository commentRepository;
    private final DailyIssueStatsRepository statsRepository;

    public StatsService(IssueRepository issueRepository,
                       CommentRepository commentRepository,
                       DailyIssueStatsRepository statsRepository) {
        this.issueRepository = issueRepository;
        this.commentRepository = commentRepository;
        this.statsRepository = statsRepository;
    }

    @Transactional
    public void aggregateDaily(LocalDate date) {
        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime endOfDay = date.plusDays(1).atStartOfDay();

        Long issuesCreated = issueRepository.countByCreatedAtBetween(startOfDay, endOfDay);
        Long issuesResolved = issueRepository.countByStatusAndUpdatedAtBetween(
            IssueStatus.RESOLVED, startOfDay, endOfDay);
        Long commentsCreated = commentRepository.countByCreatedAtBetween(startOfDay, endOfDay);

        DailyIssueStats stats = new DailyIssueStats(date, issuesCreated, issuesResolved, commentsCreated);
        statsRepository.save(stats);
    }
}
```

### 2.2 캐싱

**build.gradle** (의존성 추가):

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    // Simple 캐시는 기본 제공, Redis는 S2.6에서
}
```

**Application.java** (@EnableCaching):

```java
@SpringBootApplication
@EnableScheduling
@EnableCaching
public class Application {
    // ...
}
```

**CacheConfig.java**:

```java
package com.example.training.common.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        // Simple 인메모리 캐시 (단일 인스턴스용)
        return new ConcurrentMapCacheManager("popularIssues", "stats", "external");
    }
}
```

**IssueService.java** (@Cacheable 적용):

```java
package com.example.training.issue.service;

import com.example.training.issue.dto.IssueResponse;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class IssueService {
    // ...

    @Cacheable(value = "popularIssues", key = "'v1'")
    public List<IssueResponse> findPopular() {
        LocalDateTime since = LocalDateTime.now().minusDays(7);

        return issueRepository.findPopularIssues(since, 10).stream()
            .map(IssueResponse::from)
            .toList();
    }
}
```

**IssueRepository.java** (인기 이슈 조회):

```java
@Query("SELECT i FROM Issue i " +
       "WHERE i.createdAt >= :since " +
       "ORDER BY i.viewCount + SIZE(i.comments) DESC")
List<Issue> findPopularIssues(@Param("since") LocalDateTime since, int limit);
```

**캐시 동작**:
1. 첫 호출: DB 조회 → 결과 캐시 저장
2. 이후 호출: 캐시에서 반환 (DB 조회 안 함)
3. TTL (Time To Live)은 S2.6에서 Redis로 전환 시 설정

### 2.3 외부 API 호출

**RestTemplate vs WebClient**:
- **RestTemplate**: 동기 블로킹 (간단한 용도)
- **WebClient**: 비동기 논블로킹 (권장)

**RestClientConfig.java**:

```java
package com.example.training.common.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

@Configuration
public class RestClientConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
            .setConnectTimeout(Duration.ofSeconds(3))
            .setReadTimeout(Duration.ofSeconds(3))
            .build();
    }
}
```

**ExternalApiService.java**:

```java
package com.example.training.external.service;

import com.example.training.external.dto.ExternalPost;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

@Service
public class ExternalApiService {
    private static final Logger logger = LoggerFactory.getLogger(ExternalApiService.class);
    private static final String API_BASE_URL = "https://jsonplaceholder.typicode.com";

    private final RestTemplate restTemplate;

    public ExternalApiService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Cacheable(value = "external", key = "#id")
    @Retryable(
        retryFor = RestClientException.class,
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000)
    )
    public ExternalPost getPost(Long id) {
        String url = API_BASE_URL + "/posts/" + id;
        logger.info("Fetching external post: {}", url);

        return restTemplate.getForObject(url, ExternalPost.class);
    }
}
```

**@Retryable 설정** (build.gradle):

```gradle
dependencies {
    implementation 'org.springframework.retry:spring-retry'
    implementation 'org.springframework:spring-aspects'
}
```

**Application.java** (@EnableRetry):

```java
@SpringBootApplication
@EnableScheduling
@EnableCaching
@EnableRetry
public class Application {
    // ...
}
```

---

## 3. S2.2-S2.3 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 2 전반부 (S2.2-S2.3)는 통과로 본다.

### S2.2 체크리스트 (Team & RBAC)

* [ ] Team, TeamMember 도메인을 설계하고 역할(OWNER/MANAGER/MEMBER)을 구분할 수 있다.
* [ ] TeamSecurityService를 만들고 사용자의 팀 권한을 체크할 수 있다.
* [ ] @PreAuthorize로 메서드 레벨 권한 체크를 할 수 있다.
* [ ] 401 (미인증), 403 (권한 없음), 404 (리소스 없음)를 구분해서 반환할 수 있다.

### S2.3 체크리스트 (Batch, Stats, Cache, External API)

* [ ] @Scheduled로 cron 표현식을 사용해 배치 작업을 스케줄링할 수 있다.
* [ ] 통계 테이블을 설계하고 날짜 범위 조회 API를 만들 수 있다.
* [ ] @Cacheable을 적용하고 캐시 히트 시 DB 조회가 발생하지 않는 것을 확인할 수 있다.
* [ ] RestTemplate으로 외부 API를 호출하고 타임아웃/재시도를 처리할 수 있다.

여기까지 구현하면:

* **RBAC** (Role-Based Access Control) 패턴
* **배치 작업** 스케줄링
* **캐싱** 전략
* **외부 API 연동** (타임아웃, 재시도)

을 모두 경험한 상태다. 다음은 **문서 4**에서 Elasticsearch, Kafka, 프로덕션 인프라를 다룬다.

---

## 4. 참고 자료

* [Spring Security Method Security](https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html)
* [Spring Scheduling](https://docs.spring.io/spring-framework/reference/integration/scheduling.html)
* [Spring Cache Abstraction](https://docs.spring.io/spring-framework/reference/integration/cache.html)
* [Spring Retry](https://github.com/spring-projects/spring-retry)
* [RestTemplate Documentation](https://docs.spring.io/spring-framework/reference/integration/rest-clients.html)
