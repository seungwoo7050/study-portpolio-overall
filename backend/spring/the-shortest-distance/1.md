# 문서 1. 전체 아키텍처 & 로드맵 개요

## 1. 이 문서의 역할

이 문서는 **"전체 그림"만 보여주는 인덱스 문서**다.

* 대상: 기본적인 프로그래밍은 할 수 있지만, Java/Spring Boot 백엔드 개발은 처음이거나 실전 패턴을 체계적으로 익히고 싶은 개발자
* 목표:

  * Spring Boot 기반 백엔드 서버의 **핵심 패턴과 구조**를 한 번에 이해
  * 어떤 순서(Stage)로 문서 2, 3, 4를 보면 되는지 파악
  * 각 Stage에서 **무엇을 만들고, 통과 기준이 뭔지** 명확히 정리

세부 문법, 코드, 설정은 각각:

* **문서 2**: Spring Boot 기초 & CRUD (S2.0-S2.1)
* **문서 3**: 고급 패턴 I: 인증/운영 (S2.2-S2.3)
* **문서 4**: 고급 패턴 II: 외부 시스템 & 인프라 (S2.4-S2.6)

에서 다룬다. 이 문서는 그 위에 얹는 "지도"라고 생각하면 된다.

---

## 2. 최종 목표: 어떤 서버를 만들 것인가

최종적으로 목표하는 것은:

> **실전에서 자주 쓰이는 Java + Spring Boot 백엔드 패턴을 작은 도메인에 여러 번 반복 적용해서 손에 익히는 것**

구체적으로:

1. **Spring Boot 프로젝트 기반 구축** (S2.0)

   * Java 17, Gradle, H2 Database
   * 환경 설정 (application.yml, profiles)
   * 헬스 체크 엔드포인트
   * GitHub Actions CI 파이프라인

2. **레이어드 아키텍처 & CRUD** (S2.1)

   * Controller / Service / Repository 패턴
   * DTO validation (Bean Validation)
   * JWT 인증 (Spring Security)
   * 트랜잭션 처리 (@Transactional)
   * Issue Tracker 도메인 구현

3. **팀 & 역할 기반 권한 (RBAC)** (S2.2)

   * 커스텀 어노테이션 + MethodSecurity
   * 401/403/404 상태 코드 구분
   * 팀 멤버 관리 도메인

4. **배치 작업, 통계, 캐싱, 외부 API** (S2.3)

   * Spring Batch 또는 @Scheduled 기반 배치 작업
   * 통계 테이블 설계
   * @Cacheable (Simple/Redis)
   * RestTemplate/WebClient + 재시도 로직

5. **Elasticsearch 검색** (S2.4)

   * RDB와 분리된 검색 인덱스
   * 전문 검색 API
   * DB-ES 동기화 전략

6. **Kafka 비동기 이벤트** (S2.5)

   * Producer/Consumer 패턴
   * 도메인 이벤트 발행/소비
   * Event-driven architecture

7. **프로덕션 인프라** (S2.6)

   * H2 → PostgreSQL 전환
   * Redis 분산 캐싱
   * Docker 컨테이너화
   * 클라우드 배포 준비

**이 전체 흐름을 Stage 1 → 2 → 3으로 쪼개서 올라간다.**

---

## 3. 전체 아키텍처 한 번에 보기

### 3.1 기술 스택

```text
[Spring Boot 3.3.5 (Java 17)]
  - Controller / Service / Repository
  - @Component 기반 아키텍처
  - Dependency Injection (생성자 주입)
        │
        ├─ Spring Data JPA (H2/PostgreSQL)
        ├─ Spring Security (JWT Authentication)
        ├─ Bean Validation (DTO 검증)
        ├─ @Scheduled (배치 작업)
        ├─ @Cacheable (Simple/Redis)
        ├─ Elasticsearch Java Client (검색)
        └─ Spring Kafka (이벤트 스트리밍)
```

### 3.2 프로젝트 구조

```text
backend/spring/
├── build.gradle                   # 빌드 설정 및 의존성
├── settings.gradle                # 프로젝트 이름
├── src/
│   ├── main/
│   │   ├── java/com/example/training/
│   │   │   ├── Application.java       # 부트스트랩
│   │   │   ├── common/
│   │   │   │   ├── controller/       # 헬스 체크 (S2.0)
│   │   │   │   ├── config/           # 설정 클래스
│   │   │   │   └── exception/        # 예외 처리
│   │   │   ├── auth/                 # 인증 (S2.1)
│   │   │   ├── user/                 # 사용자 관리 (S2.1)
│   │   │   ├── project/              # 프로젝트 모듈 (S2.1)
│   │   │   ├── issue/                # 이슈 트래커 (S2.1)
│   │   │   ├── comment/              # 댓글 (S2.1)
│   │   │   ├── team/                 # 팀 & RBAC (S2.2)
│   │   │   ├── stats/                # 통계 & 배치 (S2.3)
│   │   │   ├── external/             # 외부 API 연동 (S2.3)
│   │   │   ├── search/               # Elasticsearch (S2.4)
│   │   │   ├── product/              # 상품 카탈로그 (S2.4)
│   │   │   ├── order/                # 주문 관리 (S2.5)
│   │   │   └── notification/         # 알림 Consumer (S2.5)
│   │   └── resources/
│   │       ├── application.yml       # 공통 설정
│   │       ├── application-local.yml # 로컬 환경
│   │       ├── application-test.yml  # 테스트 환경
│   │       └── application-prod.yml  # 프로덕션 환경
│   └── test/
│       └── java/com/example/training/
│           ├── ApplicationTest.java
│           ├── common/controller/
│           │   └── HealthControllerTest.java
│           └── ...
└── .github/
    └── workflows/
        └── ci.yml                 # CI 파이프라인
```

### 3.3 대표 시나리오 (Issue Tracker)

```text
1. 사용자 회원가입: POST /api/users
2. 로그인: POST /api/auth/login → JWT 토큰 발급
3. 프로젝트 생성: POST /api/projects (인증 필요)
4. 이슈 생성: POST /api/projects/{id}/issues
5. 댓글 추가: POST /api/issues/{id}/comments
6. 이슈 상태 변경: PUT /api/issues/{id} (assignee 설정 + status 변경)
7. 트랜잭션: 댓글 추가 + 이슈 상태 자동 변경 (원자성 보장)
```

---

## 4. Stage별 로드맵 개요

Stage는 **"검증 가능한 기능 단위"** 기준으로 나눈다.

* **Stage 1**: Spring Boot 기초 & CRUD (S2.0-S2.1)
* **Stage 2**: 인증/권한 & 운영 패턴 (S2.2-S2.3)
* **Stage 3**: 외부 시스템 통합 & 인프라 (S2.4-S2.6)

각 Stage마다:

* 필요 기술
* 만들어야 할 최소 기능
* 통과 체크리스트

를 명확하게 정의한다.

---

## 5. Stage 1 – Spring Boot 기초 & CRUD (S2.0-S2.1)

### 5.1 Stage 1의 목표

* Spring Boot 프로젝트 골격을 구축하고 CI를 세팅할 수 있고,
* **Controller / Service / Repository** 패턴으로 **CRUD API**를 만들 수 있고,
* JWT 인증과 Bean Validation을 적용할 수 있으며,
* **@Transactional**로 복합 연산의 원자성을 보장할 수 있는 수준.

이 Stage에서는 **RBAC, 배치, 검색, 이벤트는 아직 안 건드린다.**
목표는 "Spring Boot의 기본 패턴에 적응하는 것".

### 5.2 다루는 기술

* **S2.0 - Bootstrap & CI**

  * Spring Boot 프로젝트 생성 (Spring Initializr)
  * 환경 설정 (application.yml, profiles)
  * Spring Data JPA + H2 Database
  * 헬스 체크 엔드포인트 (`GET /api/health`)
  * GitHub Actions CI 파이프라인

* **S2.1 - Layered CRUD & Transaction**

  * Controller / Service / Repository 패턴
  * DTO (Bean Validation)
  * JWT 인증 (Spring Security + jjwt)
  * @Transactional (JPA 트랜잭션)
  * Issue Tracker 도메인 (User, Project, Issue, Comment)

### 5.3 이 Stage에서 완성해야 할 기능

**S2.0 최소 기능**:

1. **Spring Boot 앱 생성 & 환경 설정**

   * `./gradlew bootRun`, JPA 설정
   * `application-local.yml`, `application-test.yml`

2. **헬스 체크 엔드포인트**

   * `GET /api/health` → `{ "status": "OK", "timestamp": "..." }`

3. **CI 파이프라인**

   * GitHub Actions: `./gradlew test`, `./gradlew build` 자동 실행

**S2.1 최소 기능**:

1. **사용자 & 인증**

   * `POST /api/users` - 회원가입
   * `POST /api/auth/login` - JWT 발급

2. **Issue Tracker CRUD**

   * `POST /api/projects` - 프로젝트 생성
   * `POST /api/projects/{id}/issues` - 이슈 생성
   * `GET /api/issues/{id}` - 이슈 조회
   * `PUT /api/issues/{id}` - 이슈 수정
   * `POST /api/issues/{id}/comments` - 댓글 추가

3. **트랜잭션 예시**

   * 댓글 추가 + 이슈 상태 자동 변경 (원자성 보장)

### 5.4 통과 체크리스트

* [ ] Spring Boot 프로젝트를 생성하고, `./gradlew bootRun`으로 로컬에서 실행할 수 있다.
* [ ] GitHub Actions CI가 push 시마다 자동으로 돌아가고, 테스트가 통과한다.
* [ ] Controller / Service / Repository 패턴을 이해하고, 각 레이어의 역할을 설명할 수 있다.
* [ ] DTO를 정의하고 Bean Validation으로 요청 검증을 할 수 있다.
* [ ] JWT 인증을 구현하고, Spring Security로 보호된 엔드포인트를 만들 수 있다.
* [ ] @Transactional을 사용해서 여러 테이블 변경을 원자적으로 처리할 수 있다.

Stage 1이 끝나면 **"Spring Boot의 핵심 패턴으로 CRUD API를 혼자 만들 수 있는 상태"**가 된다.

---

## 6. Stage 2 – 인증/권한 & 운영 패턴 (S2.2-S2.3)

### 6.1 Stage 2의 목표

* **팀 기반 RBAC**를 커스텀 어노테이션으로 구현할 수 있고,
* **배치 작업**으로 통계를 주기적으로 집계할 수 있으며,
* **캐싱**으로 반복 조회 성능을 개선하고,
* **외부 HTTP API**를 타임아웃/재시도와 함께 안전하게 호출할 수 있는 것.

이 Stage까지가 사실상 "실무에서 바로 써먹을 수 있는 수준"이다.
Stage 3는 여기서 더 내려가고 싶을 때만 선택.

### 6.2 다루는 기술

* **S2.2 - Team & RBAC**

  * Team, TeamMember 도메인
  * 커스텀 어노테이션 + @PreAuthorize
  * 401 (미인증) / 403 (권한 없음) / 404 (리소스 없음) 구분
  * 팀 멤버 역할 관리 (OWNER, MANAGER, MEMBER)

* **S2.3 - Batch, Stats, Cache, External API**

  * @Scheduled - 배치 작업
  * 통계 테이블 설계 (`DailyIssueStats`)
  * @Cacheable - Simple/Redis 캐싱
  * RestTemplate/WebClient - 외부 API 호출 + 재시도

### 6.3 이 Stage에서 완성해야 할 기능

**S2.2 최소 기능**:

1. **팀 관리**

   * `POST /api/teams` - 팀 생성 (OWNER로 생성)
   * `POST /api/teams/{id}/members` - 멤버 추가 (OWNER/MANAGER만)
   * `PATCH /api/teams/{id}/members/{memberId}` - 역할 변경

2. **워크스페이스 리소스 접근 제어**

   * `POST /api/teams/{teamId}/items` - 팀 멤버만 생성 가능
   * `GET /api/items/{id}` - 팀 멤버만 조회 가능

**S2.3 최소 기능**:

1. **배치 작업**

   * 매일 새벽 3시: 어제의 이슈 생성/해결/댓글 수 집계 → `DailyIssueStats` 테이블에 저장

2. **통계 조회 API**

   * `GET /api/stats/daily?from=2025-01-01&to=2025-01-31` - 날짜 범위 통계

3. **인기 이슈 캐싱**

   * `GET /api/issues/popular` - 최근 7일간 조회수+댓글 수 기준 상위 10개 (캐시 TTL 5분)

4. **외부 API 연동**

   * `GET /api/external/posts/{id}` - JSONPlaceholder 등 외부 API 호출 (타임아웃 3초, 재시도 3회)

### 6.4 통과 체크리스트

**S2.2**:

* [ ] 팀 OWNER/MANAGER/MEMBER 역할을 구분하고, @PreAuthorize로 권한을 체크할 수 있다.
* [ ] 같은 API를 다른 역할로 호출했을 때 401/403/404를 올바르게 반환한다.
* [ ] 커스텀 어노테이션 (`@RequireRole()` 등)을 만들고 사용할 수 있다.

**S2.3**:

* [ ] @Scheduled로 배치 작업을 구현하고, 특정 시각에 자동 실행되도록 할 수 있다.
* [ ] 통계 테이블을 설계하고, 날짜 범위 조회 API를 만들 수 있다.
* [ ] @Cacheable을 적용하고, 같은 요청이 반복될 때 DB 조회가 줄어드는 것을 확인할 수 있다.
* [ ] 외부 HTTP API를 호출하고, 타임아웃/재시도를 처리할 수 있다.

여기까지 구현하면, **실전 운영에 필요한 핵심 패턴을 모두 경험한 상태**다.

---

## 7. Stage 3 – 외부 시스템 통합 & 인프라 (S2.4-S2.6)

### 7.1 Stage 3의 목표

이 Stage는 **선택 사항**이다. S2.4-S2.5는 검색 엔진, 메시지 큐 같은 외부 시스템 통합을 경험하고 싶을 때, S2.6은 프로덕션 배포를 준비할 때 들어간다.

목표는:

* Elasticsearch로 **전문 검색** 기능을 구현하고,
* Kafka로 **비동기 이벤트 처리** 아키텍처를 경험하며,
* PostgreSQL, Redis, Docker로 **프로덕션 인프라**를 구축하는 것.

### 7.2 다루는 기술

* **S2.4 - Elasticsearch Search**

  * Elasticsearch Java Client
  * 상품 카탈로그 도메인
  * 전문 검색 API
  * DB-ES 동기화 전략

* **S2.5 - Kafka Async Events**

  * Spring Kafka
  * Producer/Consumer 패턴
  * 주문 이벤트 발행 → 알림 생성
  * Event-driven architecture

* **S2.6 - Production Infrastructure**

  * PostgreSQL (프로덕션 DB)
  * Redis (분산 캐싱)
  * Docker & Docker Compose
  * 환경별 설정 전략 (로컬/Docker/프로덕션)

### 7.3 이 Stage에서 완성해야 할 기능

**S2.4 최소 기능**:

1. **상품 CRUD (DB 기준)**

   * `POST /api/products` - 상품 생성 → DB + ES 인덱싱
   * `PUT /api/products/{id}` - 상품 수정 → DB + ES 갱신

2. **검색 API**

   * `GET /api/search/products?q=키워드&category=전자제품&minPrice=10000` - ES 쿼리 실행

3. **재색인 관리자 엔드포인트**

   * `POST /api/admin/reindex/products` - 전체 상품 재색인

**S2.5 최소 기능**:

1. **주문 생성 (Producer)**

   * `POST /api/orders` - 주문 생성 → DB 저장 → `ORDER_CREATED` 이벤트 발행

2. **알림 Consumer**

   * `ORDER_CREATED` 이벤트 수신 → `Notification` 테이블에 알림 생성

3. **비동기 특성 확인**

   * 주문 API는 이벤트 발행 후 바로 201 응답
   * 알림은 나중에 Consumer가 처리

**S2.6 최소 기능**:

1. **PostgreSQL 전환**

   * application-prod.yml에 PostgreSQL 설정
   * Hibernate dialect 변경
   * Docker Compose로 PostgreSQL 16 실행

2. **Redis 캐시 통합**

   * CacheConfig에 Redis 설정 추가
   * Fallback 전략 (Redis 미설정 시 Simple 캐시)
   * 기존 캐싱 코드 호환성 유지

3. **Docker 컨테이너화**

   * Dockerfile 작성 (Multi-stage build)
   * docker-compose.yml로 전체 스택 오케스트레이션
   * 환경 변수 관리 (.env.example)

4. **검증**

   * `docker-compose up -d`로 전체 스택 실행
   * 헬스 체크, PostgreSQL 연결, Redis 캐시 동작 확인

### 7.4 통과 체크리스트

**S2.4**:

* [ ] Elasticsearch 클라이언트를 Spring Boot에 통합하고, 인덱스를 생성할 수 있다.
* [ ] 상품 생성/수정 시 DB와 ES를 동기화할 수 있다.
* [ ] 전문 검색 API를 구현하고, 키워드/필터로 검색 결과를 반환할 수 있다.
* [ ] 전체 재색인 엔드포인트를 만들고, DB 데이터를 ES에 일괄 동기화할 수 있다.

**S2.5**:

* [ ] Kafka Producer를 구현하고, 도메인 이벤트를 발행할 수 있다.
* [ ] Kafka Consumer를 구현하고, 이벤트를 수신해서 처리할 수 있다.
* [ ] 주문 생성 → 이벤트 발행 → 알림 생성 플로우가 비동기로 동작하는 것을 확인할 수 있다.
* [ ] Consumer 중단/재시작 시에도 이벤트가 누락되지 않는 것을 확인할 수 있다.

**S2.6**:

* [ ] application-prod.yml에 PostgreSQL 설정을 추가하고 연결할 수 있다.
* [ ] Docker Compose로 PostgreSQL + Redis를 실행하고 애플리케이션이 연결되는 것을 확인할 수 있다.
* [ ] Redis 캐시가 동작하고, 캐시 히트 시 DB 조회가 발생하지 않는 것을 확인할 수 있다.
* [ ] Dockerfile을 작성하고 `docker-compose build`로 이미지를 빌드할 수 있다.
* [ ] 전체 스택을 `docker-compose up -d`로 실행하고 모든 서비스가 정상 동작하는 것을 확인할 수 있다.
* [ ] 로컬 개발(H2 + Simple), Docker(PostgreSQL + Redis) 환경을 모두 지원할 수 있다.

---

## 8. 정리: 학습 순서 요약

추천 순서는 아래와 같다.

1. **문서 1 (지금 이 문서)**

   * 전체 구조/Stage/목표 확인

2. **문서 2 – Spring Boot 기초 & CRUD (S2.0-S2.1)**

   * Stage 1 내용을 채우는 문서
   * Bootstrap, CI, Layered architecture, JWT, Transaction까지

3. **문서 3 – 고급 패턴 I: 인증/운영 (S2.2-S2.3)**

   * Stage 2 전반부
   * RBAC, Batch, Cache, External API

4. **문서 4 – 고급 패턴 II: 외부 시스템 & 인프라 (S2.4-S2.6)**

   * Stage 3 전체
   * Elasticsearch, Kafka (선택)
   * PostgreSQL, Redis, Docker (프로덕션 준비)

이 문서는 여기까지.
다음 단계로는 **문서 2**에서 Stage 1 내용을 실제 코드/예제로 채우면 된다.
