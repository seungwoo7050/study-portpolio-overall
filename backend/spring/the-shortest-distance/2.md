# 문서 2. Spring Boot 기초 & CRUD (S2.0-S2.1)

> 이 문서는 **Stage 1** 용이다.
> 전제:
>
> * 기본적인 프로그래밍 경험은 있음
> * Java 기초 문법은 어느 정도 알고 있거나 빠르게 익힐 수 있음
> * 이제 **Spring Boot로 REST API 서버**를 만들고, **CI 파이프라인**을 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* Java 17+ 설치 가능
* Gradle 또는 Maven 사용 가능
* Git + GitHub 기본 사용 가능
* HTTP/REST API 개념 이해

### 이 문서의 목표

1. **Spring Boot 프로젝트 골격** 구축 (S2.0)
2. **GitHub Actions CI** 파이프라인 설정
3. **Controller / Service / Repository** 패턴 이해
4. **DTO validation** + **JWT 인증** 적용
5. **@Transactional**로 복합 연산 처리

### 이 문서가 다루는 범위

* **S2.0**: Spring Boot Bootstrap & CI Baseline
* **S2.1**: Layered CRUD & Transaction Pattern

**다루지 않는 범위** (다음 문서 3, 4에서):

* S2.2: Team & RBAC
* S2.3: Batch, Cache, External API
* S2.4-S2.6: Elasticsearch, Kafka, Infrastructure

---

## 1. Java + Spring Boot 핵심 개념

### 1.1 Java 최소 필수 개념

**타입 선언**:

```java
String name = "Alice";
int age = 30;
List<String> tags = List.of("backend", "spring");
```

**클래스와 생성자**:

```java
public class User {
    private final Long id;
    private final String email;

    public User(Long id, String email) {
        this.id = id;
        this.email = email;
    }

    // Getter만 제공 (불변 객체 선호)
    public Long getId() { return id; }
    public String getEmail() { return email; }
}
```

**인터페이스**:

```java
public interface UserRepository {
    User findById(Long id);
    void save(User user);
}
```

**레코드 (Java 14+)**:

```java
// DTO에 유용 (자동으로 생성자, getter, equals, hashCode 생성)
public record CreateUserRequest(String email, String password) {}
```

### 1.2 Spring Boot 핵심 개념

#### 1.2.1 의존성 주입 (Dependency Injection)

**생성자 주입 (권장)**:

```java
@Service
public class IssueService {
    private final IssueRepository issueRepository;

    // 생성자 주입 (@Autowired 생략 가능)
    public IssueService(IssueRepository issueRepository) {
        this.issueRepository = issueRepository;
    }

    public Issue createIssue(CreateIssueDto dto) {
        // ...
    }
}
```

**왜 생성자 주입인가?**
- 불변성 (final 필드)
- 테스트 용이성 (mock 주입 쉬움)
- 순환 의존성 조기 발견

#### 1.2.2 레이어 구조

```text
[Controller] → [Service] → [Repository] → [DB]
    ↓               ↓            ↓
  DTO 검증      비즈니스 로직   데이터 접근
```

**각 레이어의 역할**:

* **Controller**: HTTP 요청/응답 처리, DTO 검증
* **Service**: 비즈니스 로직, 트랜잭션 경계
* **Repository**: 데이터 접근 (JPA, JDBC)

#### 1.2.3 어노테이션

```java
@RestController           // Controller 레이어
@Service                  // Service 레이어
@Repository               // Repository 레이어
@Component                // 일반 빈
@Configuration            // 설정 클래스
@Bean                     // 빈 정의 메서드
@Transactional            // 트랜잭션 경계
@RequestMapping("/api")   // URL 매핑
@GetMapping, @PostMapping // HTTP 메서드 매핑
```

---

## 2. S2.0: Spring Boot Bootstrap & CI Baseline

### 2.1 프로젝트 생성

**Spring Initializr** 사용:

```bash
# 또는 https://start.spring.io에서 GUI로 생성
./gradlew init --type spring-boot
```

**필수 의존성**:
- Spring Web
- Spring Data JPA
- H2 Database
- Validation
- Lombok (선택)

**build.gradle**:

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.5'
    id 'io.spring.dependency-management' version '1.1.6'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
java {
    sourceCompatibility = '17'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    runtimeOnly 'com.h2database:h2'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

### 2.2 Application.java (부트스트랩)

```java
package com.example.training;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**@SpringBootApplication**이 하는 일:
- `@Configuration`: 설정 클래스
- `@EnableAutoConfiguration`: 자동 설정
- `@ComponentScan`: 하위 패키지 스캔

### 2.3 환경 설정 파일

**application.yml** (공통):

```yaml
spring:
  application:
    name: training
  profiles:
    active: local

server:
  port: 8080
```

**application-local.yml** (로컬 개발):

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

**application-test.yml** (테스트):

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
```

### 2.4 헬스 체크 엔드포인트

**HealthResponse.java**:

```java
package com.example.training.common.dto;

import java.time.LocalDateTime;

public record HealthResponse(String status, LocalDateTime timestamp) {
    public static HealthResponse ok() {
        return new HealthResponse("OK", LocalDateTime.now());
    }
}
```

**HealthController.java**:

```java
package com.example.training.common.controller;

import com.example.training.common.dto.HealthResponse;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/health")
public class HealthController {

    @GetMapping
    public HealthResponse health() {
        return HealthResponse.ok();
    }
}
```

**실행 & 테스트**:

```bash
./gradlew bootRun

# 다른 터미널에서
curl http://localhost:8080/api/health
# {"status":"OK","timestamp":"2025-01-15T10:30:00"}
```

### 2.5 GitHub Actions CI

**.github/workflows/ci.yml**:

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
      working-directory: backend/spring

    - name: Build with Gradle
      run: ./gradlew build
      working-directory: backend/spring

    - name: Run tests
      run: ./gradlew test
      working-directory: backend/spring
```

---

## 3. S2.1: Layered CRUD & Transaction Pattern

### 3.1 도메인 모델 (JPA Entity)

**User.java**:

```java
package com.example.training.user.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;  // 실제로는 BCrypt 해시

    @Column(nullable = false)
    private LocalDateTime createdAt;

    protected User() {}  // JPA 요구사항

    public User(String email, String password) {
        this.email = email;
        this.password = password;
        this.createdAt = LocalDateTime.now();
    }

    // Getters
    public Long getId() { return id; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

**Issue.java**:

```java
package com.example.training.issue.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "issues")
public class Issue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private IssueStatus status = IssueStatus.OPEN;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id", nullable = false)
    private Project project;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reporter_id", nullable = false)
    private User reporter;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignee_id")
    private User assignee;

    @Column(nullable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    protected Issue() {}

    public Issue(String title, String description, Project project, User reporter) {
        this.title = title;
        this.description = description;
        this.project = project;
        this.reporter = reporter;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // 비즈니스 메서드
    public void updateStatus(IssueStatus newStatus) {
        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }

    public void assignTo(User user) {
        this.assignee = user;
        this.updatedAt = LocalDateTime.now();
    }

    // Getters
    public Long getId() { return id; }
    public String getTitle() { return title; }
    public String getDescription() { return description; }
    public IssueStatus getStatus() { return status; }
    public Project getProject() { return project; }
    public User getReporter() { return reporter; }
    public User getAssignee() { return assignee; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
}
```

**IssueStatus.java**:

```java
package com.example.training.issue.domain;

public enum IssueStatus {
    OPEN,
    IN_PROGRESS,
    RESOLVED,
    CLOSED
}
```

### 3.2 DTO (Data Transfer Object)

**CreateIssueDto.java**:

```java
package com.example.training.issue.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public record CreateIssueDto(
    @NotNull(message = "Project ID is required")
    Long projectId,

    @NotBlank(message = "Title is required")
    String title,

    String description
) {}
```

**IssueResponse.java**:

```java
package com.example.training.issue.dto;

import com.example.training.issue.domain.Issue;
import com.example.training.issue.domain.IssueStatus;

import java.time.LocalDateTime;

public record IssueResponse(
    Long id,
    String title,
    String description,
    IssueStatus status,
    Long projectId,
    Long reporterId,
    Long assigneeId,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    public static IssueResponse from(Issue issue) {
        return new IssueResponse(
            issue.getId(),
            issue.getTitle(),
            issue.getDescription(),
            issue.getStatus(),
            issue.getProject().getId(),
            issue.getReporter().getId(),
            issue.getAssignee() != null ? issue.getAssignee().getId() : null,
            issue.getCreatedAt(),
            issue.getUpdatedAt()
        );
    }
}
```

### 3.3 Repository

**IssueRepository.java**:

```java
package com.example.training.issue.repository;

import com.example.training.issue.domain.Issue;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface IssueRepository extends JpaRepository<Issue, Long> {

    List<Issue> findByProjectId(Long projectId);

    @Query("SELECT i FROM Issue i WHERE i.assignee.id = :userId")
    List<Issue> findByAssigneeId(Long userId);
}
```

**Spring Data JPA**가 자동으로 구현 제공:
- `save()`, `findById()`, `findAll()`, `delete()` 등
- 메서드 이름 기반 쿼리 생성 (`findByProjectId`)
- `@Query` 어노테이션으로 커스텀 쿼리

### 3.4 Service

**IssueService.java**:

```java
package com.example.training.issue.service;

import com.example.training.issue.domain.Issue;
import com.example.training.issue.dto.CreateIssueDto;
import com.example.training.issue.dto.IssueResponse;
import com.example.training.issue.repository.IssueRepository;
import com.example.training.project.domain.Project;
import com.example.training.project.repository.ProjectRepository;
import com.example.training.user.domain.User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Transactional(readOnly = true)
public class IssueService {
    private final IssueRepository issueRepository;
    private final ProjectRepository projectRepository;

    public IssueService(IssueRepository issueRepository,
                       ProjectRepository projectRepository) {
        this.issueRepository = issueRepository;
        this.projectRepository = projectRepository;
    }

    @Transactional
    public IssueResponse createIssue(CreateIssueDto dto, User reporter) {
        Project project = projectRepository.findById(dto.projectId())
            .orElseThrow(() -> new IllegalArgumentException("Project not found"));

        Issue issue = new Issue(dto.title(), dto.description(), project, reporter);
        Issue saved = issueRepository.save(issue);

        return IssueResponse.from(saved);
    }

    public IssueResponse getIssue(Long id) {
        Issue issue = issueRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Issue not found"));
        return IssueResponse.from(issue);
    }

    public List<IssueResponse> getProjectIssues(Long projectId) {
        return issueRepository.findByProjectId(projectId).stream()
            .map(IssueResponse::from)
            .toList();
    }
}
```

**@Transactional**:
- 클래스 레벨: `readOnly = true` (조회 최적화)
- 메서드 레벨: `@Transactional` (쓰기 작업, readOnly 오버라이드)

### 3.5 Controller

**IssueController.java**:

```java
package com.example.training.issue.controller;

import com.example.training.issue.dto.CreateIssueDto;
import com.example.training.issue.dto.IssueResponse;
import com.example.training.issue.service.IssueService;
import com.example.training.user.domain.User;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/issues")
public class IssueController {
    private final IssueService issueService;

    public IssueController(IssueService issueService) {
        this.issueService = issueService;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public IssueResponse createIssue(
        @Valid @RequestBody CreateIssueDto dto,
        @AuthenticationPrincipal User user
    ) {
        return issueService.createIssue(dto, user);
    }

    @GetMapping("/{id}")
    public IssueResponse getIssue(@PathVariable Long id) {
        return issueService.getIssue(id);
    }

    @GetMapping("/project/{projectId}")
    public List<IssueResponse> getProjectIssues(@PathVariable Long projectId) {
        return issueService.getProjectIssues(projectId);
    }
}
```

**어노테이션 설명**:
- `@RestController`: `@Controller` + `@ResponseBody`
- `@RequestMapping`: 기본 URL 경로
- `@PostMapping`, `@GetMapping`: HTTP 메서드 매핑
- `@Valid`: DTO 검증 트리거
- `@RequestBody`: JSON → 객체 변환
- `@PathVariable`: URL 경로 변수
- `@AuthenticationPrincipal`: 인증된 사용자 주입

### 3.6 JWT 인증

**build.gradle** (의존성 추가):

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}
```

**JwtUtil.java**:

```java
package com.example.training.auth.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtil {
    private final Key key;
    private final long expirationMs;

    public JwtUtil(
        @Value("${jwt.secret}") String secret,
        @Value("${jwt.expiration-ms}") long expirationMs
    ) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes());
        this.expirationMs = expirationMs;
    }

    public String generateToken(String email) {
        return Jwts.builder()
            .setSubject(email)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
    }

    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

**SecurityConfig.java**:

```java
package com.example.training.common.config;

import com.example.training.auth.filter.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/health", "/api/auth/**", "/api/users").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 3.7 트랜잭션 예시

**CommentService.java** (댓글 추가 + 이슈 상태 변경):

```java
package com.example.training.comment.service;

import com.example.training.comment.domain.Comment;
import com.example.training.comment.dto.CreateCommentDto;
import com.example.training.comment.repository.CommentRepository;
import com.example.training.issue.domain.Issue;
import com.example.training.issue.domain.IssueStatus;
import com.example.training.issue.repository.IssueRepository;
import com.example.training.user.domain.User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CommentService {
    private final CommentRepository commentRepository;
    private final IssueRepository issueRepository;

    public CommentService(CommentRepository commentRepository,
                         IssueRepository issueRepository) {
        this.commentRepository = commentRepository;
        this.issueRepository = issueRepository;
    }

    @Transactional
    public void addCommentAndUpdateStatus(CreateCommentDto dto, User author) {
        // 1. 댓글 생성
        Issue issue = issueRepository.findById(dto.issueId())
            .orElseThrow(() -> new IllegalArgumentException("Issue not found"));

        Comment comment = new Comment(dto.content(), issue, author);
        commentRepository.save(comment);

        // 2. 이슈 상태 변경 (예: OPEN → IN_PROGRESS)
        if (issue.getStatus() == IssueStatus.OPEN) {
            issue.updateStatus(IssueStatus.IN_PROGRESS);
            // save() 불필요 - @Transactional이 자동으로 변경 감지
        }

        // 트랜잭션 종료 시:
        // - 성공: 모두 커밋
        // - 예외 발생: 모두 롤백
    }
}
```

**@Transactional의 이점**:
- 원자성: 모두 성공 또는 모두 실패
- 변경 감지 (Dirty Checking): 엔티티 변경 자동 감지 & UPDATE
- 예외 발생 시 자동 롤백

---

## 4. S2.0-S2.1 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 1 (S2.0-S2.1)은 통과로 본다.

### S2.0 체크리스트 (Bootstrap & CI)

* [ ] Spring Boot 프로젝트를 생성하고, `./gradlew bootRun`으로 로컬에서 실행할 수 있다.
* [ ] `application.yml` 및 프로파일별 설정 파일을 작성할 수 있다.
* [ ] 헬스 체크 엔드포인트 (`GET /api/health`)를 구현하고 응답을 확인할 수 있다.
* [ ] GitHub Actions CI 워크플로우를 작성하고, push 시 자동 빌드/테스트가 실행된다.

### S2.1 체크리스트 (Layered CRUD)

* [ ] JPA Entity를 정의하고 H2 데이터베이스에 테이블을 생성할 수 있다.
* [ ] Spring Data JPA Repository를 작성하고 CRUD 메서드를 사용할 수 있다.
* [ ] Service 레이어에 비즈니스 로직을 작성하고 @Transactional을 적용할 수 있다.
* [ ] Controller에서 DTO를 받아 검증하고 Service를 호출할 수 있다.
* [ ] JWT 토큰을 생성/검증하고, Spring Security로 인증된 엔드포인트를 보호할 수 있다.
* [ ] @Transactional을 사용해서 여러 테이블 변경을 원자적으로 처리할 수 있다.
* [ ] Bean Validation (@NotBlank, @NotNull 등)으로 DTO 검증을 할 수 있다.

여기까지 구현하면:

* **Spring Boot 기본 프로젝트 구조** 이해
* **3-Layer Architecture** (Controller/Service/Repository) 숙지
* **REST API CRUD** 구현 가능
* **JWT 인증** 적용 가능
* **트랜잭션** 관리 가능
* **CI 파이프라인** 구축 완료

상태가 된다. 다음은 **문서 3**에서 RBAC, 배치, 캐싱 패턴을 익힌다.

---

## 5. 참고 자료

* [Spring Boot 공식 문서](https://spring.io/projects/spring-boot)
* [Spring Data JPA 공식 문서](https://spring.io/projects/spring-data-jpa)
* [Spring Security 공식 문서](https://spring.io/projects/spring-security)
* [Java 17 문서](https://docs.oracle.com/en/java/javase/17/)
* [Gradle 공식 문서](https://docs.gradle.org/)
