# 문서 2. Spring Boot 기초 & CRUD (S2.0-S2.1)

> 이 문서는 **Stage 1** 용이다.
> 전제:
>
> * 기본적인 프로그래밍 경험은 있음
> * Java 기초 문법은 어느 정도 알고 있거나 빠르게 익힐 수 있음
> * 이제 **Spring Boot로 REST API 서버**를 만들고, **CI 파이프라인**을 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* Java 17+ 설치 가능
* Gradle 또는 Maven 사용 가능
* Git + GitHub 기본 사용 가능
* HTTP/REST API 개념 이해

### 이 문서의 목표

1. **Spring Boot 프로젝트 골격** 구축 (S2.0)
2. **GitHub Actions CI** 파이프라인 설정
3. **Controller / Service / Repository** 패턴 이해
4. **DTO validation** + **JWT 인증** 적용
5. **@Transactional**로 복합 연산 처리

### 이 문서가 다루는 범위

* **S2.0**: Spring Boot Bootstrap & CI Baseline
* **S2.1**: Layered CRUD & Transaction Pattern

**다루지 않는 범위** (다음 문서 3, 4에서):

* S2.2: Team & RBAC
* S2.3: Batch, Cache, External API
* S2.4-S2.6: Elasticsearch, Kafka, Infrastructure

---

## 1. Java + Spring Boot 핵심 개념

### 1.1 C에서 Java로: 핵심 차이점

**C 프로그래머를 위한 Java 요약:**

| 측면 | C | Java |
|------|---|------|
| 메모리 관리 | 수동 (malloc/free) | 자동 (가비지 컬렉터) |
| 포인터 | 명시적 포인터 | 참조 (포인터 숨김) |
| 문자열 | char* | String 객체 |
| 배열 | 고정 크기 | 동적 크기 가능 (ArrayList 등) |
| 함수 | 전역 함수 | 클래스 메서드 |
| 구조체 | struct | class (+ 메서드 포함) |
| 헤더 파일 | .h 필요 | 불필요 (패키지 시스템) |
| 컴파일 | 기계어 직접 | 바이트코드 → JVM |

### 1.2 Java 기본 문법

#### 1.2.1 기본 타입과 변수

**C와 비슷한 기본 타입**:

```java
// 정수
byte b = 127;           // 8비트 (-128 ~ 127)
short s = 32767;        // 16비트
int i = 2147483647;     // 32비트 (가장 많이 사용)
long l = 9223372036854775807L;  // 64비트

// 실수
float f = 3.14f;        // 32비트
double d = 3.14159;     // 64비트 (가장 많이 사용)

// 논리
boolean flag = true;    // true 또는 false

// 문자
char c = 'A';           // 16비트 유니코드
```

**참조 타입 (Reference Type)**:

```java
// String (불변 객체)
String name = "Alice";              // C의 char*와 다름!
String greeting = "Hello " + name;  // 연결 가능
int length = name.length();         // 메서드 호출

// 배열 (C와 유사하지만 더 안전)
int[] numbers = {1, 2, 3, 4, 5};   // C: int numbers[] = {...}
int[] arr = new int[10];            // C: int arr[10]
int size = numbers.length;          // C: sizeof(numbers)/sizeof(int)

// null (C의 NULL)
String empty = null;                // 참조가 없음을 의미
```

#### 1.2.2 클래스와 객체 (C의 구조체 + 함수)

**C 구조체와 비교**:

```c
// C 스타일
typedef struct {
    int id;
    char name[50];
} User;

void print_user(User* user) {
    printf("%d: %s\n", user->id, user->name);
}

User user = {1, "Alice"};
print_user(&user);
```

**Java 클래스로 변환**:

```java
// Java 스타일
public class User {
    // 필드 (C의 struct 멤버)
    private int id;
    private String name;

    // 생성자 (초기화)
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // 메서드 (C의 함수, 하지만 객체에 속함)
    public void print() {
        System.out.println(id + ": " + name);
    }

    // Getter (외부에서 필드 읽기)
    public int getId() { return id; }
    public String getName() { return name; }
}

// 사용법
User user = new User(1, "Alice");  // C: malloc + 초기화
user.print();                       // C: print_user(&user)
int id = user.getId();              // C: user.id (하지만 캡슐화)
```

**왜 private/public인가?**
- `private`: 외부에서 직접 접근 불가 (캡슐화)
- `public`: 외부에서 접근 가능
- `protected`: 상속받은 클래스에서만 접근
- (생략): 같은 패키지 내에서만 접근

#### 1.2.3 패키지와 import (C의 헤더 대신)

**C의 헤더 파일**:

```c
// user.h
#ifndef USER_H
#define USER_H
typedef struct { ... } User;
void print_user(User* user);
#endif

// main.c
#include "user.h"
```

**Java의 패키지 시스템**:

```java
// com/example/training/user/User.java
package com.example.training.user;  // 네임스페이스

public class User {
    // ... 클래스 내용
}

// com/example/training/Application.java
package com.example.training;

import com.example.training.user.User;  // 다른 패키지에서 가져오기
// 또는
import com.example.training.user.*;     // 전체 가져오기

public class Application {
    public static void main(String[] args) {
        User user = new User(1, "Alice");
    }
}
```

**패키지 규칙**:
- 도메인 역순: `com.example.training`
- 폴더 구조와 일치: `com/example/training/User.java`
- 같은 패키지 내에서는 import 불필요

#### 1.2.4 컬렉션 (동적 자료구조)

**C에서는 직접 구현해야 하는 것들**:

```java
import java.util.*;

// 동적 배열 (C: 직접 realloc 필요)
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.add("Charlie");
String first = names.get(0);        // Alice
int size = names.size();            // 3
names.remove("Bob");                // 삭제

// 해시맵 (C: 직접 구현 필요)
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 30);
ages.put("Bob", 25);
int aliceAge = ages.get("Alice");   // 30
boolean hasKey = ages.containsKey("Alice");

// 집합 (중복 불허)
Set<String> uniqueNames = new HashSet<>();
uniqueNames.add("Alice");
uniqueNames.add("Alice");  // 무시됨
// size는 1
```

**제네릭 (Generic)**:
- `List<String>`: String만 담는 리스트
- `Map<String, Integer>`: String 키, Integer 값
- 컴파일 타임에 타입 체크 (안전성)

#### 1.2.5 람다와 스트림 (함수형 프로그래밍)

**C 스타일 반복**:

```c
// C
int sum = 0;
for (int i = 0; i < size; i++) {
    if (numbers[i] % 2 == 0) {
        sum += numbers[i];
    }
}
```

**Java 스트림**:

```java
// Java (선언적 스타일)
List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);

int sum = numbers.stream()
    .filter(n -> n % 2 == 0)      // 짝수만
    .mapToInt(n -> n)
    .sum();                        // 합계: 12

// 또는 메서드 참조
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .toList();
```

**람다 표현식**:
- `n -> n % 2 == 0`: 익명 함수 (C의 함수 포인터와 유사)
- `(a, b) -> a + b`: 두 인자를 받는 함수
- 간결한 코드 작성 가능

#### 1.2.6 예외 처리 (C의 에러 코드 대신)

**C 스타일 에러 처리**:

```c
// C
int read_file(const char* path, char* buffer) {
    FILE* f = fopen(path, "r");
    if (f == NULL) {
        return -1;  // 에러 코드
    }
    // ...
    fclose(f);
    return 0;  // 성공
}

int result = read_file("file.txt", buffer);
if (result != 0) {
    printf("Error reading file\n");
}
```

**Java 예외 처리**:

```java
// Java
public String readFile(String path) throws IOException {
    try {
        return Files.readString(Path.of(path));
    } catch (IOException e) {
        throw new RuntimeException("Failed to read file: " + path, e);
    }
}

// 사용 시
try {
    String content = readFile("file.txt");
} catch (RuntimeException e) {
    System.err.println("Error: " + e.getMessage());
}
```

**예외 종류**:
- **Checked Exception**: 반드시 처리 또는 선언 (`throws IOException`)
- **Unchecked Exception**: 처리 선택 (`RuntimeException`)

### 1.3 Gradle: 빌드 도구

**C의 Makefile과 비교**:

```makefile
# C Makefile
CC = gcc
CFLAGS = -Wall -O2

main: main.o user.o
    $(CC) -o main main.o user.o

main.o: main.c user.h
    $(CC) $(CFLAGS) -c main.c
```

**Gradle (build.gradle)**:

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.5'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
java {
    sourceCompatibility = '17'  // Java 버전
}

repositories {
    mavenCentral()  // 라이브러리 저장소
}

dependencies {
    // Spring Boot 의존성 (자동으로 다운로드)
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'

    // 테스트 의존성
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

**Gradle 명령어**:

```bash
./gradlew build          # C: make
./gradlew clean          # C: make clean
./gradlew test           # 테스트 실행
./gradlew bootRun        # 애플리케이션 실행
./gradlew dependencies   # 의존성 트리 확인
```

**Maven vs Gradle**:
- **Maven**: XML 기반, 오래됨, 더 verbose
- **Gradle**: Groovy/Kotlin 기반, 최신, 더 간결 (Spring 공식 권장)

### 1.4 Spring Boot 핵심 개념

#### 1.4.1 IoC/DI 컨테이너 (Spring의 마법)

**전통적인 방식 (수동 객체 생성)**:

```java
// C 스타일: 모든 것을 직접 관리
public class Application {
    public static void main(String[] args) {
        // 1. 데이터베이스 연결 생성
        Connection conn = DriverManager.getConnection("jdbc:...");

        // 2. Repository 생성
        IssueRepository repo = new IssueRepositoryImpl(conn);

        // 3. Service 생성 (Repository 주입)
        IssueService service = new IssueService(repo);

        // 4. Controller 생성 (Service 주입)
        IssueController controller = new IssueController(service);

        // 의존성 그래프를 수동으로 관리!
    }
}
```

**Spring 방식 (자동 관리)**:

```java
// Spring이 자동으로 객체 생성 & 주입
@RestController
public class IssueController {
    private final IssueService issueService;

    // Spring이 IssueService를 찾아서 자동 주입
    public IssueController(IssueService issueService) {
        this.issueService = issueService;
    }
}

@Service
public class IssueService {
    private final IssueRepository issueRepository;

    // Spring이 IssueRepository를 찾아서 자동 주입
    public IssueService(IssueRepository issueRepository) {
        this.issueRepository = issueRepository;
    }
}

@Repository
public interface IssueRepository extends JpaRepository<Issue, Long> {
    // Spring Data JPA가 구현체를 자동 생성
}
```

**IoC (Inversion of Control)**:
- **전통**: 개발자가 객체 생성 제어
- **IoC**: Spring이 객체 생성 제어
- 제어의 역전

**DI (Dependency Injection)**:
- 객체가 필요한 의존성을 외부에서 주입받음
- 생성자, 세터, 필드 주입 방식 (생성자 권장)

**왜 생성자 주입인가?**
- **불변성**: `final` 필드 사용 가능
- **테스트 용이성**: Mock 객체 주입 쉬움
- **순환 의존성 방지**: 컴파일 타임에 감지
- **명시성**: 필수 의존성이 명확함

#### 1.4.2 Annotation의 비밀 (컴파일러와 런타임)

**Annotation이란?**
- 코드에 메타데이터를 추가하는 방법
- C의 `#pragma`와 유사하지만 훨씬 강력

**Annotation 동작 방식**:

```java
@RestController  // ← 이게 어떻게 동작하는가?
public class IssueController {
    @GetMapping("/api/issues/{id}")  // ← 이것도?
    public IssueResponse getIssue(@PathVariable Long id) {
        // ...
    }
}
```

**내부 동작**:

1. **컴파일 타임**:
   - `@RestController` → `@Controller` + `@ResponseBody`의 합성
   - 컴파일러가 Annotation을 읽고 검증

2. **런타임** (Spring 실행 시):
   - Spring이 모든 클래스를 스캔 (Component Scan)
   - `@RestController` 발견 → Bean으로 등록
   - `@GetMapping` 발견 → HTTP GET /api/issues/{id}로 매핑
   - 요청 오면 → 메서드 호출 → JSON 변환 → 응답

**주요 Annotation들**:

```java
// Bean 등록 (Spring이 관리하는 객체)
@Component          // 일반 컴포넌트
@Service            // 비즈니스 로직 (Component의 특수화)
@Repository         // 데이터 접근 (Component의 특수화)
@Controller         // 웹 컨트롤러
@RestController     // REST API 컨트롤러 (Controller + ResponseBody)
@Configuration      // 설정 클래스

// HTTP 매핑
@RequestMapping("/api")  // 기본 URL
@GetMapping             // GET 요청
@PostMapping            // POST 요청
@PutMapping             // PUT 요청
@DeleteMapping          // DELETE 요청
@PatchMapping           // PATCH 요청

// 파라미터 바인딩
@PathVariable       // URL 경로 변수 (/api/users/{id})
@RequestParam       // 쿼리 파라미터 (?name=Alice)
@RequestBody        // HTTP Body (JSON → 객체)
@RequestHeader      // HTTP 헤더

// 검증
@Valid              // DTO 검증 트리거
@NotNull            // null 불허
@NotBlank           // 빈 문자열 불허
@Size(min=1, max=100) // 길이 제한

// 트랜잭션 & 캐시
@Transactional      // 트랜잭션 경계
@Cacheable          // 캐시 적용
```

#### 1.4.3 JPA/Hibernate (ORM)

**ORM이란?**
- Object-Relational Mapping
- 객체 ↔ 테이블 매핑
- SQL을 직접 작성하지 않음 (대부분)

**C/Java JDBC 방식 (ORM 없이)**:

```java
// 전통적인 JDBC
Connection conn = DriverManager.getConnection("jdbc:...");
PreparedStatement stmt = conn.prepareStatement(
    "SELECT id, email FROM users WHERE id = ?"
);
stmt.setLong(1, userId);
ResultSet rs = stmt.executeQuery();

if (rs.next()) {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setEmail(rs.getString("email"));
}
rs.close();
stmt.close();
conn.close();

// 엄청 길고 반복적!
```

**JPA 방식**:

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String email;

    // Getters & Setters
}

// Repository (인터페이스만 정의)
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    // Spring Data JPA가 SQL 자동 생성:
    // SELECT * FROM users WHERE email = ?
}

// 사용
User user = userRepository.findById(1L).orElseThrow();
// JPA가 자동으로: SELECT * FROM users WHERE id = 1
```

**JPA Entity Annotation**:

```java
@Entity                 // JPA Entity 선언
@Table(name = "users")  // 테이블 이름 (생략 시 클래스명)
public class User {

    @Id                         // 기본 키
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // AUTO_INCREMENT
    private Long id;

    @Column(unique = true, nullable = false, length = 100)
    private String email;       // 컬럼 제약조건

    @Column(columnDefinition = "TEXT")
    private String bio;         // TEXT 타입

    @ManyToOne(fetch = FetchType.LAZY)  // N:1 관계
    @JoinColumn(name = "team_id")
    private Team team;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)  // 1:N 관계
    private List<Issue> issues = new ArrayList<>();
}
```

**Hibernate = JPA 구현체**:
- JPA는 **스펙**(인터페이스)
- Hibernate는 **구현체**
- Spring Boot는 기본으로 Hibernate 사용

#### 1.4.4 레이어 구조 (아키텍처)

```text
[Controller] → [Service] → [Repository] → [DB]
    ↓               ↓            ↓
  DTO 검증      비즈니스 로직   데이터 접근
```

**각 레이어의 역할**:

| 레이어 | 역할 | 예시 |
|--------|------|------|
| **Controller** | HTTP 요청/응답 처리 | `@RestController`, `@GetMapping` |
| **Service** | 비즈니스 로직, 트랜잭션 | `@Service`, `@Transactional` |
| **Repository** | 데이터 접근 | `JpaRepository`, SQL 실행 |
| **Entity** | DB 테이블 매핑 | `@Entity`, `@Table` |
| **DTO** | 데이터 전송 객체 | `CreateUserDto`, `UserResponse` |

**왜 레이어를 나누는가?**
- **단일 책임**: 각 레이어가 하나의 책임만
- **테스트 용이성**: 레이어별 독립 테스트
- **유지보수성**: 변경 영향 범위 최소화
- **재사용성**: Service는 여러 Controller에서 사용

#### 1.4.5 Record (Java 14+, DTO에 최적)

**전통적인 DTO (Boilerplate 코드)**:

```java
// 200줄짜리 DTO 클래스...
public class CreateUserDto {
    private String email;
    private String password;

    public CreateUserDto() {}

    public CreateUserDto(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    @Override
    public boolean equals(Object o) { /* ... */ }

    @Override
    public int hashCode() { /* ... */ }

    @Override
    public String toString() { /* ... */ }
}
```

**Record 사용 (간결!)**:

```java
// 단 1줄!
public record CreateUserDto(String email, String password) {}

// 자동으로 생성되는 것들:
// - 생성자: new CreateUserDto(email, password)
// - Getter: dto.email(), dto.password()
// - equals(), hashCode(), toString()
// - 불변 객체 (final 필드)
```

**Record는 언제 사용?**
- DTO (데이터 전송 객체)
- Value Object (값 객체)
- 불변 데이터가 필요한 곳
- **Entity에는 사용 불가** (JPA는 기본 생성자 필요)

---

## 2. S2.0: Spring Boot Bootstrap & CI Baseline

### 2.1 프로젝트 생성

**Spring Initializr** 사용:

```bash
# 또는 https://start.spring.io에서 GUI로 생성
./gradlew init --type spring-boot
```

**필수 의존성**:
- Spring Web
- Spring Data JPA
- H2 Database
- Validation
- Lombok (선택)

**build.gradle**:

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.3.5'
    id 'io.spring.dependency-management' version '1.1.6'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
java {
    sourceCompatibility = '17'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    runtimeOnly 'com.h2database:h2'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

### 2.2 Application.java (부트스트랩)

```java
package com.example.training;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**@SpringBootApplication**이 하는 일:
- `@Configuration`: 설정 클래스
- `@EnableAutoConfiguration`: 자동 설정
- `@ComponentScan`: 하위 패키지 스캔

### 2.3 환경 설정 파일

**application.yml** (공통):

```yaml
spring:
  application:
    name: training
  profiles:
    active: local

server:
  port: 8080
```

**application-local.yml** (로컬 개발):

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

**application-test.yml** (테스트):

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
```

### 2.4 헬스 체크 엔드포인트

**HealthResponse.java**:

```java
package com.example.training.common.dto;

import java.time.LocalDateTime;

public record HealthResponse(String status, LocalDateTime timestamp) {
    public static HealthResponse ok() {
        return new HealthResponse("OK", LocalDateTime.now());
    }
}
```

**HealthController.java**:

```java
package com.example.training.common.controller;

import com.example.training.common.dto.HealthResponse;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/health")
public class HealthController {

    @GetMapping
    public HealthResponse health() {
        return HealthResponse.ok();
    }
}
```

**실행 & 테스트**:

```bash
./gradlew bootRun

# 다른 터미널에서
curl http://localhost:8080/api/health
# {"status":"OK","timestamp":"2025-01-15T10:30:00"}
```

### 2.5 GitHub Actions CI

**.github/workflows/ci.yml**:

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
      working-directory: backend/spring

    - name: Build with Gradle
      run: ./gradlew build
      working-directory: backend/spring

    - name: Run tests
      run: ./gradlew test
      working-directory: backend/spring
```

---

## 3. S2.1: Layered CRUD & Transaction Pattern

### 3.1 도메인 모델 (JPA Entity)

**User.java**:

```java
package com.example.training.user.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;  // 실제로는 BCrypt 해시

    @Column(nullable = false)
    private LocalDateTime createdAt;

    protected User() {}  // JPA 요구사항

    public User(String email, String password) {
        this.email = email;
        this.password = password;
        this.createdAt = LocalDateTime.now();
    }

    // Getters
    public Long getId() { return id; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

**Issue.java**:

```java
package com.example.training.issue.domain;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "issues")
public class Issue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private IssueStatus status = IssueStatus.OPEN;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id", nullable = false)
    private Project project;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reporter_id", nullable = false)
    private User reporter;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "assignee_id")
    private User assignee;

    @Column(nullable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    protected Issue() {}

    public Issue(String title, String description, Project project, User reporter) {
        this.title = title;
        this.description = description;
        this.project = project;
        this.reporter = reporter;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // 비즈니스 메서드
    public void updateStatus(IssueStatus newStatus) {
        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }

    public void assignTo(User user) {
        this.assignee = user;
        this.updatedAt = LocalDateTime.now();
    }

    // Getters
    public Long getId() { return id; }
    public String getTitle() { return title; }
    public String getDescription() { return description; }
    public IssueStatus getStatus() { return status; }
    public Project getProject() { return project; }
    public User getReporter() { return reporter; }
    public User getAssignee() { return assignee; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
}
```

**IssueStatus.java**:

```java
package com.example.training.issue.domain;

public enum IssueStatus {
    OPEN,
    IN_PROGRESS,
    RESOLVED,
    CLOSED
}
```

### 3.2 DTO (Data Transfer Object)

**CreateIssueDto.java**:

```java
package com.example.training.issue.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public record CreateIssueDto(
    @NotNull(message = "Project ID is required")
    Long projectId,

    @NotBlank(message = "Title is required")
    String title,

    String description
) {}
```

**IssueResponse.java**:

```java
package com.example.training.issue.dto;

import com.example.training.issue.domain.Issue;
import com.example.training.issue.domain.IssueStatus;

import java.time.LocalDateTime;

public record IssueResponse(
    Long id,
    String title,
    String description,
    IssueStatus status,
    Long projectId,
    Long reporterId,
    Long assigneeId,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    public static IssueResponse from(Issue issue) {
        return new IssueResponse(
            issue.getId(),
            issue.getTitle(),
            issue.getDescription(),
            issue.getStatus(),
            issue.getProject().getId(),
            issue.getReporter().getId(),
            issue.getAssignee() != null ? issue.getAssignee().getId() : null,
            issue.getCreatedAt(),
            issue.getUpdatedAt()
        );
    }
}
```

### 3.3 Repository

**IssueRepository.java**:

```java
package com.example.training.issue.repository;

import com.example.training.issue.domain.Issue;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface IssueRepository extends JpaRepository<Issue, Long> {

    List<Issue> findByProjectId(Long projectId);

    @Query("SELECT i FROM Issue i WHERE i.assignee.id = :userId")
    List<Issue> findByAssigneeId(Long userId);
}
```

**Spring Data JPA**가 자동으로 구현 제공:
- `save()`, `findById()`, `findAll()`, `delete()` 등
- 메서드 이름 기반 쿼리 생성 (`findByProjectId`)
- `@Query` 어노테이션으로 커스텀 쿼리

### 3.4 Service

**IssueService.java**:

```java
package com.example.training.issue.service;

import com.example.training.issue.domain.Issue;
import com.example.training.issue.dto.CreateIssueDto;
import com.example.training.issue.dto.IssueResponse;
import com.example.training.issue.repository.IssueRepository;
import com.example.training.project.domain.Project;
import com.example.training.project.repository.ProjectRepository;
import com.example.training.user.domain.User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Transactional(readOnly = true)
public class IssueService {
    private final IssueRepository issueRepository;
    private final ProjectRepository projectRepository;

    public IssueService(IssueRepository issueRepository,
                       ProjectRepository projectRepository) {
        this.issueRepository = issueRepository;
        this.projectRepository = projectRepository;
    }

    @Transactional
    public IssueResponse createIssue(CreateIssueDto dto, User reporter) {
        Project project = projectRepository.findById(dto.projectId())
            .orElseThrow(() -> new IllegalArgumentException("Project not found"));

        Issue issue = new Issue(dto.title(), dto.description(), project, reporter);
        Issue saved = issueRepository.save(issue);

        return IssueResponse.from(saved);
    }

    public IssueResponse getIssue(Long id) {
        Issue issue = issueRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Issue not found"));
        return IssueResponse.from(issue);
    }

    public List<IssueResponse> getProjectIssues(Long projectId) {
        return issueRepository.findByProjectId(projectId).stream()
            .map(IssueResponse::from)
            .toList();
    }
}
```

**@Transactional**:
- 클래스 레벨: `readOnly = true` (조회 최적화)
- 메서드 레벨: `@Transactional` (쓰기 작업, readOnly 오버라이드)

### 3.5 Controller

**IssueController.java**:

```java
package com.example.training.issue.controller;

import com.example.training.issue.dto.CreateIssueDto;
import com.example.training.issue.dto.IssueResponse;
import com.example.training.issue.service.IssueService;
import com.example.training.user.domain.User;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/issues")
public class IssueController {
    private final IssueService issueService;

    public IssueController(IssueService issueService) {
        this.issueService = issueService;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public IssueResponse createIssue(
        @Valid @RequestBody CreateIssueDto dto,
        @AuthenticationPrincipal User user
    ) {
        return issueService.createIssue(dto, user);
    }

    @GetMapping("/{id}")
    public IssueResponse getIssue(@PathVariable Long id) {
        return issueService.getIssue(id);
    }

    @GetMapping("/project/{projectId}")
    public List<IssueResponse> getProjectIssues(@PathVariable Long projectId) {
        return issueService.getProjectIssues(projectId);
    }
}
```

**어노테이션 설명**:
- `@RestController`: `@Controller` + `@ResponseBody`
- `@RequestMapping`: 기본 URL 경로
- `@PostMapping`, `@GetMapping`: HTTP 메서드 매핑
- `@Valid`: DTO 검증 트리거
- `@RequestBody`: JSON → 객체 변환
- `@PathVariable`: URL 경로 변수
- `@AuthenticationPrincipal`: 인증된 사용자 주입

### 3.6 JWT 인증

**build.gradle** (의존성 추가):

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}
```

**JwtUtil.java**:

```java
package com.example.training.auth.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtil {
    private final Key key;
    private final long expirationMs;

    public JwtUtil(
        @Value("${jwt.secret}") String secret,
        @Value("${jwt.expiration-ms}") long expirationMs
    ) {
        this.key = Keys.hmacShaKeyFor(secret.getBytes());
        this.expirationMs = expirationMs;
    }

    public String generateToken(String email) {
        return Jwts.builder()
            .setSubject(email)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
    }

    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

**SecurityConfig.java**:

```java
package com.example.training.common.config;

import com.example.training.auth.filter.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/health", "/api/auth/**", "/api/users").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 3.7 트랜잭션 예시

**CommentService.java** (댓글 추가 + 이슈 상태 변경):

```java
package com.example.training.comment.service;

import com.example.training.comment.domain.Comment;
import com.example.training.comment.dto.CreateCommentDto;
import com.example.training.comment.repository.CommentRepository;
import com.example.training.issue.domain.Issue;
import com.example.training.issue.domain.IssueStatus;
import com.example.training.issue.repository.IssueRepository;
import com.example.training.user.domain.User;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CommentService {
    private final CommentRepository commentRepository;
    private final IssueRepository issueRepository;

    public CommentService(CommentRepository commentRepository,
                         IssueRepository issueRepository) {
        this.commentRepository = commentRepository;
        this.issueRepository = issueRepository;
    }

    @Transactional
    public void addCommentAndUpdateStatus(CreateCommentDto dto, User author) {
        // 1. 댓글 생성
        Issue issue = issueRepository.findById(dto.issueId())
            .orElseThrow(() -> new IllegalArgumentException("Issue not found"));

        Comment comment = new Comment(dto.content(), issue, author);
        commentRepository.save(comment);

        // 2. 이슈 상태 변경 (예: OPEN → IN_PROGRESS)
        if (issue.getStatus() == IssueStatus.OPEN) {
            issue.updateStatus(IssueStatus.IN_PROGRESS);
            // save() 불필요 - @Transactional이 자동으로 변경 감지
        }

        // 트랜잭션 종료 시:
        // - 성공: 모두 커밋
        // - 예외 발생: 모두 롤백
    }
}
```

**@Transactional의 이점**:
- 원자성: 모두 성공 또는 모두 실패
- 변경 감지 (Dirty Checking): 엔티티 변경 자동 감지 & UPDATE
- 예외 발생 시 자동 롤백

---

## 4. S2.0-S2.1 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 1 (S2.0-S2.1)은 통과로 본다.

### S2.0 체크리스트 (Bootstrap & CI)

* [ ] Spring Boot 프로젝트를 생성하고, `./gradlew bootRun`으로 로컬에서 실행할 수 있다.
* [ ] `application.yml` 및 프로파일별 설정 파일을 작성할 수 있다.
* [ ] 헬스 체크 엔드포인트 (`GET /api/health`)를 구현하고 응답을 확인할 수 있다.
* [ ] GitHub Actions CI 워크플로우를 작성하고, push 시 자동 빌드/테스트가 실행된다.

### S2.1 체크리스트 (Layered CRUD)

* [ ] JPA Entity를 정의하고 H2 데이터베이스에 테이블을 생성할 수 있다.
* [ ] Spring Data JPA Repository를 작성하고 CRUD 메서드를 사용할 수 있다.
* [ ] Service 레이어에 비즈니스 로직을 작성하고 @Transactional을 적용할 수 있다.
* [ ] Controller에서 DTO를 받아 검증하고 Service를 호출할 수 있다.
* [ ] JWT 토큰을 생성/검증하고, Spring Security로 인증된 엔드포인트를 보호할 수 있다.
* [ ] @Transactional을 사용해서 여러 테이블 변경을 원자적으로 처리할 수 있다.
* [ ] Bean Validation (@NotBlank, @NotNull 등)으로 DTO 검증을 할 수 있다.

여기까지 구현하면:

* **Spring Boot 기본 프로젝트 구조** 이해
* **3-Layer Architecture** (Controller/Service/Repository) 숙지
* **REST API CRUD** 구현 가능
* **JWT 인증** 적용 가능
* **트랜잭션** 관리 가능
* **CI 파이프라인** 구축 완료

상태가 된다. 다음은 **문서 3**에서 RBAC, 배치, 캐싱 패턴을 익힌다.

---

## 5. 참고 자료

* [Spring Boot 공식 문서](https://spring.io/projects/spring-boot)
* [Spring Data JPA 공식 문서](https://spring.io/projects/spring-data-jpa)
* [Spring Security 공식 문서](https://spring.io/projects/spring-security)
* [Java 17 문서](https://docs.oracle.com/en/java/javase/17/)
* [Gradle 공식 문서](https://docs.gradle.org/)
