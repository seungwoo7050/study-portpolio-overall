# 문서 4. 고급 패턴 II: 외부 시스템 & 인프라 (N2.4-N2.6)

> 이 문서는 **Stage 2 후반부 + Stage 3 (인프라)** 용이다.
> 전제:
>
> * Stage 1-2 전반부 (N2.0-N2.3) 완료
> * NestJS 핵심 패턴 (Controller/Service/Guard) 숙지
> * 이제 **Elasticsearch 검색**, **Kafka 이벤트 스트리밍**, **프로덕션 인프라**를 경험할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* N2.0-N2.3 완료 (NestJS 기초 + RBAC + 배치/캐시)
* Docker Compose 사용 가능 (Elasticsearch, Kafka 로컬 실행용)
* 비동기 처리 개념 이해

### 이 문서의 목표

1. **Elasticsearch** 전문 검색 구현 (N2.4)
2. **Kafka** Producer/Consumer 패턴 (N2.5)
3. **Event-driven architecture** 경험
4. **프로덕션 인프라** 구축 (N2.6): PostgreSQL, Redis, Docker

### 이 문서가 다루는 범위

* **N2.4**: Elasticsearch Search
* **N2.5**: Kafka Async Events
* **N2.6**: Docker, PostgreSQL, Redis 인프라

---

## 1. N2.4: Elasticsearch Search

### 1.1 목표

* RDB와 분리된 검색 인덱스 구축
* 전문 검색 API 구현
* DB-ES 동기화 전략

### 1.2 Docker Compose (Elasticsearch)

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data

volumes:
  es_data:
```

**실행**:

```bash
docker-compose up -d elasticsearch
curl http://localhost:9200
# {"name":"...","cluster_name":"docker-cluster",...}
```

### 1.3 Elasticsearch 클라이언트 설치

```bash
npm install @elastic/elasticsearch
```

**ElasticsearchModule**:

```bash
nest g module elasticsearch
nest g service elasticsearch
```

```typescript
// src/elasticsearch/elasticsearch.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { Client } from '@elastic/elasticsearch';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class ElasticsearchService implements OnModuleInit {
  private client: Client;

  constructor(private config: ConfigService) {
    this.client = new Client({
      node: this.config.get('ELASTICSEARCH_NODE') || 'http://localhost:9200',
    });
  }

  async onModuleInit() {
    try {
      await this.client.ping();
      console.log('Elasticsearch connected');
    } catch (error) {
      console.error('Elasticsearch connection failed:', error.message);
    }
  }

  getClient(): Client {
    return this.client;
  }
}
```

```typescript
// src/elasticsearch/elasticsearch.module.ts
import { Global, Module } from '@nestjs/common';
import { ElasticsearchService } from './elasticsearch.service';

@Global()
export class ElasticsearchModule {
  static forRoot() {
    return {
      module: ElasticsearchModule,
      providers: [ElasticsearchService],
      exports: [ElasticsearchService],
    };
  }
}
```

**AppModule에 추가**:

```typescript
@Module({
  imports: [
    ElasticsearchModule.forRoot(),
    // ...
  ],
})
export class AppModule {}
```

### 1.4 Product 도메인

**Prisma Schema**:

```prisma
model Product {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  category    String
  brand       String
  price       Int
  status      String   @default("ACTIVE")  // ACTIVE, INACTIVE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

**ProductService (DB + ES 동기화)**:

```typescript
// src/product/product.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { ElasticsearchService } from '../elasticsearch/elasticsearch.service';

@Injectable()
export class ProductService {
  private readonly indexName = 'products';

  constructor(
    private prisma: PrismaService,
    private es: ElasticsearchService,
  ) {}

  async create(dto: CreateProductDto) {
    // 1. DB 저장
    const product = await this.prisma.product.create({
      data: dto,
    });

    // 2. ES 인덱싱
    await this.indexProduct(product);

    return product;
  }

  async update(id: number, dto: UpdateProductDto) {
    // 1. DB 업데이트
    const product = await this.prisma.product.update({
      where: { id },
      data: dto,
    });

    // 2. ES 갱신
    await this.indexProduct(product);

    return product;
  }

  async delete(id: number) {
    // 1. DB 삭제
    await this.prisma.product.delete({
      where: { id },
    });

    // 2. ES 삭제
    await this.es.getClient().delete({
      index: this.indexName,
      id: id.toString(),
    });
  }

  private async indexProduct(product: any) {
    await this.es.getClient().index({
      index: this.indexName,
      id: product.id.toString(),
      document: {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    });
  }

  async reindexAll() {
    const products = await this.prisma.product.findMany({
      where: { status: 'ACTIVE' },
    });

    const bulkBody = products.flatMap((product) => [
      { index: { _index: this.indexName, _id: product.id.toString() } },
      {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    ]);

    if (bulkBody.length > 0) {
      await this.es.getClient().bulk({ body: bulkBody });
    }

    return { indexed: products.length };
  }
}
```

### 1.5 Search API

```typescript
// src/search/search.service.ts
import { Injectable } from '@nestjs/common';
import { ElasticsearchService } from '../elasticsearch/elasticsearch.service';

@Injectable()
export class SearchService {
  constructor(private es: ElasticsearchService) {}

  async searchProducts(params: SearchProductsDto) {
    const { q, category, brand, minPrice, maxPrice, page = 1, size = 10 } = params;

    const must: any[] = [];

    // 키워드 검색 (name, description)
    if (q) {
      must.push({
        multi_match: {
          query: q,
          fields: ['name^2', 'description'],  // name에 2배 가중치
        },
      });
    }

    // 필터
    const filter: any[] = [];

    if (category) {
      filter.push({ term: { category } });
    }

    if (brand) {
      filter.push({ term: { brand } });
    }

    if (minPrice || maxPrice) {
      const range: any = {};
      if (minPrice) range.gte = minPrice;
      if (maxPrice) range.lte = maxPrice;
      filter.push({ range: { price: range } });
    }

    const result = await this.es.getClient().search({
      index: 'products',
      from: (page - 1) * size,
      size,
      body: {
        query: {
          bool: {
            must,
            filter,
          },
        },
      },
    });

    return {
      total: result.hits.total.value,
      items: result.hits.hits.map((hit) => hit._source),
    };
  }
}
```

**SearchController**:

```typescript
@Controller('api/search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  @Get('products')
  searchProducts(@Query() params: SearchProductsDto) {
    return this.searchService.searchProducts(params);
  }
}
```

**SearchProductsDto**:

```typescript
// src/search/dto/search-products.dto.ts
import { IsString, IsOptional, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class SearchProductsDto {
  @IsString()
  @IsOptional()
  q?: string;

  @IsString()
  @IsOptional()
  category?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsInt()
  @IsOptional()
  @Type(() => Number)
  minPrice?: number;

  @IsInt()
  @IsOptional()
  @Type(() => Number)
  maxPrice?: number;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Type(() => Number)
  page?: number;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Type(() => Number)
  size?: number;
}
```

### 1.6 재색인 관리자 엔드포인트

```typescript
@Controller('api/admin')
export class AdminController {
  constructor(private readonly productService: ProductService) {}

  @Post('reindex/products')
  reindexProducts() {
    return this.productService.reindexAll();
  }
}
```

---

## 2. N2.5: Kafka Async Events

### 2.1 목표

* Kafka Producer/Consumer 구현
* 도메인 이벤트 발행/소비
* Event-driven architecture 경험

### 2.2 Docker Compose (Kafka)

**docker-compose.yml** (추가):

```yaml
version: '3.8'

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
```

**실행**:

```bash
docker-compose up -d zookeeper kafka
```

### 2.3 KafkaJS 설치

```bash
npm install kafkajs
```

**KafkaModule**:

```typescript
// src/kafka/kafka.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { Kafka, Producer, Consumer } from 'kafkajs';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class KafkaService implements OnModuleInit, OnModuleDestroy {
  private kafka: Kafka;
  private producer: Producer;
  private consumers: Map<string, Consumer> = new Map();

  constructor(private config: ConfigService) {
    this.kafka = new Kafka({
      clientId: this.config.get('KAFKA_CLIENT_ID') || 'nestjs-app',
      brokers: [this.config.get('KAFKA_BROKERS') || 'localhost:9092'],
    });

    this.producer = this.kafka.producer();
  }

  async onModuleInit() {
    await this.producer.connect();
    console.log('Kafka Producer connected');
  }

  async onModuleDestroy() {
    await this.producer.disconnect();
    for (const [, consumer] of this.consumers) {
      await consumer.disconnect();
    }
  }

  async sendEvent(topic: string, message: any) {
    await this.producer.send({
      topic,
      messages: [
        {
          value: JSON.stringify(message),
        },
      ],
    });
  }

  async subscribe(topic: string, groupId: string, handler: (message: any) => Promise<void>) {
    const consumer = this.kafka.consumer({ groupId });
    await consumer.connect();
    await consumer.subscribe({ topic, fromBeginning: false });

    await consumer.run({
      eachMessage: async ({ message }) => {
        const payload = JSON.parse(message.value.toString());
        await handler(payload);
      },
    });

    this.consumers.set(topic, consumer);
  }
}
```

### 2.4 Order 도메인 (Producer)

**Prisma Schema**:

```prisma
model Order {
  id          Int      @id @default(autoincrement())
  totalAmount Int
  status      String   @default("PENDING")  // PENDING, PAID, CANCELLED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId      Int
  user        User     @relation(fields: [userId], references: [id])

  items       OrderItem[]
}

model OrderItem {
  id        Int @id @default(autoincrement())
  quantity  Int
  price     Int

  orderId   Int
  order     Order @relation(fields: [orderId], references: [id])

  productId Int
}
```

**OrderService**:

```typescript
// src/order/order.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { KafkaService } from '../kafka/kafka.service';

@Injectable()
export class OrderService {
  constructor(
    private prisma: PrismaService,
    private kafka: KafkaService,
  ) {}

  async create(dto: CreateOrderDto, userId: number) {
    // 트랜잭션: Order + OrderItem 생성
    const order = await this.prisma.$transaction(async (tx) => {
      const newOrder = await tx.order.create({
        data: {
          userId,
          totalAmount: dto.items.reduce((sum, item) => sum + item.price * item.quantity, 0),
          status: 'PENDING',
        },
      });

      await tx.orderItem.createMany({
        data: dto.items.map((item) => ({
          orderId: newOrder.id,
          productId: item.productId,
          quantity: item.quantity,
          price: item.price,
        })),
      });

      return newOrder;
    });

    // 이벤트 발행
    await this.kafka.sendEvent('order-events', {
      eventId: crypto.randomUUID(),
      eventType: 'ORDER_CREATED',
      timestamp: new Date().toISOString(),
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
    });

    return order;
  }

  async markAsPaid(id: number) {
    const order = await this.prisma.order.update({
      where: { id },
      data: { status: 'PAID' },
    });

    await this.kafka.sendEvent('order-events', {
      eventId: crypto.randomUUID(),
      eventType: 'ORDER_PAID',
      timestamp: new Date().toISOString(),
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
    });

    return order;
  }
}
```

### 2.5 Notification Consumer

**Prisma Schema**:

```prisma
model Notification {
  id        Int      @id @default(autoincrement())
  type      String   // ORDER_CREATED, ORDER_PAID, ORDER_CANCELLED
  message   String
  createdAt DateTime @default(now())

  userId    Int
  user      User     @relation(fields: [userId], references: [id])
}
```

**NotificationService**:

```typescript
// src/notification/notification.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { KafkaService } from '../kafka/kafka.service';

@Injectable()
export class NotificationService implements OnModuleInit {
  constructor(
    private prisma: PrismaService,
    private kafka: KafkaService,
  ) {}

  async onModuleInit() {
    // Consumer 시작
    await this.kafka.subscribe(
      'order-events',
      'notification-consumer-group',
      this.handleOrderEvent.bind(this),
    );
  }

  async handleOrderEvent(event: any) {
    const { eventType, orderId, userId, totalAmount } = event;

    let message = '';

    switch (eventType) {
      case 'ORDER_CREATED':
        message = `주문이 생성되었습니다. 주문 번호: ${orderId}, 금액: ${totalAmount}원`;
        break;
      case 'ORDER_PAID':
        message = `주문이 결제되었습니다. 주문 번호: ${orderId}`;
        break;
      case 'ORDER_CANCELLED':
        message = `주문이 취소되었습니다. 주문 번호: ${orderId}`;
        break;
      default:
        return;
    }

    await this.prisma.notification.create({
      data: {
        type: eventType,
        message,
        userId,
      },
    });

    console.log(`Notification created: ${message}`);
  }

  async getUserNotifications(userId: number) {
    return this.prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 20,
    });
  }
}
```

**NotificationController**:

```typescript
@Controller('api/notifications')
@UseGuards(AuthGuard('jwt'))
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get()
  getUserNotifications(@CurrentUser() user) {
    return this.notificationService.getUserNotifications(user.userId);
  }
}
```

---

## 3. N2.6: Docker, PostgreSQL, Redis 인프라

### 3.1 목표

* SQLite → PostgreSQL 전환 (프로덕션 DB)
* In-memory → Redis 캐시 (분산 캐싱)
* Docker Compose 전체 스택 컨테이너화
* 클라우드 배포 준비

### 3.2 Prisma Schema 변경 (PostgreSQL)

**prisma/schema.prisma**:

```prisma
datasource db {
  provider = "postgresql"  // sqlite → postgresql
  url      = env("DATABASE_URL")
}

// 모델은 기존과 동일
model User { ... }
model Issue { ... }
```

**마이그레이션 재생성**:

```bash
# 기존 SQLite 마이그레이션 삭제 (선택)
rm -rf prisma/migrations

# PostgreSQL용 마이그레이션 생성
npx prisma migrate dev --name init-postgresql
```

### 3.3 Redis 캐시 통합

**AppModule 설정**:

```typescript
// src/app.module.ts
import { CacheModule } from '@nestjs/cache-manager';
import { redisStore } from 'cache-manager-redis-store';

@Module({
  imports: [
    CacheModule.registerAsync({
      isGlobal: true,
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const logger = new Logger(AppModule.name);
        const host = configService.get<string>('REDIS_HOST');
        const port = Number(configService.get<string>('REDIS_PORT')) || 6379;

        // Fallback: Redis 미설정 시 in-memory 사용
        if (!host) {
          logger.warn('REDIS_HOST not set. Falling back to in-memory cache store.');
          return { ttl: 300 };
        }

        // Redis 설정
        return {
          store: await redisStore({
            socket: { host, port },
          }),
          ttl: 300,
        };
      },
    }),
    // ...
  ],
})
export class AppModule {}
```

**기존 캐싱 코드 호환성**:
- N2.3에서 작성한 `IssueService.findPopular()` 코드 변경 없음
- `CACHE_MANAGER` 주입 패턴 동일
- Redis 또는 in-memory 자동 선택

### 3.4 Docker Compose

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  # NestJS 애플리케이션
  app:
    build: .
    container_name: web-phase1-5-node
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://app:app@db:5432/app?schema=public
      REDIS_HOST: redis
      REDIS_PORT: 6379
      # ... 기타 환경 변수
    ports:
      - '3000:3000'
    networks:
      - app-network

  # PostgreSQL 16
  db:
    image: postgres:16
    container_name: postgres
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: app
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

  # Redis 7
  redis:
    image: redis:7
    container_name: redis
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # Elasticsearch, Kafka 등 기존 서비스...

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
```

**Dockerfile**:

```dockerfile
FROM node:20-alpine

WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm ci

# 소스 복사 & 빌드
COPY . .
RUN npx prisma generate
RUN npm run build

# 실행 환경
ENV NODE_ENV=production
ENV PORT=3000
EXPOSE 3000

CMD ["node", "dist/main.js"]
```

### 3.5 실행 및 검증

**전체 스택 시작**:

```bash
# 모든 서비스 시작
docker-compose up -d

# 마이그레이션 실행 (최초 1회)
docker-compose exec app npx prisma migrate deploy

# 로그 확인
docker-compose logs -f app
```

**검증**:

```bash
# 헬스 체크
curl http://localhost:3000/api/health

# PostgreSQL 연결 확인
docker-compose exec db psql -U app -d app -c "\dt"

# Redis 연결 확인
docker-compose exec redis redis-cli KEYS '*'

# 인기 이슈 캐시 확인 (Redis)
curl http://localhost:3000/api/issues/popular
docker-compose exec redis redis-cli GET "popular_issues:v1"
```

### 3.6 환경별 설정 전략

**로컬 개발 (`.env.local`)**:
```env
DATABASE_URL="file:./dev.db"  # SQLite 유지
REDIS_HOST=  # 비어있음 → in-memory 캐시
```

**Docker 환경 (docker-compose.yml)**:
```yaml
environment:
  DATABASE_URL: postgresql://app:app@db:5432/app?schema=public
  REDIS_HOST: redis
```

**프로덕션 (클라우드)**:
```env
DATABASE_URL=postgresql://user:pass@prod-db.example.com:5432/app
REDIS_HOST=prod-redis.example.com
JWT_SECRET=<강력한-시크릿>
```

---

## 4. N2.4-N2.6 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 2 후반부 + Stage 3 (N2.4-N2.6)는 통과로 본다.

### N2.4 체크리스트 (Elasticsearch)

* [ ] Elasticsearch 클라이언트를 NestJS에 통합하고, 인덱스를 생성할 수 있다.
* [ ] 상품 생성/수정 시 DB와 ES를 동기화할 수 있다.
* [ ] 전문 검색 API를 구현하고, 키워드/필터로 검색 결과를 반환할 수 있다.
* [ ] 전체 재색인 엔드포인트를 만들고, DB 데이터를 ES에 일괄 동기화할 수 있다.

### N2.5 체크리스트 (Kafka)

* [ ] Kafka Producer를 구현하고, 도메인 이벤트를 발행할 수 있다.
* [ ] Kafka Consumer를 구현하고, 이벤트를 수신해서 처리할 수 있다.
* [ ] 주문 생성 → 이벤트 발행 → 알림 생성 플로우가 비동기로 동작하는 것을 확인할 수 있다.
* [ ] Consumer 중단/재시작 시에도 이벤트가 누락되지 않는 것을 확인할 수 있다.

### N2.6 체크리스트 (인프라)

* [ ] Prisma Schema를 PostgreSQL로 변경하고 마이그레이션을 재생성할 수 있다.
* [ ] Docker Compose로 PostgreSQL + Redis를 실행하고 애플리케이션이 연결되는 것을 확인할 수 있다.
* [ ] Redis 캐시가 동작하고, 캐시 히트 시 DB 조회가 발생하지 않는 것을 확인할 수 있다.
* [ ] Dockerfile을 작성하고 `docker-compose build`로 이미지를 빌드할 수 있다.
* [ ] 전체 스택을 `docker-compose up -d`로 실행하고 모든 서비스가 정상 동작하는 것을 확인할 수 있다.
* [ ] 로컬 개발(SQLite + in-memory), Docker(PostgreSQL + Redis) 환경을 모두 지원할 수 있다.

여기까지 구현하면:

* **NestJS 핵심 패턴** (Module, Controller, Service, DI)
* **REST API** (CRUD, DTO validation, JWT)
* **RBAC** (Guard + Decorator)
* **배치 작업** (@nestjs/schedule)
* **캐싱** (@nestjs/cache-manager, Redis)
* **외부 API 연동** (타임아웃 + 재시도)
* **Elasticsearch 검색**
* **Kafka 이벤트 스트리밍**
* **프로덕션 인프라** (PostgreSQL, Redis, Docker)

까지 **실전 NestJS 백엔드 개발의 모든 핵심 패턴과 인프라 구축**을 경험한 상태다.

---

## 5. 참고 자료

* [Elasticsearch Official Docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
* [Elasticsearch Node.js Client](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html)
* [KafkaJS Documentation](https://kafka.js.org/)
* [Kafka Concepts](https://kafka.apache.org/documentation/#gettingStarted)
* [PostgreSQL Official Docs](https://www.postgresql.org/docs/)
* [Redis Official Docs](https://redis.io/documentation)
* [Docker Compose Official Docs](https://docs.docker.com/compose/)
* [Prisma Database Providers](https://www.prisma.io/docs/reference/database-reference/supported-databases)
