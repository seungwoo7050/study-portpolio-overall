# 문서 4. 고급 패턴 II: 외부 시스템 (N2.4-N2.5)

> 이 문서는 **Stage 2 후반부 (선택)** 용이다.
> 전제:
>
> * Stage 1-2 전반부 (N2.0-N2.3) 완료
> * NestJS 핵심 패턴 (Controller/Service/Guard) 숙지
> * 이제 **Elasticsearch 검색**, **Kafka 이벤트 스트리밍**을 경험할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* N2.0-N2.3 완료 (NestJS 기초 + RBAC + 배치/캐시)
* Docker Compose 사용 가능 (Elasticsearch, Kafka 로컬 실행용)
* 비동기 처리 개념 이해

### 이 문서의 목표

1. **Elasticsearch** 전문 검색 구현 (N2.4)
2. **Kafka** Producer/Consumer 패턴 (N2.5)
3. **Event-driven architecture** 경험

### 이 문서가 다루는 범위

* **N2.4**: Elasticsearch Search
* **N2.5**: Kafka Async Events

---

## 1. N2.4: Elasticsearch Search

### 1.1 목표

* RDB와 분리된 검색 인덱스 구축
* 전문 검색 API 구현
* DB-ES 동기화 전략

### 1.2 Docker Compose (Elasticsearch)

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data

volumes:
  es_data:
```

**실행**:

```bash
docker-compose up -d elasticsearch
curl http://localhost:9200
# {"name":"...","cluster_name":"docker-cluster",...}
```

### 1.3 Elasticsearch 클라이언트 설치

```bash
npm install @elastic/elasticsearch
```

**ElasticsearchModule**:

```bash
nest g module elasticsearch
nest g service elasticsearch
```

```typescript
// src/elasticsearch/elasticsearch.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { Client } from '@elastic/elasticsearch';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class ElasticsearchService implements OnModuleInit {
  private client: Client;

  constructor(private config: ConfigService) {
    this.client = new Client({
      node: this.config.get('ELASTICSEARCH_NODE') || 'http://localhost:9200',
    });
  }

  async onModuleInit() {
    try {
      await this.client.ping();
      console.log('Elasticsearch connected');
    } catch (error) {
      console.error('Elasticsearch connection failed:', error.message);
    }
  }

  getClient(): Client {
    return this.client;
  }
}
```

```typescript
// src/elasticsearch/elasticsearch.module.ts
import { Global, Module } from '@nestjs/common';
import { ElasticsearchService } from './elasticsearch.service';

@Global()
export class ElasticsearchModule {
  static forRoot() {
    return {
      module: ElasticsearchModule,
      providers: [ElasticsearchService],
      exports: [ElasticsearchService],
    };
  }
}
```

**AppModule에 추가**:

```typescript
@Module({
  imports: [
    ElasticsearchModule.forRoot(),
    // ...
  ],
})
export class AppModule {}
```

### 1.4 Product 도메인

**Prisma Schema**:

```prisma
model Product {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  category    String
  brand       String
  price       Int
  status      String   @default("ACTIVE")  // ACTIVE, INACTIVE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

**ProductService (DB + ES 동기화)**:

```typescript
// src/product/product.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { ElasticsearchService } from '../elasticsearch/elasticsearch.service';

@Injectable()
export class ProductService {
  private readonly indexName = 'products';

  constructor(
    private prisma: PrismaService,
    private es: ElasticsearchService,
  ) {}

  async create(dto: CreateProductDto) {
    // 1. DB 저장
    const product = await this.prisma.product.create({
      data: dto,
    });

    // 2. ES 인덱싱
    await this.indexProduct(product);

    return product;
  }

  async update(id: number, dto: UpdateProductDto) {
    // 1. DB 업데이트
    const product = await this.prisma.product.update({
      where: { id },
      data: dto,
    });

    // 2. ES 갱신
    await this.indexProduct(product);

    return product;
  }

  async delete(id: number) {
    // 1. DB 삭제
    await this.prisma.product.delete({
      where: { id },
    });

    // 2. ES 삭제
    await this.es.getClient().delete({
      index: this.indexName,
      id: id.toString(),
    });
  }

  private async indexProduct(product: any) {
    await this.es.getClient().index({
      index: this.indexName,
      id: product.id.toString(),
      document: {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    });
  }

  async reindexAll() {
    const products = await this.prisma.product.findMany({
      where: { status: 'ACTIVE' },
    });

    const bulkBody = products.flatMap((product) => [
      { index: { _index: this.indexName, _id: product.id.toString() } },
      {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    ]);

    if (bulkBody.length > 0) {
      await this.es.getClient().bulk({ body: bulkBody });
    }

    return { indexed: products.length };
  }
}
```

### 1.5 Search API

```typescript
// src/search/search.service.ts
import { Injectable } from '@nestjs/common';
import { ElasticsearchService } from '../elasticsearch/elasticsearch.service';

@Injectable()
export class SearchService {
  constructor(private es: ElasticsearchService) {}

  async searchProducts(params: SearchProductsDto) {
    const { q, category, brand, minPrice, maxPrice, page = 1, size = 10 } = params;

    const must: any[] = [];

    // 키워드 검색 (name, description)
    if (q) {
      must.push({
        multi_match: {
          query: q,
          fields: ['name^2', 'description'],  // name에 2배 가중치
        },
      });
    }

    // 필터
    const filter: any[] = [];

    if (category) {
      filter.push({ term: { category } });
    }

    if (brand) {
      filter.push({ term: { brand } });
    }

    if (minPrice || maxPrice) {
      const range: any = {};
      if (minPrice) range.gte = minPrice;
      if (maxPrice) range.lte = maxPrice;
      filter.push({ range: { price: range } });
    }

    const result = await this.es.getClient().search({
      index: 'products',
      from: (page - 1) * size,
      size,
      body: {
        query: {
          bool: {
            must,
            filter,
          },
        },
      },
    });

    return {
      total: result.hits.total.value,
      items: result.hits.hits.map((hit) => hit._source),
    };
  }
}
```

**SearchController**:

```typescript
@Controller('api/search')
export class SearchController {
  constructor(private readonly searchService: SearchService) {}

  @Get('products')
  searchProducts(@Query() params: SearchProductsDto) {
    return this.searchService.searchProducts(params);
  }
}
```

**SearchProductsDto**:

```typescript
// src/search/dto/search-products.dto.ts
import { IsString, IsOptional, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class SearchProductsDto {
  @IsString()
  @IsOptional()
  q?: string;

  @IsString()
  @IsOptional()
  category?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsInt()
  @IsOptional()
  @Type(() => Number)
  minPrice?: number;

  @IsInt()
  @IsOptional()
  @Type(() => Number)
  maxPrice?: number;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Type(() => Number)
  page?: number;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Type(() => Number)
  size?: number;
}
```

### 1.6 재색인 관리자 엔드포인트

```typescript
@Controller('api/admin')
export class AdminController {
  constructor(private readonly productService: ProductService) {}

  @Post('reindex/products')
  reindexProducts() {
    return this.productService.reindexAll();
  }
}
```

---

## 2. N2.5: Kafka Async Events

### 2.1 목표

* Kafka Producer/Consumer 구현
* 도메인 이벤트 발행/소비
* Event-driven architecture 경험

### 2.2 Docker Compose (Kafka)

**docker-compose.yml** (추가):

```yaml
version: '3.8'

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
```

**실행**:

```bash
docker-compose up -d zookeeper kafka
```

### 2.3 KafkaJS 설치

```bash
npm install kafkajs
```

**KafkaModule**:

```typescript
// src/kafka/kafka.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { Kafka, Producer, Consumer } from 'kafkajs';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class KafkaService implements OnModuleInit, OnModuleDestroy {
  private kafka: Kafka;
  private producer: Producer;
  private consumers: Map<string, Consumer> = new Map();

  constructor(private config: ConfigService) {
    this.kafka = new Kafka({
      clientId: this.config.get('KAFKA_CLIENT_ID') || 'nestjs-app',
      brokers: [this.config.get('KAFKA_BROKERS') || 'localhost:9092'],
    });

    this.producer = this.kafka.producer();
  }

  async onModuleInit() {
    await this.producer.connect();
    console.log('Kafka Producer connected');
  }

  async onModuleDestroy() {
    await this.producer.disconnect();
    for (const [, consumer] of this.consumers) {
      await consumer.disconnect();
    }
  }

  async sendEvent(topic: string, message: any) {
    await this.producer.send({
      topic,
      messages: [
        {
          value: JSON.stringify(message),
        },
      ],
    });
  }

  async subscribe(topic: string, groupId: string, handler: (message: any) => Promise<void>) {
    const consumer = this.kafka.consumer({ groupId });
    await consumer.connect();
    await consumer.subscribe({ topic, fromBeginning: false });

    await consumer.run({
      eachMessage: async ({ message }) => {
        const payload = JSON.parse(message.value.toString());
        await handler(payload);
      },
    });

    this.consumers.set(topic, consumer);
  }
}
```

### 2.4 Order 도메인 (Producer)

**Prisma Schema**:

```prisma
model Order {
  id          Int      @id @default(autoincrement())
  totalAmount Int
  status      String   @default("PENDING")  // PENDING, PAID, CANCELLED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId      Int
  user        User     @relation(fields: [userId], references: [id])

  items       OrderItem[]
}

model OrderItem {
  id        Int @id @default(autoincrement())
  quantity  Int
  price     Int

  orderId   Int
  order     Order @relation(fields: [orderId], references: [id])

  productId Int
}
```

**OrderService**:

```typescript
// src/order/order.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { KafkaService } from '../kafka/kafka.service';

@Injectable()
export class OrderService {
  constructor(
    private prisma: PrismaService,
    private kafka: KafkaService,
  ) {}

  async create(dto: CreateOrderDto, userId: number) {
    // 트랜잭션: Order + OrderItem 생성
    const order = await this.prisma.$transaction(async (tx) => {
      const newOrder = await tx.order.create({
        data: {
          userId,
          totalAmount: dto.items.reduce((sum, item) => sum + item.price * item.quantity, 0),
          status: 'PENDING',
        },
      });

      await tx.orderItem.createMany({
        data: dto.items.map((item) => ({
          orderId: newOrder.id,
          productId: item.productId,
          quantity: item.quantity,
          price: item.price,
        })),
      });

      return newOrder;
    });

    // 이벤트 발행
    await this.kafka.sendEvent('order-events', {
      eventId: crypto.randomUUID(),
      eventType: 'ORDER_CREATED',
      timestamp: new Date().toISOString(),
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
    });

    return order;
  }

  async markAsPaid(id: number) {
    const order = await this.prisma.order.update({
      where: { id },
      data: { status: 'PAID' },
    });

    await this.kafka.sendEvent('order-events', {
      eventId: crypto.randomUUID(),
      eventType: 'ORDER_PAID',
      timestamp: new Date().toISOString(),
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
    });

    return order;
  }
}
```

### 2.5 Notification Consumer

**Prisma Schema**:

```prisma
model Notification {
  id        Int      @id @default(autoincrement())
  type      String   // ORDER_CREATED, ORDER_PAID, ORDER_CANCELLED
  message   String
  createdAt DateTime @default(now())

  userId    Int
  user      User     @relation(fields: [userId], references: [id])
}
```

**NotificationService**:

```typescript
// src/notification/notification.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { KafkaService } from '../kafka/kafka.service';

@Injectable()
export class NotificationService implements OnModuleInit {
  constructor(
    private prisma: PrismaService,
    private kafka: KafkaService,
  ) {}

  async onModuleInit() {
    // Consumer 시작
    await this.kafka.subscribe(
      'order-events',
      'notification-consumer-group',
      this.handleOrderEvent.bind(this),
    );
  }

  async handleOrderEvent(event: any) {
    const { eventType, orderId, userId, totalAmount } = event;

    let message = '';

    switch (eventType) {
      case 'ORDER_CREATED':
        message = `주문이 생성되었습니다. 주문 번호: ${orderId}, 금액: ${totalAmount}원`;
        break;
      case 'ORDER_PAID':
        message = `주문이 결제되었습니다. 주문 번호: ${orderId}`;
        break;
      case 'ORDER_CANCELLED':
        message = `주문이 취소되었습니다. 주문 번호: ${orderId}`;
        break;
      default:
        return;
    }

    await this.prisma.notification.create({
      data: {
        type: eventType,
        message,
        userId,
      },
    });

    console.log(`Notification created: ${message}`);
  }

  async getUserNotifications(userId: number) {
    return this.prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 20,
    });
  }
}
```

**NotificationController**:

```typescript
@Controller('api/notifications')
@UseGuards(AuthGuard('jwt'))
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get()
  getUserNotifications(@CurrentUser() user) {
    return this.notificationService.getUserNotifications(user.userId);
  }
}
```

---

## 3. N2.4-N2.5 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 2 후반부 (N2.4-N2.5)는 통과로 본다.

### N2.4 체크리스트

* [ ] Elasticsearch 클라이언트를 NestJS에 통합하고, 인덱스를 생성할 수 있다.
* [ ] 상품 생성/수정 시 DB와 ES를 동기화할 수 있다.
* [ ] 전문 검색 API를 구현하고, 키워드/필터로 검색 결과를 반환할 수 있다.
* [ ] 전체 재색인 엔드포인트를 만들고, DB 데이터를 ES에 일괄 동기화할 수 있다.

### N2.5 체크리스트

* [ ] Kafka Producer를 구현하고, 도메인 이벤트를 발행할 수 있다.
* [ ] Kafka Consumer를 구현하고, 이벤트를 수신해서 처리할 수 있다.
* [ ] 주문 생성 → 이벤트 발행 → 알림 생성 플로우가 비동기로 동작하는 것을 확인할 수 있다.
* [ ] Consumer 중단/재시작 시에도 이벤트가 누락되지 않는 것을 확인할 수 있다.

여기까지 구현하면:

* **NestJS 핵심 패턴** (Module, Controller, Service, DI)
* **REST API** (CRUD, DTO validation, JWT)
* **RBAC** (Guard + Decorator)
* **배치 작업** (@nestjs/schedule)
* **캐싱** (@nestjs/cache-manager)
* **외부 API 연동** (타임아웃 + 재시도)
* **Elasticsearch 검색**
* **Kafka 이벤트 스트리밍**

까지 **실전 NestJS 백엔드 개발의 모든 핵심 패턴**을 경험한 상태다.

---

## 4. 참고 자료

* [Elasticsearch Official Docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
* [Elasticsearch Node.js Client](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html)
* [KafkaJS Documentation](https://kafka.js.org/)
* [Kafka Concepts](https://kafka.apache.org/documentation/#gettingStarted)
