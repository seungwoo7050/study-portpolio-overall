# 문서 2. NestJS 기초 & CRUD (N2.0-N2.1)

> 이 문서는 **Stage 1** 용이다.
> 전제:
>
> * 기본적인 프로그래밍 경험은 있음
> * TypeScript/JavaScript 기초 문법은 어느 정도 알고 있거나 빠르게 익힐 수 있음
> * 이제 **NestJS로 REST API 서버**를 만들고, **CI 파이프라인**을 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* Node.js 20+ 설치 가능
* npm 또는 pnpm 사용 가능
* Git + GitHub 기본 사용 가능
* HTTP/REST API 개념 이해

### 이 문서의 목표

1. **NestJS 프로젝트 골격** 구축 (N2.0)
2. **GitHub Actions CI** 파이프라인 설정
3. **Controller / Service / Repository** 패턴 이해
4. **DTO validation** + **JWT 인증** 적용
5. **Prisma 트랜잭션**으로 복합 연산 처리

### 이 문서가 다루는 범위

* **N2.0**: NestJS Bootstrap & CI Baseline
* **N2.1**: Layered CRUD & Transaction Pattern

**다루지 않는 범위** (다음 문서 3, 4에서):

* N2.2: Team & RBAC
* N2.3: Batch, Cache, External API
* N2.4-N2.5: Elasticsearch, Kafka

---

## 1. TypeScript + NestJS 핵심 개념

### 1.1 TypeScript 최소 필수 개념

**타입 주석**:

```typescript
let name: string = "Alice";
let age: number = 30;
let isActive: boolean = true;
```

**인터페이스 & 타입**:

```typescript
interface User {
  id: number;
  email: string;
  nickname: string;
}

type UserRole = 'ADMIN' | 'USER' | 'GUEST';
```

**함수 타입**:

```typescript
function createUser(email: string, password: string): User {
  // ...
}

// 화살표 함수
const login = async (email: string, password: string): Promise<string> => {
  // ...
};
```

**클래스**:

```typescript
class UserService {
  private readonly users: User[] = [];

  findById(id: number): User | undefined {
    return this.users.find(u => u.id === id);
  }

  create(email: string, password: string): User {
    // ...
  }
}
```

**제네릭**:

```typescript
function wrap<T>(value: T): { data: T } {
  return { data: value };
}

const result = wrap<number>(42); // { data: 42 }
```

### 1.2 NestJS 핵심 개념

**모듈 (Module)**:

```typescript
@Module({
  imports: [],          // 의존하는 다른 모듈
  controllers: [UserController],  // 이 모듈의 컨트롤러
  providers: [UserService],       // 이 모듈의 서비스 (DI)
  exports: [UserService],         // 다른 모듈에 노출할 서비스
})
export class UserModule {}
```

**컨트롤러 (Controller)**:

```typescript
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  findAll(): Promise<User[]> {
    return this.userService.findAll();
  }

  @Post()
  create(@Body() dto: CreateUserDto): Promise<User> {
    return this.userService.create(dto);
  }
}
```

**서비스 (Service)**:

```typescript
@Injectable()
export class UserService {
  constructor(private readonly prisma: PrismaService) {}

  async findAll(): Promise<User[]> {
    return this.prisma.user.findMany();
  }

  async create(dto: CreateUserDto): Promise<User> {
    return this.prisma.user.create({
      data: {
        email: dto.email,
        passwordHash: await bcrypt.hash(dto.password, 10),
        nickname: dto.nickname,
      },
    });
  }
}
```

**Dependency Injection**:

```typescript
// NestJS가 자동으로 UserService 인스턴스를 주입
constructor(private readonly userService: UserService) {}
```

---

## 2. N2.0: NestJS Bootstrap & CI Baseline

### 2.1 목표

* NestJS 프로젝트 생성
* 환경 설정 (`.env`, Prisma, SQLite)
* 헬스 체크 엔드포인트
* GitHub Actions CI 파이프라인

### 2.2 프로젝트 생성

```bash
# NestJS CLI 설치 (전역)
npm i -g @nestjs/cli

# 프로젝트 생성
nest new backend-node-js

# 디렉토리 이동
cd backend-node-js
```

선택 사항:
- Package manager: npm (또는 pnpm)
- 생성 후 `package.json`, `tsconfig.json`, `src/main.ts` 확인

### 2.3 환경 설정

**1. @nestjs/config 설치**:

```bash
npm install @nestjs/config
```

**2. .env 파일 생성**:

```env
# .env
PORT=3000
NODE_ENV=development
DATABASE_URL="file:./dev.db"
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=1d
```

**3. AppModule에 ConfigModule 추가**:

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,  // 모든 모듈에서 접근 가능
      envFilePath: ['.env.local', '.env'],  // 우선순위
    }),
  ],
})
export class AppModule {}
```

### 2.4 Prisma 설정

**1. Prisma 설치**:

```bash
npm install prisma @prisma/client
npx prisma init
```

**2. schema.prisma 설정**:

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"  // 개발용
  url      = env("DATABASE_URL")
}

// 헬스 체크용 더미 모델 (N2.1에서 실제 모델 추가)
model Health {
  id        Int      @id @default(autoincrement())
  status    String
  timestamp DateTime @default(now())
}
```

**3. Prisma Client 생성**:

```bash
npx prisma generate
npx prisma migrate dev --name init
```

**4. PrismaService 생성**:

```bash
nest g module common/prisma
nest g service common/prisma
```

```typescript
// src/common/prisma/prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  async enableShutdownHooks(app: any) {
    this.$on('beforeExit', async () => {
      await app.close();
    });
  }
}
```

```typescript
// src/common/prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()  // 모든 모듈에서 import 없이 사용 가능
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

### 2.5 헬스 체크 엔드포인트

```bash
nest g module common/health
nest g controller common/health
```

```typescript
// src/common/health/health.controller.ts
import { Controller, Get } from '@nestjs/common';

@Controller('api/health')
export class HealthController {
  @Get()
  check() {
    return {
      status: 'OK',
      timestamp: new Date().toISOString(),
    };
  }
}
```

**테스트**:

```bash
npm run start:dev

# 다른 터미널에서
curl http://localhost:3000/api/health
# {"status":"OK","timestamp":"2025-01-30T10:15:30.123Z"}
```

### 2.6 GitHub Actions CI

**.github/workflows/ci.yml**:

```yaml
name: CI

on:
  push:
    branches: [main, develop, 'feature/**']
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run unit tests
        run: npm test

      - name: Run e2e tests
        run: npm run test:e2e

      - name: Build application
        run: npm run build
```

**기본 e2e 테스트** (`test/app.e2e-spec.ts`):

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/api/health (GET)', () => {
    return request(app.getHttpServer())
      .get('/api/health')
      .expect(200)
      .expect((res) => {
        expect(res.body.status).toBe('OK');
        expect(res.body.timestamp).toBeDefined();
      });
  });
});
```

**Git push**:

```bash
git add .
git commit -m "feat: N2.0 - Bootstrap & CI baseline"
git push origin main
```

→ GitHub Actions에서 자동으로 테스트 실행

---

## 3. N2.1: Layered CRUD & Transaction Pattern

### 3.1 목표

* Controller / Service / Repository 패턴
* DTO validation (class-validator)
* JWT 인증 (Passport)
* Prisma 트랜잭션

### 3.2 Prisma Schema (Issue Tracker)

```prisma
// prisma/schema.prisma
model User {
  id           Int       @id @default(autoincrement())
  email        String    @unique
  passwordHash String
  nickname     String
  createdAt    DateTime  @default(now())

  projects     Project[]
  issues       Issue[]   @relation("Reporter")
  assignedIssues Issue[] @relation("Assignee")
  comments     Comment[]
}

model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  createdAt   DateTime @default(now())

  ownerId     Int
  owner       User     @relation(fields: [ownerId], references: [id])
  issues      Issue[]
}

model Issue {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  status      String   @default("OPEN")  // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  projectId   Int
  project     Project  @relation(fields: [projectId], references: [id])

  reporterId  Int
  reporter    User     @relation("Reporter", fields: [reporterId], references: [id])

  assigneeId  Int?
  assignee    User?    @relation("Assignee", fields: [assigneeId], references: [id])

  comments    Comment[]
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  issueId   Int
  issue     Issue    @relation(fields: [issueId], references: [id])

  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}
```

**마이그레이션**:

```bash
npx prisma migrate dev --name add_issue_tracker
```

### 3.3 DTO 정의

**class-validator 설치**:

```bash
npm install class-validator class-transformer
```

**main.ts에 ValidationPipe 추가**:

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 글로벌 Validation Pipe
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,        // DTO에 없는 필드 제거
    forbidNonWhitelisted: true,  // DTO에 없는 필드 있으면 에러
    transform: true,        // 타입 자동 변환
  }));

  await app.listen(process.env.PORT || 3000);
}
bootstrap();
```

**User DTO**:

```typescript
// src/user/dto/create-user.dto.ts
import { IsEmail, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  password: string;

  @IsString()
  @MinLength(2)
  nickname: string;
}
```

**Issue DTO**:

```typescript
// src/issue/dto/create-issue.dto.ts
import { IsString, IsOptional, IsInt } from 'class-validator';

export class CreateIssueDto {
  @IsString()
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsInt()
  projectId: number;
}

// src/issue/dto/update-issue.dto.ts
import { IsString, IsEnum, IsInt, IsOptional } from 'class-validator';

export class UpdateIssueDto {
  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED'])
  @IsOptional()
  status?: string;

  @IsInt()
  @IsOptional()
  assigneeId?: number;
}
```

### 3.4 JWT 인증

**Passport 설치**:

```bash
npm install @nestjs/passport passport passport-jwt
npm install --save-dev @types/passport-jwt
npm install bcrypt
npm install --save-dev @types/bcrypt
```

**AuthModule 생성**:

```bash
nest g module auth
nest g service auth
nest g controller auth
```

**JWT Strategy**:

```typescript
// src/auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```

**AuthService**:

```typescript
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../common/prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
  ) {}

  async login(email: string, password: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { sub: user.id, email: user.email };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

**AuthModule 설정**:

```typescript
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        secret: config.get('JWT_SECRET'),
        signOptions: { expiresIn: config.get('JWT_EXPIRES_IN') },
      }),
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}
```

**컨트롤러에서 인증 사용**:

```typescript
// src/issue/issue.controller.ts
import { Controller, Get, Post, Body, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller('api/issues')
@UseGuards(AuthGuard('jwt'))  // 모든 엔드포인트에 인증 필요
export class IssueController {
  constructor(private readonly issueService: IssueService) {}

  @Post()
  create(@Body() dto: CreateIssueDto, @Request() req) {
    const userId = req.user.userId;
    return this.issueService.create(dto, userId);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.issueService.findOne(+id);
  }
}
```

### 3.5 Service Layer (비즈니스 로직)

```typescript
// src/issue/issue.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { CreateIssueDto, UpdateIssueDto } from './dto';

@Injectable()
export class IssueService {
  constructor(private prisma: PrismaService) {}

  async create(dto: CreateIssueDto, reporterId: number) {
    return this.prisma.issue.create({
      data: {
        title: dto.title,
        description: dto.description,
        projectId: dto.projectId,
        reporterId,
      },
    });
  }

  async findOne(id: number) {
    const issue = await this.prisma.issue.findUnique({
      where: { id },
      include: {
        reporter: { select: { id: true, nickname: true } },
        assignee: { select: { id: true, nickname: true } },
        comments: {
          include: {
            author: { select: { id: true, nickname: true } },
          },
        },
      },
    });

    if (!issue) {
      throw new NotFoundException(`Issue #${id} not found`);
    }

    return issue;
  }

  async update(id: number, dto: UpdateIssueDto) {
    return this.prisma.issue.update({
      where: { id },
      data: dto,
    });
  }
}
```

### 3.6 트랜잭션

**시나리오**: 댓글 추가 + 이슈 상태 자동 변경

```typescript
// src/comment/comment.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';

@Injectable()
export class CommentService {
  constructor(private prisma: PrismaService) {}

  async createWithStatusUpdate(issueId: number, content: string, authorId: number) {
    return this.prisma.$transaction(async (tx) => {
      // 1. 댓글 생성
      const comment = await tx.comment.create({
        data: {
          content,
          issueId,
          authorId,
        },
      });

      // 2. 이슈 상태 변경 (예: OPEN → IN_PROGRESS)
      await tx.issue.update({
        where: { id: issueId },
        data: { status: 'IN_PROGRESS' },
      });

      return comment;
    });
  }
}
```

**컨트롤러**:

```typescript
@Post(':id/comments')
@UseGuards(AuthGuard('jwt'))
createComment(
  @Param('id') id: string,
  @Body() dto: CreateCommentDto,
  @Request() req,
) {
  return this.commentService.createWithStatusUpdate(
    +id,
    dto.content,
    req.user.userId,
  );
}
```

### 3.7 예외 처리

**전역 예외 필터**:

```typescript
// src/common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : 'Internal server error';

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
    });
  }
}
```

**main.ts에 적용**:

```typescript
import { AllExceptionsFilter } from './common/filters/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalFilters(new AllExceptionsFilter());
  app.useGlobalPipes(new ValidationPipe({...}));

  await app.listen(3000);
}
```

---

## 4. N2.0-N2.1 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 1 (N2.0-N2.1)은 통과로 본다.

### N2.0 체크리스트

* [ ] NestJS 프로젝트를 생성하고, `npm run start:dev`로 로컬에서 실행할 수 있다.
* [ ] `@nestjs/config`로 환경 변수를 주입하고, `.env` 파일로 설정을 관리할 수 있다.
* [ ] Prisma ORM을 설정하고, SQLite 데이터베이스에 연결할 수 있다.
* [ ] 헬스 체크 엔드포인트 (`GET /api/health`)를 만들고, 200 응답을 확인할 수 있다.
* [ ] GitHub Actions CI가 push 시마다 자동으로 돌아가고, 테스트가 통과한다.

### N2.1 체크리스트

* [ ] Controller / Service 패턴을 이해하고, 각 레이어의 역할을 설명할 수 있다.
* [ ] DTO를 정의하고 `class-validator`로 요청 검증을 할 수 있다.
* [ ] JWT 인증을 구현하고, `@UseGuards(AuthGuard('jwt'))`로 보호된 엔드포인트를 만들 수 있다.
* [ ] Prisma로 CRUD 작업을 수행하고, 관계 (relation) 데이터를 `include`로 조회할 수 있다.
* [ ] Prisma 트랜잭션 (`prisma.$transaction()`)을 사용해서 여러 테이블 변경을 원자적으로 처리할 수 있다.
* [ ] e2e 테스트를 작성하고, `npm run test:e2e`로 전체 플로우를 검증할 수 있다.

여기까지 구현하면:

* **NestJS의 핵심 패턴** (Module, Controller, Service, DI)
* **REST API 구현** (CRUD, DTO validation)
* **JWT 인증**
* **Prisma 트랜잭션**
* **CI 파이프라인**

까지 **NestJS 백엔드 개발의 기초**가 완성된 상태다.

**다음 단계** (문서 3):

* N2.2: Team & RBAC
* N2.3: Batch, Stats, Cache, External API

---

## 5. 참고 자료

* [NestJS 공식 문서](https://docs.nestjs.com/)
* [Prisma 공식 문서](https://www.prisma.io/docs)
* [class-validator GitHub](https://github.com/typestack/class-validator)
* [Passport JWT Strategy](http://www.passportjs.org/packages/passport-jwt/)
