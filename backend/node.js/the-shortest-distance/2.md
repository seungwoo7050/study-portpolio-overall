# 문서 2. NestJS 기초 & CRUD (N2.0-N2.1)

> 이 문서는 **Stage 1** 용이다.
> 전제:
>
> * 기본적인 프로그래밍 경험은 있음
> * TypeScript/JavaScript 기초 문법은 어느 정도 알고 있거나 빠르게 익힐 수 있음
> * 이제 **NestJS로 REST API 서버**를 만들고, **CI 파이프라인**을 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* Node.js 20+ 설치 가능
* npm 또는 pnpm 사용 가능
* Git + GitHub 기본 사용 가능
* HTTP/REST API 개념 이해

### 이 문서의 목표

1. **NestJS 프로젝트 골격** 구축 (N2.0)
2. **GitHub Actions CI** 파이프라인 설정
3. **Controller / Service / Repository** 패턴 이해
4. **DTO validation** + **JWT 인증** 적용
5. **Prisma 트랜잭션**으로 복합 연산 처리

### 이 문서가 다루는 범위

* **N2.0**: NestJS Bootstrap & CI Baseline
* **N2.1**: Layered CRUD & Transaction Pattern

**다루지 않는 범위** (다음 문서 3, 4에서):

* N2.2: Team & RBAC
* N2.3: Batch, Cache, External API
* N2.4-N2.5: Elasticsearch, Kafka

---

## 1. TypeScript + NestJS 핵심 개념

### 1.1 C에서 JavaScript/TypeScript로: 핵심 차이점

**C 프로그래머를 위한 JavaScript 요약:**

| 측면 | C | JavaScript/TypeScript |
|------|---|----------------------|
| 메모리 관리 | 수동 (malloc/free) | 자동 (가비지 컬렉터) |
| 타입 시스템 | 정적 타입 (컴파일 타임) | JS: 동적, TS: 정적 (선택) |
| 포인터 | 명시적 포인터 | 없음 (모든 객체는 참조) |
| 문자열 | char* | 불변 string 객체 |
| 배열 | 고정 크기 | 동적 크기 (자동 확장) |
| 함수 | 전역 함수 | 일급 객체 (변수에 할당 가능) |
| 구조체 | struct | object 또는 class |
| 헤더 파일 | .h 필요 | import/export 시스템 |
| 컴파일 | 기계어 직접 | JS: 인터프리터, TS: JS로 컴파일 |
| 동시성 | 스레드 (pthread) | 이벤트 루프 + 비동기 |

### 1.2 JavaScript 기본 문법

#### 1.2.1 변수와 타입

**C와 달리 타입 선언이 선택적 (JavaScript)**:

```javascript
// JavaScript (타입 없음)
let name = "Alice";           // C의 char*와 유사
let age = 30;                 // C의 int와 유사
let pi = 3.14159;             // C의 double과 유사
let isActive = true;          // C의 bool과 유사

// 변수 선언 키워드
const PI = 3.14159;           // 상수 (C의 const)
let count = 0;                // 재할당 가능
var old = "old";              // 구식 (사용 지양)

// 배열 (C와 다르게 동적!)
let numbers = [1, 2, 3, 4, 5];
numbers.push(6);              // C: realloc 필요, JS: 자동 확장
let first = numbers[0];       // C와 동일
let length = numbers.length;  // C: sizeof 계산 필요

// 객체 (C의 struct와 유사)
let user = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};
console.log(user.name);       // C: user.name 또는 user->name
```

**TypeScript (타입 추가)**:

```typescript
// TypeScript (타입 명시)
let name: string = "Alice";
let age: number = 30;
let isActive: boolean = true;

// 배열 타입
let numbers: number[] = [1, 2, 3];
let names: Array<string> = ["Alice", "Bob"];

// 객체 타입 (인터페이스)
interface User {
    id: number;
    name: string;
    email: string;
}

let user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};
```

**null과 undefined**:
- `null`: 명시적으로 "값 없음" (C의 NULL)
- `undefined`: 변수가 선언되었지만 값이 할당되지 않음
- 둘 다 falsy 값

#### 1.2.2 함수 (일급 객체)

**C 함수와 비교**:

```c
// C 스타일
int add(int a, int b) {
    return a + b;
}

typedef int (*MathFunc)(int, int);
MathFunc f = add;  // 함수 포인터
```

**JavaScript/TypeScript 함수**:

```typescript
// 전통적인 함수 선언
function add(a: number, b: number): number {
    return a + b;
}

// 화살표 함수 (람다와 유사)
const add = (a: number, b: number): number => {
    return a + b;
};

// 더 짧게 (한 줄)
const add = (a: number, b: number): number => a + b;

// 함수를 변수에 할당 (일급 객체)
const operation = add;
let result = operation(5, 3);  // 8

// 함수를 인자로 전달 (고차 함수)
function apply(f: (a: number, b: number) => number, x: number, y: number): number {
    return f(x, y);
}

let sum = apply(add, 10, 20);  // 30
```

**콜백 함수**:

```typescript
// C에서는 함수 포인터로 구현
// JavaScript에서는 자연스럽게 지원

// 배열 메서드와 콜백
let numbers = [1, 2, 3, 4, 5];

// map: 각 요소 변환
let doubled = numbers.map(n => n * 2);  // [2, 4, 6, 8, 10]

// filter: 조건 필터링
let evens = numbers.filter(n => n % 2 === 0);  // [2, 4]

// reduce: 누적 연산
let sum = numbers.reduce((acc, n) => acc + n, 0);  // 15
```

#### 1.2.3 비동기 프로그래밍 (가장 중요!)

**C와의 가장 큰 차이점**:

```c
// C: 동기 방식 (블로킹)
FILE* f = fopen("file.txt", "r");  // 파일 열릴 때까지 대기
if (f == NULL) {
    return -1;
}
// ...
fclose(f);
```

**JavaScript: 비동기 방식**:

```typescript
// 1. 콜백 방식 (구식)
fs.readFile("file.txt", (err, data) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(data);
});
// 파일 읽기를 기다리지 않고 다음 코드 실행!

// 2. Promise 방식
const promise = fs.promises.readFile("file.txt");
promise
    .then(data => console.log(data))
    .catch(err => console.error(err));

// 3. async/await 방식 (최신, 권장)
async function readFile() {
    try {
        const data = await fs.promises.readFile("file.txt");
        console.log(data);
    } catch (err) {
        console.error(err);
    }
}

// await는 Promise가 완료될 때까지 기다림
// 하지만 다른 작업은 블로킹하지 않음!
```

**async/await 패턴**:

```typescript
// 데이터베이스 조회 (비동기)
async function getUser(id: number): Promise<User> {
    // await: Promise가 완료될 때까지 기다림
    const user = await db.user.findUnique({ where: { id } });
    return user;
}

// 여러 비동기 작업 순차 실행
async function process() {
    const user = await getUser(1);           // 1번 완료 후
    const posts = await getPosts(user.id);   // 2번 실행
    return { user, posts };
}

// 병렬 실행
async function processParallel() {
    // 동시에 시작
    const [user, posts] = await Promise.all([
        getUser(1),
        getPosts(1)
    ]);
    return { user, posts };
}
```

**왜 비동기가 중요한가?**
- Node.js는 **단일 스레드** (C의 멀티스레드와 다름)
- I/O 작업 (DB, 파일, 네트워크)을 기다리는 동안 다른 작업 처리
- **이벤트 루프**가 비동기 작업 관리

#### 1.2.4 클래스와 객체 (C의 struct + 함수)

**C 구조체와 비교**:

```c
// C 스타일
typedef struct {
    int id;
    char email[100];
} User;

void print_user(User* user) {
    printf("%d: %s\n", user->id, user->email);
}
```

**TypeScript 클래스**:

```typescript
// TypeScript 클래스
class User {
    // 필드 (C의 struct 멤버)
    private id: number;
    private email: string;

    // 생성자
    constructor(id: number, email: string) {
        this.id = id;
        this.email = email;
    }

    // 메서드 (C의 함수, 하지만 객체에 속함)
    print(): void {
        console.log(`${this.id}: ${this.email}`);
    }

    // Getter (계산된 속성)
    get displayName(): string {
        return `User #${this.id}`;
    }
}

// 사용
const user = new User(1, "alice@example.com");
user.print();                   // 1: alice@example.com
console.log(user.displayName);  // User #1
```

**접근 제어자**:
- `public`: 외부에서 접근 가능 (기본값)
- `private`: 클래스 내부에서만 접근
- `protected`: 클래스 + 상속받은 클래스에서 접근
- `readonly`: 읽기 전용

#### 1.2.5 인터페이스와 타입 (TypeScript)

**C의 struct vs TypeScript 인터페이스**:

```c
// C
typedef struct {
    int id;
    char name[50];
} User;
```

```typescript
// TypeScript 인터페이스 (타입 정의만)
interface User {
    id: number;
    name: string;
    email?: string;  // 선택적 속성 (있어도 되고 없어도 됨)
}

// 구현
const user: User = {
    id: 1,
    name: "Alice"
    // email은 생략 가능
};

// 함수 인자 타입 체크
function printUser(user: User): void {
    console.log(user.name);
}
```

**Type Alias**:

```typescript
// 타입 별칭
type UserRole = 'ADMIN' | 'USER' | 'GUEST';  // Union 타입
type ID = number | string;                    // 여러 타입 가능

// 사용
let role: UserRole = 'ADMIN';  // OK
let role2: UserRole = 'INVALID';  // 컴파일 에러!
```

#### 1.2.6 모듈 시스템 (C의 헤더 대신)

**C의 헤더 파일**:

```c
// user.h
#ifndef USER_H
#define USER_H
typedef struct { ... } User;
void print_user(User* user);
#endif

// main.c
#include "user.h"
```

**TypeScript import/export**:

```typescript
// user.service.ts
export class UserService {
    findAll(): User[] {
        // ...
    }
}

export interface User {
    id: number;
    name: string;
}

// user.controller.ts
import { UserService, User } from './user.service';

// 또는 전체 가져오기
import * as UserModule from './user.service';
```

**named export vs default export**:

```typescript
// named export (여러 개 가능)
export class UserService { }
export interface User { }

// default export (파일당 1개만)
export default class UserService { }

// import 방식
import { UserService } from './user.service';  // named
import UserService from './user.service';      // default
```

### 1.3 npm: 패키지 관리자

**C의 수동 라이브러리 관리와 비교**:

```c
// C: 수동으로 라이브러리 다운로드 & 컴파일
# 1. curl로 다운로드
# 2. tar -xzf 압축 해제
# 3. ./configure && make && make install
# 4. Makefile에 -l 플래그 추가
```

**npm (Node Package Manager)**:

```bash
# 패키지 설치 (자동으로 다운로드 & 의존성 해결)
npm install express
npm install --save-dev typescript  # 개발 의존성

# package.json에 자동 기록
```

**package.json** (C의 Makefile + 의존성 목록):

```json
{
  "name": "backend-node-js",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/main.js",
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "@nestjs/core": "^10.0.0",
    "prisma": "^5.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

**scripts 실행**:

```bash
npm run start   # C: make run
npm run build   # C: make
npm test        # C: make test
```

### 1.4 TypeScript vs JavaScript

**왜 TypeScript인가?**

| 기능 | JavaScript | TypeScript |
|------|-----------|------------|
| 타입 체크 | 런타임에만 | 컴파일 타임 |
| 에러 발견 | 실행 시 발견 | 코드 작성 시 발견 |
| IDE 지원 | 제한적 | 강력한 자동완성 |
| 리팩토링 | 위험함 | 안전함 |
| 컴파일 | 불필요 | JS로 컴파일 필요 |

**예시**:

```javascript
// JavaScript (타입 없음)
function add(a, b) {
    return a + b;
}

add(1, 2);        // 3
add("1", "2");    // "12" (문자열 연결!)
add(1, "2");      // "12" (암묵적 변환)
```

```typescript
// TypeScript (타입 있음)
function add(a: number, b: number): number {
    return a + b;
}

add(1, 2);        // 3
add("1", "2");    // 컴파일 에러!
add(1, "2");      // 컴파일 에러!
```

**tsconfig.json** (TypeScript 설정):

```json
{
  "compilerOptions": {
    "target": "ES2021",           // 컴파일 타겟 JS 버전
    "module": "commonjs",         // 모듈 시스템
    "strict": true,               // 엄격한 타입 체크
    "esModuleInterop": true,
    "outDir": "./dist",           // 컴파일 결과물 위치
    "rootDir": "./src"
  }
}
```

### 1.5 NestJS 핵심 개념

NestJS는 **Angular에서 영감을 받은 TypeScript 기반 프레임워크**입니다. C 프로그래머 입장에서 이해하기 어려운 핵심 개념들을 설명합니다.

#### 1.5.1 IoC/DI 컨테이너 (제어의 역전 / 의존성 주입)

**C 스타일 (수동 관리)**:

```c
// C: 모든 의존성을 직접 생성 & 관리
int main() {
    // DB 연결 직접 생성
    sqlite3* db;
    sqlite3_open("database.db", &db);

    // Repository 생성 (DB 전달)
    UserRepository* repo = create_user_repository(db);

    // Service 생성 (Repository 전달)
    UserService* service = create_user_service(repo);

    // Controller 생성 (Service 전달)
    UserController* controller = create_user_controller(service);

    // ... 작업 수행

    // 정리 (역순으로 해제)
    destroy_user_controller(controller);
    destroy_user_service(service);
    destroy_user_repository(repo);
    sqlite3_close(db);
}
```

**NestJS 스타일 (자동 관리)**:

```typescript
// NestJS: 프레임워크가 자동으로 생성 & 주입
@Injectable()
export class UserService {
    // NestJS가 자동으로 PrismaService 인스턴스를 주입!
    constructor(private readonly prisma: PrismaService) {}
    // C에서는 직접 create_prisma_service() 호출해야 함
}

@Controller('users')
export class UserController {
    // NestJS가 자동으로 UserService 인스턴스를 주입!
    constructor(private readonly userService: UserService) {}
    // C에서는 직접 create_user_service(repo) 호출해야 함
}
```

**왜 DI가 필요한가?**
- **C**: `main()`에서 모든 객체 생성 순서 관리 → 복잡함
- **NestJS**: 프레임워크가 의존성 그래프 분석 → 자동 생성 → 편리함
- **테스트**: Mock 객체로 쉽게 교체 가능

#### 1.5.2 데코레이터 (Decorator) - NestJS의 핵심 마법

**C에서는 없는 개념**:

C에서는 함수나 구조체에 메타데이터를 붙이려면:
```c
// C: 매크로나 전처리기 사용
#define ROUTE(path) // ... 복잡한 매크로
```

**TypeScript 데코레이터**:

```typescript
// @로 시작하는 것이 데코레이터
@Controller('users')  // 이 클래스는 '/users' 경로의 컨트롤러
export class UserController {

    @Get()  // HTTP GET 메서드 처리
    findAll(): Promise<User[]> {
        // ...
    }

    @Post()  // HTTP POST 메서드 처리
    @HttpCode(201)  // 응답 코드 201
    create(@Body() dto: CreateUserDto): Promise<User> {
        // @Body(): HTTP 요청 본문을 dto 파라미터로 자동 파싱
    }

    @Get(':id')  // HTTP GET /users/:id
    findOne(@Param('id') id: string): Promise<User> {
        // @Param('id'): URL 파라미터 'id'를 변수로 추출
    }
}
```

**주요 데코레이터**:
- `@Module()`: 모듈 정의 (C의 헤더 파일 + 소스 파일 역할)
- `@Controller()`: REST API 경로 처리
- `@Injectable()`: DI 컨테이너에 등록 (주입 가능한 클래스)
- `@Get()`, `@Post()`, `@Put()`, `@Delete()`: HTTP 메서드
- `@Body()`, `@Param()`, `@Query()`: 요청 데이터 추출

#### 1.5.3 모듈 시스템 (Module)

**C의 파일 구조**:

```c
// user.h
#ifndef USER_H
#define USER_H
typedef struct User { ... } User;
User* create_user(...);
#endif

// user.c
#include "user.h"
User* create_user(...) { ... }

// main.c
#include "user.h"
#include "database.h"
int main() { ... }
```

**NestJS 모듈**:

```typescript
// user.module.ts
@Module({
    imports: [DatabaseModule],      // 다른 모듈 가져오기 (C의 #include)
    controllers: [UserController],  // 이 모듈의 컨트롤러 등록
    providers: [UserService],       // 이 모듈의 서비스 등록 (DI)
    exports: [UserService],         // 다른 모듈에서 사용 가능하게 노출
})
export class UserModule {}

// app.module.ts (진입점)
@Module({
    imports: [UserModule, IssueModule],  // C의 main.c처럼 전체 조립
    controllers: [AppController],
    providers: [AppService],
})
export class AppModule {}
```

**모듈의 역할**:
- **캡슐화**: 관련 기능을 묶음 (User 관련 Controller + Service)
- **의존성 관리**: imports로 명시적 선언
- **재사용**: 다른 프로젝트에서 모듈 단위로 재사용

#### 1.5.4 Prisma ORM (Object-Relational Mapping)

**C의 SQL 직접 처리**:

```c
// C: JDBC/ODBC 스타일 (매우 장황함)
sqlite3_stmt* stmt;
sqlite3_prepare_v2(db, "SELECT id, email, nickname FROM users WHERE id = ?", -1, &stmt, NULL);
sqlite3_bind_int(stmt, 1, user_id);

if (sqlite3_step(stmt) == SQLITE_ROW) {
    int id = sqlite3_column_int(stmt, 0);
    const char* email = (const char*)sqlite3_column_text(stmt, 1);
    const char* nickname = (const char*)sqlite3_column_text(stmt, 2);

    // 수동으로 User 구조체에 매핑
    User* user = malloc(sizeof(User));
    user->id = id;
    strcpy(user->email, email);
    strcpy(user->nickname, nickname);
}
sqlite3_finalize(stmt);
```

**Prisma ORM**:

```typescript
// Prisma: 자동으로 SQL 생성 & 매핑
const user = await prisma.user.findUnique({
    where: { id: userId }
});
// 끝! SQL 작성 불필요, 타입 안전
```

**Prisma 스키마** (데이터베이스 정의):

```prisma
// schema.prisma
model User {
  id           Int       @id @default(autoincrement())
  email        String    @unique
  passwordHash String
  nickname     String
  createdAt    DateTime  @default(now())

  // 관계 (C에서는 외래 키를 수동 관리)
  issues       Issue[]   // 1:N 관계
}

model Issue {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  status      String   @default("OPEN")
  authorId    Int

  // 관계
  author      User     @relation(fields: [authorId], references: [id])
}
```

**Prisma 주요 메서드**:

```typescript
// CREATE
await prisma.user.create({
    data: { email, passwordHash, nickname }
});

// READ
await prisma.user.findUnique({ where: { id } });
await prisma.user.findMany({ where: { status: 'ACTIVE' } });

// UPDATE
await prisma.user.update({
    where: { id },
    data: { nickname: 'newName' }
});

// DELETE
await prisma.user.delete({ where: { id } });

// 관계 조회 (JOIN 자동 처리)
await prisma.issue.findMany({
    include: {
        author: true,  // User도 함께 조회 (C: 수동 JOIN)
    }
});
```

**왜 ORM인가?**
- **C**: SQL 문자열 직접 작성 → 오타 위험, 타입 불일치
- **Prisma**: TypeScript 코드로 작성 → 컴파일 타임 검증, 자동완성

#### 1.5.5 레이어 아키텍처 (3계층)

**C의 평면적 구조**:

```c
// C: 모든 로직이 한 곳에
int handle_create_user(const char* email, const char* password) {
    // 1. 검증
    if (email == NULL || password == NULL) return -1;

    // 2. DB 작업
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(db, "INSERT INTO users ...", -1, &stmt, NULL);
    sqlite3_bind_text(stmt, 1, email, -1, SQLITE_TRANSIENT);
    // ...

    // 3. 결과 반환
    return 0;
}
```

**NestJS 3계층 구조**:

```typescript
// 1. Controller 계층: HTTP 요청 처리
@Controller('users')
export class UserController {
    constructor(private readonly userService: UserService) {}

    @Post()
    async create(@Body() dto: CreateUserDto): Promise<User> {
        // 비즈니스 로직은 Service에 위임
        return this.userService.create(dto);
    }
}

// 2. Service 계층: 비즈니스 로직
@Injectable()
export class UserService {
    constructor(private readonly prisma: PrismaService) {}

    async create(dto: CreateUserDto): Promise<User> {
        // 검증
        if (await this.prisma.user.findUnique({ where: { email: dto.email } })) {
            throw new ConflictException('Email already exists');
        }

        // 비즈니스 로직 (비밀번호 해싱)
        const passwordHash = await bcrypt.hash(dto.password, 10);

        // Repository에 위임 (Prisma가 Repository 역할)
        return this.prisma.user.create({
            data: { email: dto.email, passwordHash, nickname: dto.nickname }
        });
    }
}

// 3. Repository 계층: 데이터 접근 (Prisma가 대체)
// PrismaService가 자동으로 제공
```

**계층별 책임**:
- **Controller**: HTTP 입출력만 처리 (C의 `main()` 일부)
- **Service**: 비즈니스 로직 (C의 핵심 함수들)
- **Repository**: DB 접근 (C의 SQL 코드, Prisma가 대체)

**왜 분리하는가?**
- **테스트**: Service만 단위 테스트 가능 (HTTP 없이)
- **재사용**: Service를 다른 Controller에서도 사용
- **유지보수**: 각 계층 독립적으로 수정

#### 1.5.6 DTO (Data Transfer Object) & Validation

**C의 수동 검증**:

```c
// C: 수동으로 모든 필드 검증
int validate_user_input(const char* email, const char* password) {
    if (email == NULL) return -1;
    if (strlen(email) < 5) return -1;
    if (strchr(email, '@') == NULL) return -1;
    if (password == NULL) return -1;
    if (strlen(password) < 8) return -1;
    // ... 수동 검증 지속
    return 0;
}
```

**NestJS DTO + Validation**:

```typescript
// DTO 정의 (타입 + 검증 규칙)
import { IsEmail, IsString, MinLength, MaxLength } from 'class-validator';

export class CreateUserDto {
    @IsEmail()  // 이메일 형식 자동 검증
    email: string;

    @IsString()
    @MinLength(8)
    @MaxLength(20)
    password: string;  // 8~20자 자동 검증

    @IsString()
    @MinLength(2)
    @MaxLength(20)
    nickname: string;
}

// Controller에서 자동 검증
@Controller('users')
export class UserController {
    @Post()
    async create(@Body() dto: CreateUserDto): Promise<User> {
        // 여기 도달하면 검증 통과 보장!
        // 검증 실패 시 자동으로 400 Bad Request 응답
        return this.userService.create(dto);
    }
}
```

**주요 검증 데코레이터**:
- `@IsEmail()`: 이메일 형식
- `@IsString()`, `@IsNumber()`, `@IsBoolean()`: 타입 검증
- `@MinLength(n)`, `@MaxLength(n)`: 길이 제한
- `@Min(n)`, `@Max(n)`: 숫자 범위
- `@IsOptional()`: 선택적 필드

**왜 DTO인가?**
- **타입 안전**: 컴파일 타임 검증
- **자동 검증**: 데코레이터만 추가하면 끝
- **문서화**: DTO 보면 API 스펙 파악 가능

---

## 2. N2.0: NestJS Bootstrap & CI Baseline

### 2.1 목표

* NestJS 프로젝트 생성
* 환경 설정 (`.env`, Prisma, SQLite)
* 헬스 체크 엔드포인트
* GitHub Actions CI 파이프라인

### 2.2 프로젝트 생성

```bash
# NestJS CLI 설치 (전역)
npm i -g @nestjs/cli

# 프로젝트 생성
nest new backend-node-js

# 디렉토리 이동
cd backend-node-js
```

선택 사항:
- Package manager: npm (또는 pnpm)
- 생성 후 `package.json`, `tsconfig.json`, `src/main.ts` 확인

### 2.3 환경 설정

**1. @nestjs/config 설치**:

```bash
npm install @nestjs/config
```

**2. .env 파일 생성**:

```env
# .env
PORT=3000
NODE_ENV=development
DATABASE_URL="file:./dev.db"
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=1d
```

**3. AppModule에 ConfigModule 추가**:

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,  // 모든 모듈에서 접근 가능
      envFilePath: ['.env.local', '.env'],  // 우선순위
    }),
  ],
})
export class AppModule {}
```

### 2.4 Prisma 설정

**1. Prisma 설치**:

```bash
npm install prisma @prisma/client
npx prisma init
```

**2. schema.prisma 설정**:

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"  // 개발용
  url      = env("DATABASE_URL")
}

// 헬스 체크용 더미 모델 (N2.1에서 실제 모델 추가)
model Health {
  id        Int      @id @default(autoincrement())
  status    String
  timestamp DateTime @default(now())
}
```

**3. Prisma Client 생성**:

```bash
npx prisma generate
npx prisma migrate dev --name init
```

**4. PrismaService 생성**:

```bash
nest g module common/prisma
nest g service common/prisma
```

```typescript
// src/common/prisma/prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  async enableShutdownHooks(app: any) {
    this.$on('beforeExit', async () => {
      await app.close();
    });
  }
}
```

```typescript
// src/common/prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()  // 모든 모듈에서 import 없이 사용 가능
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

### 2.5 헬스 체크 엔드포인트

```bash
nest g module common/health
nest g controller common/health
```

```typescript
// src/common/health/health.controller.ts
import { Controller, Get } from '@nestjs/common';

@Controller('api/health')
export class HealthController {
  @Get()
  check() {
    return {
      status: 'OK',
      timestamp: new Date().toISOString(),
    };
  }
}
```

**테스트**:

```bash
npm run start:dev

# 다른 터미널에서
curl http://localhost:3000/api/health
# {"status":"OK","timestamp":"2025-01-30T10:15:30.123Z"}
```

### 2.6 GitHub Actions CI

**.github/workflows/ci.yml**:

```yaml
name: CI

on:
  push:
    branches: [main, develop, 'feature/**']
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run unit tests
        run: npm test

      - name: Run e2e tests
        run: npm run test:e2e

      - name: Build application
        run: npm run build
```

**기본 e2e 테스트** (`test/app.e2e-spec.ts`):

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/api/health (GET)', () => {
    return request(app.getHttpServer())
      .get('/api/health')
      .expect(200)
      .expect((res) => {
        expect(res.body.status).toBe('OK');
        expect(res.body.timestamp).toBeDefined();
      });
  });
});
```

**Git push**:

```bash
git add .
git commit -m "feat: N2.0 - Bootstrap & CI baseline"
git push origin main
```

→ GitHub Actions에서 자동으로 테스트 실행

---

## 3. N2.1: Layered CRUD & Transaction Pattern

### 3.1 목표

* Controller / Service / Repository 패턴
* DTO validation (class-validator)
* JWT 인증 (Passport)
* Prisma 트랜잭션

### 3.2 Prisma Schema (Issue Tracker)

```prisma
// prisma/schema.prisma
model User {
  id           Int       @id @default(autoincrement())
  email        String    @unique
  passwordHash String
  nickname     String
  createdAt    DateTime  @default(now())

  projects     Project[]
  issues       Issue[]   @relation("Reporter")
  assignedIssues Issue[] @relation("Assignee")
  comments     Comment[]
}

model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  createdAt   DateTime @default(now())

  ownerId     Int
  owner       User     @relation(fields: [ownerId], references: [id])
  issues      Issue[]
}

model Issue {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  status      String   @default("OPEN")  // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  projectId   Int
  project     Project  @relation(fields: [projectId], references: [id])

  reporterId  Int
  reporter    User     @relation("Reporter", fields: [reporterId], references: [id])

  assigneeId  Int?
  assignee    User?    @relation("Assignee", fields: [assigneeId], references: [id])

  comments    Comment[]
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  issueId   Int
  issue     Issue    @relation(fields: [issueId], references: [id])

  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}
```

**마이그레이션**:

```bash
npx prisma migrate dev --name add_issue_tracker
```

### 3.3 DTO 정의

**class-validator 설치**:

```bash
npm install class-validator class-transformer
```

**main.ts에 ValidationPipe 추가**:

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 글로벌 Validation Pipe
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,        // DTO에 없는 필드 제거
    forbidNonWhitelisted: true,  // DTO에 없는 필드 있으면 에러
    transform: true,        // 타입 자동 변환
  }));

  await app.listen(process.env.PORT || 3000);
}
bootstrap();
```

**User DTO**:

```typescript
// src/user/dto/create-user.dto.ts
import { IsEmail, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  password: string;

  @IsString()
  @MinLength(2)
  nickname: string;
}
```

**Issue DTO**:

```typescript
// src/issue/dto/create-issue.dto.ts
import { IsString, IsOptional, IsInt } from 'class-validator';

export class CreateIssueDto {
  @IsString()
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsInt()
  projectId: number;
}

// src/issue/dto/update-issue.dto.ts
import { IsString, IsEnum, IsInt, IsOptional } from 'class-validator';

export class UpdateIssueDto {
  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED'])
  @IsOptional()
  status?: string;

  @IsInt()
  @IsOptional()
  assigneeId?: number;
}
```

### 3.4 JWT 인증

**Passport 설치**:

```bash
npm install @nestjs/passport passport passport-jwt
npm install --save-dev @types/passport-jwt
npm install bcrypt
npm install --save-dev @types/bcrypt
```

**AuthModule 생성**:

```bash
nest g module auth
nest g service auth
nest g controller auth
```

**JWT Strategy**:

```typescript
// src/auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```

**AuthService**:

```typescript
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../common/prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
  ) {}

  async login(email: string, password: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { sub: user.id, email: user.email };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

**AuthModule 설정**:

```typescript
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        secret: config.get('JWT_SECRET'),
        signOptions: { expiresIn: config.get('JWT_EXPIRES_IN') },
      }),
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}
```

**컨트롤러에서 인증 사용**:

```typescript
// src/issue/issue.controller.ts
import { Controller, Get, Post, Body, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller('api/issues')
@UseGuards(AuthGuard('jwt'))  // 모든 엔드포인트에 인증 필요
export class IssueController {
  constructor(private readonly issueService: IssueService) {}

  @Post()
  create(@Body() dto: CreateIssueDto, @Request() req) {
    const userId = req.user.userId;
    return this.issueService.create(dto, userId);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.issueService.findOne(+id);
  }
}
```

### 3.5 Service Layer (비즈니스 로직)

```typescript
// src/issue/issue.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { CreateIssueDto, UpdateIssueDto } from './dto';

@Injectable()
export class IssueService {
  constructor(private prisma: PrismaService) {}

  async create(dto: CreateIssueDto, reporterId: number) {
    return this.prisma.issue.create({
      data: {
        title: dto.title,
        description: dto.description,
        projectId: dto.projectId,
        reporterId,
      },
    });
  }

  async findOne(id: number) {
    const issue = await this.prisma.issue.findUnique({
      where: { id },
      include: {
        reporter: { select: { id: true, nickname: true } },
        assignee: { select: { id: true, nickname: true } },
        comments: {
          include: {
            author: { select: { id: true, nickname: true } },
          },
        },
      },
    });

    if (!issue) {
      throw new NotFoundException(`Issue #${id} not found`);
    }

    return issue;
  }

  async update(id: number, dto: UpdateIssueDto) {
    return this.prisma.issue.update({
      where: { id },
      data: dto,
    });
  }
}
```

### 3.6 트랜잭션

**시나리오**: 댓글 추가 + 이슈 상태 자동 변경

```typescript
// src/comment/comment.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';

@Injectable()
export class CommentService {
  constructor(private prisma: PrismaService) {}

  async createWithStatusUpdate(issueId: number, content: string, authorId: number) {
    return this.prisma.$transaction(async (tx) => {
      // 1. 댓글 생성
      const comment = await tx.comment.create({
        data: {
          content,
          issueId,
          authorId,
        },
      });

      // 2. 이슈 상태 변경 (예: OPEN → IN_PROGRESS)
      await tx.issue.update({
        where: { id: issueId },
        data: { status: 'IN_PROGRESS' },
      });

      return comment;
    });
  }
}
```

**컨트롤러**:

```typescript
@Post(':id/comments')
@UseGuards(AuthGuard('jwt'))
createComment(
  @Param('id') id: string,
  @Body() dto: CreateCommentDto,
  @Request() req,
) {
  return this.commentService.createWithStatusUpdate(
    +id,
    dto.content,
    req.user.userId,
  );
}
```

### 3.7 예외 처리

**전역 예외 필터**:

```typescript
// src/common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : 'Internal server error';

    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
    });
  }
}
```

**main.ts에 적용**:

```typescript
import { AllExceptionsFilter } from './common/filters/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalFilters(new AllExceptionsFilter());
  app.useGlobalPipes(new ValidationPipe({...}));

  await app.listen(3000);
}
```

---

## 4. N2.0-N2.1 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 1 (N2.0-N2.1)은 통과로 본다.

### N2.0 체크리스트

* [ ] NestJS 프로젝트를 생성하고, `npm run start:dev`로 로컬에서 실행할 수 있다.
* [ ] `@nestjs/config`로 환경 변수를 주입하고, `.env` 파일로 설정을 관리할 수 있다.
* [ ] Prisma ORM을 설정하고, SQLite 데이터베이스에 연결할 수 있다.
* [ ] 헬스 체크 엔드포인트 (`GET /api/health`)를 만들고, 200 응답을 확인할 수 있다.
* [ ] GitHub Actions CI가 push 시마다 자동으로 돌아가고, 테스트가 통과한다.

### N2.1 체크리스트

* [ ] Controller / Service 패턴을 이해하고, 각 레이어의 역할을 설명할 수 있다.
* [ ] DTO를 정의하고 `class-validator`로 요청 검증을 할 수 있다.
* [ ] JWT 인증을 구현하고, `@UseGuards(AuthGuard('jwt'))`로 보호된 엔드포인트를 만들 수 있다.
* [ ] Prisma로 CRUD 작업을 수행하고, 관계 (relation) 데이터를 `include`로 조회할 수 있다.
* [ ] Prisma 트랜잭션 (`prisma.$transaction()`)을 사용해서 여러 테이블 변경을 원자적으로 처리할 수 있다.
* [ ] e2e 테스트를 작성하고, `npm run test:e2e`로 전체 플로우를 검증할 수 있다.

여기까지 구현하면:

* **NestJS의 핵심 패턴** (Module, Controller, Service, DI)
* **REST API 구현** (CRUD, DTO validation)
* **JWT 인증**
* **Prisma 트랜잭션**
* **CI 파이프라인**

까지 **NestJS 백엔드 개발의 기초**가 완성된 상태다.

**다음 단계** (문서 3):

* N2.2: Team & RBAC
* N2.3: Batch, Stats, Cache, External API

---

## 5. 참고 자료

* [NestJS 공식 문서](https://docs.nestjs.com/)
* [Prisma 공식 문서](https://www.prisma.io/docs)
* [class-validator GitHub](https://github.com/typestack/class-validator)
* [Passport JWT Strategy](http://www.passportjs.org/packages/passport-jwt/)
