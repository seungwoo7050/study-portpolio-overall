# 문서 3. 고급 패턴 I: 인증/운영 (N2.2-N2.3)

> 이 문서는 **Stage 2 전반부** 용이다.
> 전제:
>
> * Stage 1 (N2.0-N2.1) 완료
> * NestJS Controller/Service/Repository 패턴 이해
> * JWT 인증 구현 경험
> * 이제 **팀 기반 RBAC**, **배치 작업**, **캐싱**, **외부 API 연동**을 익힐 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* N2.0-N2.1 완료 (NestJS 기초 + CRUD + JWT)
* Prisma ORM 사용 경험
* Guard/Decorator 개념 이해 가능

### 이 문서의 목표

1. **팀 기반 RBAC** 구현 (N2.2)
2. **배치 작업**으로 통계 집계 (N2.3)
3. **캐싱**으로 성능 개선 (N2.3)
4. **외부 HTTP API** 안전하게 호출 (N2.3)

### 이 문서가 다루는 범위

* **N2.2**: Team & Role-Based Access Control
* **N2.3**: Batch Jobs, Stats, Cache, External API

**다루지 않는 범위** (다음 문서 4에서):

* N2.4: Elasticsearch Search
* N2.5: Kafka Async Events

---

## 1. N2.2: Team & RBAC

### 1.1 목표

* 팀/역할 도메인 설계
* Guard + 커스텀 데코레이터로 권한 체크
* 401 (미인증) / 403 (권한 없음) / 404 (리소스 없음) 구분

### 1.2 Prisma Schema

```prisma
// prisma/schema.prisma
model Team {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())

  members   TeamMember[]
  items     WorkspaceItem[]
}

model TeamMember {
  id       Int      @id @default(autoincrement())
  role     String   // OWNER, MANAGER, MEMBER
  joinedAt DateTime @default(now())

  teamId   Int
  team     Team     @relation(fields: [teamId], references: [id])

  userId   Int
  user     User     @relation(fields: [userId], references: [id])

  @@unique([teamId, userId])
}

model WorkspaceItem {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  teamId    Int
  team      Team     @relation(fields: [teamId], references: [id])

  createdBy Int
  creator   User     @relation(fields: [createdBy], references: [id])
}
```

### 1.3 커스텀 데코레이터

**@CurrentUser() 데코레이터**:

```typescript
// src/common/decorators/current-user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;  // JwtStrategy에서 설정한 user 객체
  },
);
```

**@Roles() 데코레이터**:

```typescript
// src/common/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

### 1.4 RolesGuard

```typescript
// src/team/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PrismaService } from '../../common/prisma/prisma.service';
import { ROLES_KEY } from '../../common/decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private prisma: PrismaService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;  // @Roles() 없으면 통과
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;  // JWT에서 가져온 user
    const teamId = +request.params.teamId || +request.params.id;

    // 팀 멤버 조회
    const member = await this.prisma.teamMember.findUnique({
      where: {
        teamId_userId: {
          teamId,
          userId: user.userId,
        },
      },
    });

    if (!member) {
      throw new ForbiddenException('You are not a member of this team');
    }

    if (!requiredRoles.includes(member.role)) {
      throw new ForbiddenException(`Requires one of: ${requiredRoles.join(', ')}`);
    }

    return true;
  }
}
```

### 1.5 TeamController 예시

```typescript
// src/team/team.controller.ts
import { Controller, Post, Get, Patch, Delete, Body, Param, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { RolesGuard } from './guards/roles.guard';
import { Roles } from '../common/decorators/roles.decorator';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { TeamService } from './team.service';

@Controller('api/teams')
@UseGuards(AuthGuard('jwt'))  // 모든 엔드포인트에 인증 필요
export class TeamController {
  constructor(private readonly teamService: TeamService) {}

  @Post()
  create(@Body() dto: CreateTeamDto, @CurrentUser() user) {
    return this.teamService.create(dto, user.userId);
  }

  @Post(':teamId/members')
  @UseGuards(RolesGuard)
  @Roles('OWNER', 'MANAGER')  // OWNER 또는 MANAGER만 가능
  addMember(@Param('teamId') teamId: string, @Body() dto: AddMemberDto) {
    return this.teamService.addMember(+teamId, dto);
  }

  @Patch(':teamId/members/:memberId')
  @UseGuards(RolesGuard)
  @Roles('OWNER')  // OWNER만 가능
  updateMemberRole(
    @Param('teamId') teamId: string,
    @Param('memberId') memberId: string,
    @Body() dto: UpdateMemberRoleDto,
  ) {
    return this.teamService.updateMemberRole(+teamId, +memberId, dto.role);
  }

  @Delete(':teamId/members/:memberId')
  @UseGuards(RolesGuard)
  @Roles('OWNER', 'MANAGER')
  removeMember(
    @Param('teamId') teamId: string,
    @Param('memberId') memberId: string,
  ) {
    return this.teamService.removeMember(+teamId, +memberId);
  }
}
```

### 1.6 상태 코드 구분

| 상황 | 상태 코드 | 처리 위치 |
|------|----------|---------|
| 토큰 없음/만료 | 401 Unauthorized | `AuthGuard('jwt')` |
| 팀 멤버 아님 | 403 Forbidden | `RolesGuard` |
| 역할 부족 | 403 Forbidden | `RolesGuard` |
| 리소스 없음 | 404 Not Found | Service Layer |

---

## 2. N2.3: Batch Jobs, Stats, Cache, External API

### 2.1 목표

* `@nestjs/schedule`로 배치 작업 구현
* 통계 테이블 설계 및 조회 API
* `@nestjs/cache-manager`로 캐싱
* `@nestjs/axios`로 외부 API 호출 + 재시도

### 2.2 배치 작업 (Daily Stats)

**@nestjs/schedule 설치**:

```bash
npm install @nestjs/schedule
```

**AppModule에 추가**:

```typescript
// src/app.module.ts
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    ScheduleModule.forRoot(),
    // ...
  ],
})
export class AppModule {}
```

**Prisma Schema (통계 테이블)**:

```prisma
model DailyIssueStats {
  id            Int      @id @default(autoincrement())
  date          DateTime @unique  // YYYY-MM-DD
  createdCount  Int      @default(0)
  resolvedCount Int      @default(0)
  commentCount  Int      @default(0)
  createdAt     DateTime @default(now())
}
```

**StatsService**:

```typescript
// src/stats/stats.service.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../common/prisma/prisma.service';

@Injectable()
export class StatsService {
  constructor(private prisma: PrismaService) {}

  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async aggregateDailyStats() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);

    const nextDay = new Date(yesterday);
    nextDay.setDate(nextDay.getDate() + 1);

    // 생성된 이슈 수
    const createdCount = await this.prisma.issue.count({
      where: {
        createdAt: {
          gte: yesterday,
          lt: nextDay,
        },
      },
    });

    // 해결된 이슈 수
    const resolvedCount = await this.prisma.issue.count({
      where: {
        status: { in: ['RESOLVED', 'CLOSED'] },
        updatedAt: {
          gte: yesterday,
          lt: nextDay,
        },
      },
    });

    // 작성된 댓글 수
    const commentCount = await this.prisma.comment.count({
      where: {
        createdAt: {
          gte: yesterday,
          lt: nextDay,
        },
      },
    });

    // Upsert
    await this.prisma.dailyIssueStats.upsert({
      where: { date: yesterday },
      update: { createdCount, resolvedCount, commentCount },
      create: { date: yesterday, createdCount, resolvedCount, commentCount },
    });
  }

  async getDailyStats(from: Date, to: Date) {
    return this.prisma.dailyIssueStats.findMany({
      where: {
        date: {
          gte: from,
          lte: to,
        },
      },
      orderBy: { date: 'asc' },
    });
  }
}
```

**StatsController**:

```typescript
@Controller('api/stats')
export class StatsController {
  constructor(private readonly statsService: StatsService) {}

  @Get('daily')
  getDailyStats(@Query('from') from: string, @Query('to') to: string) {
    return this.statsService.getDailyStats(new Date(from), new Date(to));
  }
}
```

### 2.3 캐싱 (In-memory)

**@nestjs/cache-manager 설치**:

```bash
npm install @nestjs/cache-manager cache-manager
```

**CacheModule 추가**:

```typescript
// src/app.module.ts
import { CacheModule } from '@nestjs/cache-manager';

@Module({
  imports: [
    CacheModule.register({
      isGlobal: true,
      ttl: 300,  // 5분 (초 단위)
    }),
    // ...
  ],
})
export class AppModule {}
```

**Service에서 캐시 사용**:

```typescript
// src/issue/issue.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class IssueService {
  constructor(
    private prisma: PrismaService,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  async getPopularIssues() {
    const cacheKey = 'popular_issues';

    // 캐시 조회
    const cached = await this.cacheManager.get(cacheKey);
    if (cached) {
      return cached;
    }

    // DB 조회
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const issues = await this.prisma.issue.findMany({
      where: {
        createdAt: { gte: sevenDaysAgo },
      },
      include: {
        _count: {
          select: { comments: true },
        },
      },
      take: 10,
      orderBy: {
        comments: {
          _count: 'desc',
        },
      },
    });

    // 캐시 저장 (TTL은 CacheModule 설정 따름)
    await this.cacheManager.set(cacheKey, issues);

    return issues;
  }
}
```

**Controller**:

```typescript
@Get('popular')
getPopularIssues() {
  return this.issueService.getPopularIssues();
}
```

### 2.4 외부 API 연동

**@nestjs/axios 설치**:

```bash
npm install @nestjs/axios axios
```

**ExternalModule**:

```typescript
// src/external/external.module.ts
import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { ExternalService } from './external.service';
import { ExternalController } from './external.controller';

@Module({
  imports: [
    HttpModule.register({
      timeout: 3000,  // 3초 타임아웃
      maxRedirects: 5,
    }),
  ],
  providers: [ExternalService],
  controllers: [ExternalController],
})
export class ExternalModule {}
```

**ExternalService (재시도 로직)**:

```typescript
// src/external/external.service.ts
import { Injectable, HttpException } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { catchError, retry } from 'rxjs/operators';

@Injectable()
export class ExternalService {
  constructor(private httpService: HttpService) {}

  async getPost(id: number) {
    const url = `https://jsonplaceholder.typicode.com/posts/${id}`;

    try {
      const response = await firstValueFrom(
        this.httpService.get(url).pipe(
          retry(3),  // 최대 3회 재시도
          catchError((error) => {
            throw new HttpException(
              `External API failed: ${error.message}`,
              error.response?.status || 500,
            );
          }),
        ),
      );

      return response.data;
    } catch (error) {
      // Fallback 응답
      return {
        id,
        title: 'Unavailable',
        body: 'External service is currently unavailable',
      };
    }
  }
}
```

**ExternalController**:

```typescript
@Controller('api/external')
export class ExternalController {
  constructor(private readonly externalService: ExternalService) {}

  @Get('posts/:id')
  getPost(@Param('id') id: string) {
    return this.externalService.getPost(+id);
  }
}
```

---

## 3. N2.2-N2.3 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 2 전반부 (N2.2-N2.3)는 통과로 본다.

### N2.2 체크리스트

* [ ] 팀 OWNER/MANAGER/MEMBER 역할을 구분하고, Guard로 권한을 체크할 수 있다.
* [ ] 같은 API를 다른 역할로 호출했을 때 401/403/404를 올바르게 반환한다.
* [ ] 커스텀 데코레이터 (`@Roles()`, `@CurrentUser()`)를 만들고 사용할 수 있다.
* [ ] RolesGuard에서 Prisma로 팀 멤버 역할을 조회하고, 권한을 체크할 수 있다.

### N2.3 체크리스트

* [ ] `@nestjs/schedule`로 배치 작업을 구현하고, 특정 시각에 자동 실행되도록 할 수 있다.
* [ ] 통계 테이블을 설계하고, 날짜 범위 조회 API를 만들 수 있다.
* [ ] 캐시를 적용하고, 같은 요청이 반복될 때 DB 조회가 줄어드는 것을 확인할 수 있다.
* [ ] 외부 HTTP API를 호출하고, 타임아웃/재시도를 처리할 수 있다.
* [ ] 외부 API 실패 시 fallback 응답을 반환할 수 있다.

여기까지 구현하면:

* **팀 기반 RBAC** (Guard + Decorator)
* **배치 작업** (@nestjs/schedule)
* **캐싱** (@nestjs/cache-manager)
* **외부 API 연동** (타임아웃 + 재시도)

까지 **실전 운영에 필요한 핵심 패턴**을 모두 경험한 상태다.

**다음 단계** (문서 4):

* N2.4: Elasticsearch Search
* N2.5: Kafka Async Events

---

## 4. 참고 자료

* [NestJS Guards](https://docs.nestjs.com/guards)
* [NestJS Custom Decorators](https://docs.nestjs.com/custom-decorators)
* [NestJS Task Scheduling](https://docs.nestjs.com/techniques/task-scheduling)
* [NestJS Caching](https://docs.nestjs.com/techniques/caching)
* [NestJS HTTP Module](https://docs.nestjs.com/techniques/http-module)
