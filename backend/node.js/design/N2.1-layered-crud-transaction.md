# 레이어드 CRUD & 트랜잭션 패턴 설계 일지 (N2.1)
> Issue Tracker 도메인을 통한 NestJS Controller/Service 패턴과 Prisma 트랜잭션 학습

## 1. 문제 정의 & 요구사항

### 1.1 목표

**레이어드 아키텍처**와 **트랜잭션 관리** 패턴을 실제 도메인에 적용:
- Controller/Service 레이어 분리
- Prisma를 이용한 데이터베이스 CRUD 작업
- DTO를 통한 입출력 검증 및 변환
- JWT 기반 인증 구현
- Prisma 트랜잭션으로 데이터 일관성 보장

### 1.2 기능 요구사항

#### 1.2.1 Issue Tracker 도메인

**엔티티:**
- `User`: 사용자 (이슈 작성자, 담당자)
- `Project`: 프로젝트 (이슈 컨테이너)
- `Issue`: 이슈 (버그, 기능 요청 등)
- `Comment`: 이슈 댓글

**관계:**
```text
User 1 ──< N Issue (reporter)
User 1 ──< N Issue (assignee, nullable)
User 1 ──< N Comment
Project 1 ──< N Issue
Issue 1 ──< N Comment
```

#### 1.2.2 API 엔드포인트

**인증:**
- `POST /api/users` - 회원가입
- `POST /api/auth/login` - 로그인 (JWT 발급)

**프로젝트:**
- `POST /api/projects` - 프로젝트 생성
- `GET /api/projects` - 프로젝트 목록 조회

**이슈:**
- `POST /api/projects/:projectId/issues` - 이슈 생성
- `GET /api/projects/:projectId/issues` - 이슈 목록 조회 (페이징, 필터링)
- `GET /api/issues/:id` - 이슈 상세 조회
- `PUT /api/issues/:id` - 이슈 수정
- `DELETE /api/issues/:id` - 이슈 삭제

**댓글:**
- `POST /api/issues/:issueId/comments` - 댓글 작성
- `GET /api/issues/:issueId/comments` - 댓글 목록 조회

### 1.3 비기능 요구사항

#### 1.3.1 보안
- 비밀번호 bcrypt 해싱 (salt rounds: 10)
- JWT 토큰 기반 인증
- 토큰 만료 시간: 1일 (개발), 1시간 (프로덕션)

#### 1.3.2 검증
- DTO validation: `class-validator` 데코레이터
- 이메일 형식 검증
- 필수 필드 검증
- 문자열 길이 제한

#### 1.3.3 성능
- 페이지네이션 기본 사이즈: 10
- N+1 쿼리 방지: Prisma `include` 사용
- 동시 쿼리: `Promise.all`

#### 1.3.4 에러 처리
- 404: 리소스 없음 (`NotFoundException`)
- 400: 잘못된 요청 (Validation 실패)
- 401: 인증 실패 (`UnauthorizedException`)
- 409: 중복 데이터 (`ConflictException`)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 레이어드 아키텍처인가?

**단일 레이어의 문제점:**
- Controller에 비즈니스 로직 혼재 → 테스트 어려움
- DB 쿼리 로직 중복 → 유지보수성 저하
- 관심사 분리 부족 → 코드 가독성 감소

**레이어 분리의 이점:**
```text
[Controller] → HTTP 요청/응답 처리
    ↓ DTO
[Service] → 비즈니스 로직
    ↓ Entity
[Repository/Prisma] → 데이터 접근
    ↓
[Database]
```

**각 레이어의 책임:**
- **Controller**: 라우팅, DTO 검증, HTTP 상태 코드, 인증 가드
- **Service**: 비즈니스 규칙, 트랜잭션 관리, 도메인 로직
- **Prisma**: SQL 쿼리 생성, 타입 안전 데이터 접근

### 2.2 왜 DTO 패턴인가?

**Entity 직접 노출의 문제:**
- 민감 정보 노출 위험 (`passwordHash`)
- API 계약 변경 어려움 (DB 스키마 = API 스키마)
- 검증 로직 분산

**DTO 사용의 이점:**
- **요청 DTO**: 검증 규칙 집중, 타입 변환
- **응답 DTO**: 민감 정보 제거, API 버전 관리 용이
- **계층 간 결합도 감소**: DB 스키마 변경이 API에 직접 영향 없음

**예시:**
```typescript
// 요청 DTO
class CreateIssueDto {
  @IsString()
  @Length(1, 200)
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsInt()
  @IsOptional()
  assigneeId?: number;
}

// 응답 DTO
class IssueResponseDto {
  id: number;
  title: string;
  status: string;
  reporter: UserResponseDto;  // passwordHash 제외
  assignee?: UserResponseDto;
  createdAt: string;
}
```

### 2.3 왜 Prisma 트랜잭션인가?

**트랜잭션이 필요한 시나리오:**
1. **팀 생성** (N2.2):
   - Team 생성 + TeamMember 생성 (OWNER)
   - 둘 중 하나 실패 시 롤백 필요

2. **이슈 상태 변경**:
   - Issue 업데이트 + 통계 테이블 업데이트
   - ACID 보장

**Prisma 트랜잭션 API:**
```typescript
// Sequential 트랜잭션
await prisma.$transaction(async (tx) => {
  const team = await tx.team.create({ data: { name } });
  await tx.teamMember.create({
    data: { teamId: team.id, userId, role: 'OWNER' }
  });
});

// Batch 트랜잭션
await prisma.$transaction([
  prisma.issue.update(...),
  prisma.dailyIssueStats.upsert(...),
]);
```

---

## 3. 데이터베이스 스키마 설계

### 3.1 Prisma 스키마 (N2.1 도메인)

```prisma
// prisma/schema.prisma

// User 모델
model User {
  id           Int       @id @default(autoincrement())
  email        String    @unique
  passwordHash String
  nickname     String
  createdAt    DateTime  @default(now())

  // Relations
  reportedIssues Issue[]   @relation("ReportedIssues")
  assignedIssues Issue[]   @relation("AssignedIssues")
  comments       Comment[]
}

// Project 모델
model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  createdAt   DateTime @default(now())

  // Relations
  issues Issue[]
}

// Issue 모델
// Valid status: OPEN, IN_PROGRESS, RESOLVED, CLOSED
model Issue {
  id          Int      @id @default(autoincrement())
  projectId   Int
  reporterId  Int
  assigneeId  Int?
  title       String
  description String?
  status      String   @default("OPEN")
  viewCount   Int      @default(0)  // N2.3: 인기 이슈 추적용
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project  Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  reporter User      @relation("ReportedIssues", fields: [reporterId], references: [id], onDelete: Cascade)
  assignee User?     @relation("AssignedIssues", fields: [assigneeId], references: [id], onDelete: SetNull)
  comments Comment[]

  @@index([projectId])
  @@index([reporterId])
  @@index([assigneeId])
  @@index([status])
}

// Comment 모델
model Comment {
  id        Int      @id @default(autoincrement())
  issueId   Int
  authorId  Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  issue  Issue @relation(fields: [issueId], references: [id], onDelete: Cascade)
  author User  @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([issueId])
  @@index([authorId])
}
```

### 3.2 스키마 설계 결정

**인덱스 전략:**
- 외래 키에 인덱스 (`projectId`, `reporterId`, `assigneeId`)
- 자주 필터링되는 필드 (`status`)
- SQLite는 외래 키 자동 인덱스 없으므로 명시적 추가

**Cascade vs SetNull:**
- `onDelete: Cascade`: 프로젝트 삭제 시 이슈도 삭제
- `onDelete: SetNull`: 담당자 탈퇴 시 이슈는 유지, assigneeId만 null

**@updatedAt:**
- Prisma가 자동으로 업데이트 시점 기록
- 별도 코드 불필요

---

## 4. 레이어 아키텍처 설계

### 4.1 모듈 구조

```text
src/
├── user/
│   ├── user.module.ts
│   ├── user.controller.ts
│   ├── user.service.ts
│   ├── user.service.spec.ts
│   └── dto/
│       ├── create-user.dto.ts
│       └── user-response.dto.ts
├── auth/
│   ├── auth.module.ts
│   ├── auth.controller.ts
│   ├── auth.service.ts
│   ├── strategies/
│   │   └── jwt.strategy.ts
│   ├── guards/
│   │   └── jwt-auth.guard.ts
│   └── dto/
│       ├── login.dto.ts
│       └── auth-response.dto.ts
├── project/
│   ├── project.module.ts
│   ├── project.controller.ts
│   ├── project.service.ts
│   └── dto/
│       ├── create-project.dto.ts
│       └── project-response.dto.ts
├── issue/
│   ├── issue.module.ts
│   ├── issue.controller.ts
│   ├── issue.service.ts
│   ├── issue.service.spec.ts
│   └── dto/
│       ├── create-issue.dto.ts
│       ├── update-issue.dto.ts
│       ├── query-issues.dto.ts
│       └── issue-response.dto.ts
└── comment/
    ├── comment.module.ts
    ├── comment.controller.ts
    ├── comment.service.ts
    └── dto/
        ├── create-comment.dto.ts
        └── comment-response.dto.ts
```

### 4.2 Controller 레이어

**책임:**
- HTTP 요청 파싱 (경로 파라미터, 쿼리, 바디)
- DTO 검증 (ValidationPipe)
- 인증 가드 적용
- 서비스 호출
- HTTP 응답 반환 (상태 코드, DTO)

**예시: IssueController**
```typescript
@Controller('issues')
@UseGuards(JwtAuthGuard)  // 모든 엔드포인트 인증 필요
export class IssueController {
  constructor(private issueService: IssueService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(
    @Body() createIssueDto: CreateIssueDto,
    @CurrentUser() user: UserPayload,
  ): Promise<IssueResponseDto> {
    return this.issueService.create(user.id, createIssueDto);
  }

  @Get(':id')
  async findOne(@Param('id', ParseIntPipe) id: number): Promise<IssueResponseDto> {
    return this.issueService.findById(id);
  }

  @Put(':id')
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateIssueDto: UpdateIssueDto,
  ): Promise<IssueResponseDto> {
    return this.issueService.update(id, updateIssueDto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  async delete(@Param('id', ParseIntPipe) id: number): Promise<void> {
    await this.issueService.delete(id);
  }
}
```

**설계 포인트:**
- `@UseGuards(JwtAuthGuard)`: 클래스 레벨에 적용 → 모든 메서드 보호
- `@CurrentUser()`: 커스텀 데코레이터로 JWT payload에서 사용자 추출
- `ParseIntPipe`: 경로 파라미터 자동 타입 변환 및 검증
- `@HttpCode()`: 성공 시 상태 코드 명시

### 4.3 Service 레이어

**책임:**
- 비즈니스 로직
- 데이터 검증 (존재 여부, 권한 등)
- Prisma를 통한 데이터베이스 작업
- 트랜잭션 관리
- Entity → DTO 변환

**예시: IssueService**
```typescript
@Injectable()
export class IssueService {
  constructor(private prisma: PrismaService) {}

  async create(
    projectId: number,
    reporterId: number,
    createIssueDto: CreateIssueDto,
  ): Promise<IssueResponseDto> {
    // 1. 프로젝트 존재 확인
    const project = await this.prisma.project.findUnique({
      where: { id: projectId },
    });
    if (!project) {
      throw new NotFoundException('Project', projectId);
    }

    // 2. 담당자 존재 확인 (선택적)
    if (createIssueDto.assigneeId) {
      const assignee = await this.prisma.user.findUnique({
        where: { id: createIssueDto.assigneeId },
      });
      if (!assignee) {
        throw new NotFoundException('User', createIssueDto.assigneeId);
      }
    }

    // 3. 이슈 생성
    const issue = await this.prisma.issue.create({
      data: {
        projectId,
        reporterId,
        title: createIssueDto.title,
        description: createIssueDto.description,
        assigneeId: createIssueDto.assigneeId,
      },
      include: {
        reporter: true,
        assignee: true,
      },
    });

    return this.mapToResponse(issue);
  }

  async findByProject(
    projectId: number,
    query: QueryIssuesDto,
  ): Promise<PaginatedIssuesResponseDto> {
    const { status, page = 1, size = 10 } = query;
    const skip = (page - 1) * size;

    const where = {
      projectId,
      ...(status && { status }),
    };

    // N+1 방지: Promise.all로 동시 쿼리
    const [issues, total] = await Promise.all([
      this.prisma.issue.findMany({
        where,
        include: { reporter: true, assignee: true },
        orderBy: { createdAt: 'desc' },
        skip,
        take: size,
      }),
      this.prisma.issue.count({ where }),
    ]);

    const items = issues.map(issue => this.mapToResponse(issue));
    return new PaginatedIssuesResponseDto(items, total, page, size);
  }

  private mapToResponse(issue: any): IssueResponseDto {
    return new IssueResponseDto(issue);
  }
}
```

**설계 포인트:**
- **검증 우선**: DB 작업 전 존재 여부 확인
- **include**: 관련 엔티티 한 번에 로드 (N+1 방지)
- **Promise.all**: 독립적인 쿼리 동시 실행
- **mapToResponse**: Entity → DTO 변환 메서드

### 4.4 DTO 레이어

#### 요청 DTO

```typescript
// dto/create-issue.dto.ts
import { IsString, IsInt, IsOptional, Length } from 'class-validator';

export class CreateIssueDto {
  @IsString()
  @Length(1, 200)
  title: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsInt()
  @IsOptional()
  assigneeId?: number;
}

// dto/update-issue.dto.ts
export class UpdateIssueDto {
  @IsString()
  @IsOptional()
  @Length(1, 200)
  title?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED'])
  @IsOptional()
  status?: string;

  @IsInt()
  @IsOptional()
  assigneeId?: number;
}

// dto/query-issues.dto.ts
export class QueryIssuesDto {
  @IsEnum(['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED'])
  @IsOptional()
  status?: string;

  @IsInt()
  @IsOptional()
  @Min(1)
  page?: number = 1;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Max(100)
  size?: number = 10;
}
```

#### 응답 DTO

```typescript
// dto/issue-response.dto.ts
export class IssueResponseDto {
  id: number;
  projectId: number;
  title: string;
  description?: string;
  status: string;
  reporter: UserResponseDto;
  assignee?: UserResponseDto;
  createdAt: string;
  updatedAt: string;

  constructor(issue: any) {
    this.id = issue.id;
    this.projectId = issue.projectId;
    this.title = issue.title;
    this.description = issue.description;
    this.status = issue.status;
    this.reporter = new UserResponseDto(issue.reporter);
    this.assignee = issue.assignee ? new UserResponseDto(issue.assignee) : undefined;
    this.createdAt = issue.createdAt.toISOString();
    this.updatedAt = issue.updatedAt.toISOString();
  }
}

// dto/user-response.dto.ts
export class UserResponseDto {
  id: number;
  email: string;
  nickname: string;

  constructor(user: any) {
    this.id = user.id;
    this.email = user.email;
    this.nickname = user.nickname;
    // passwordHash 제외 (보안)
  }
}
```

---

## 5. JWT 인증 구현

### 5.1 인증 흐름

```text
1. 회원가입/로그인
   POST /api/users → bcrypt 해싱 → DB 저장
   POST /api/auth/login → 비밀번호 검증 → JWT 발급

2. 인증된 요청
   GET /api/issues/:id
     ↓
   Authorization: Bearer <token>
     ↓
   JwtAuthGuard → JWT 검증 → Request에 user 주입
     ↓
   Controller → @CurrentUser() 데코레이터로 사용자 추출
```

### 5.2 AuthService 구현

```typescript
@Injectable()
export class AuthService {
  constructor(
    private userService: UserService,
    private jwtService: JwtService,
  ) {}

  async login(loginDto: LoginDto): Promise<AuthResponseDto> {
    const user = await this.userService.findByEmail(loginDto.email);

    const isPasswordValid = await this.userService.validatePassword(
      user,
      loginDto.password,
    );

    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { sub: user.id, email: user.email };
    const accessToken = this.jwtService.sign(payload);

    return new AuthResponseDto(accessToken, new UserResponseDto(user));
  }
}
```

### 5.3 JwtStrategy 구현

```typescript
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```

### 5.4 CurrentUser 데코레이터

```typescript
export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

---

## 6. 트랜잭션 패턴

### 6.1 Sequential 트랜잭션 (N2.2에서 사용)

```typescript
// TeamService.createTeam
async createTeam(userId: number, createTeamDto: CreateTeamDto) {
  return this.prisma.$transaction(async (tx) => {
    // 1. 팀 생성
    const team = await tx.team.create({
      data: { name: createTeamDto.name },
    });

    // 2. 생성자를 OWNER로 추가
    await tx.teamMember.create({
      data: {
        teamId: team.id,
        userId: userId,
        role: TeamRole.OWNER,
      },
    });

    return team;
  });
}
```

**특징:**
- 콜백 내부의 `tx` 사용
- 하나의 작업 실패 시 전체 롤백
- 순차적 의존 관계 (team.id 필요)

### 6.2 Batch 트랜잭션

```typescript
// 예시: 이슈 상태 변경 + 통계 업데이트
await this.prisma.$transaction([
  this.prisma.issue.update({
    where: { id },
    data: { status: 'RESOLVED' },
  }),
  this.prisma.dailyIssueStats.update({
    where: { date: today },
    data: { resolvedCount: { increment: 1 } },
  }),
]);
```

**특징:**
- 독립적인 작업 배열
- 모두 성공 또는 모두 실패
- 더 간결한 문법

---

## 7. 커스텀 예외 처리

### 7.1 도메인 예외 정의

```typescript
// common/exceptions/domain.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common';

export class NotFoundException extends HttpException {
  constructor(resource: string, id: number | string) {
    super(`${resource} with id ${id} not found`, HttpStatus.NOT_FOUND);
  }
}

export class ConflictException extends HttpException {
  constructor(message: string) {
    super(message, HttpStatus.CONFLICT);
  }
}

export class UnauthorizedException extends HttpException {
  constructor(message: string) {
    super(message, HttpStatus.UNAUTHORIZED);
  }
}
```

### 7.2 사용 예시

```typescript
// UserService
async findByEmail(email: string): Promise<User> {
  const user = await this.prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    throw new NotFoundException('User', email);
  }

  return user;
}

async create(createUserDto: CreateUserDto): Promise<User> {
  const existing = await this.prisma.user.findUnique({
    where: { email: createUserDto.email },
  });

  if (existing) {
    throw new ConflictException('Email already exists');
  }

  const passwordHash = await bcrypt.hash(createUserDto.password, 10);

  return this.prisma.user.create({
    data: {
      email: createUserDto.email,
      passwordHash,
      nickname: createUserDto.nickname,
    },
  });
}
```

---

## 8. 테스트 전략

### 8.1 Service 단위 테스트

```typescript
// issue.service.spec.ts
describe('IssueService', () => {
  let service: IssueService;
  let prisma: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        IssueService,
        {
          provide: PrismaService,
          useValue: {
            issue: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
              delete: jest.fn(),
            },
            project: {
              findUnique: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<IssueService>(IssueService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  it('should create an issue', async () => {
    const projectId = 1;
    const reporterId = 1;
    const createDto = { title: 'Bug', description: 'Fix this' };

    jest.spyOn(prisma.project, 'findUnique').mockResolvedValue({ id: 1, name: 'Project' } as any);
    jest.spyOn(prisma.issue, 'create').mockResolvedValue({
      id: 1,
      projectId,
      reporterId,
      ...createDto,
      status: 'OPEN',
      reporter: { id: 1, email: 'test@example.com', nickname: 'Test' },
    } as any);

    const result = await service.create(projectId, reporterId, createDto);

    expect(result).toHaveProperty('id', 1);
    expect(result.title).toBe('Bug');
  });

  it('should throw NotFoundException when project does not exist', async () => {
    jest.spyOn(prisma.project, 'findUnique').mockResolvedValue(null);

    await expect(
      service.create(999, 1, { title: 'Bug' }),
    ).rejects.toThrow(NotFoundException);
  });
});
```

### 8.2 e2e 테스트

```typescript
// test/issue.e2e-spec.ts
describe('Issue API (e2e)', () => {
  let app: INestApplication;
  let accessToken: string;

  beforeAll(async () => {
    // ... 앱 초기화

    // 테스트용 사용자 생성 및 로그인
    await request(app.getHttpServer())
      .post('/api/users')
      .send({ email: 'test@example.com', password: 'password', nickname: 'Test' });

    const loginRes = await request(app.getHttpServer())
      .post('/api/auth/login')
      .send({ email: 'test@example.com', password: 'password' });

    accessToken = loginRes.body.accessToken;
  });

  it('should create a project and issue', async () => {
    // 1. 프로젝트 생성
    const projectRes = await request(app.getHttpServer())
      .post('/api/projects')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ name: 'Test Project', description: 'Description' })
      .expect(201);

    const projectId = projectRes.body.id;

    // 2. 이슈 생성
    const issueRes = await request(app.getHttpServer())
      .post(`/api/projects/${projectId}/issues`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ title: 'Bug Report', description: 'Details' })
      .expect(201);

    expect(issueRes.body).toHaveProperty('id');
    expect(issueRes.body.title).toBe('Bug Report');
    expect(issueRes.body.status).toBe('OPEN');
  });

  it('should return 401 without token', async () => {
    await request(app.getHttpServer())
      .get('/api/projects')
      .expect(401);
  });
});
```

---

## 9. API 엔드포인트 명세

### 9.1 인증 API

**POST /api/users**
- 요청: `{ email, password, nickname }`
- 응답: `{ id, email, nickname, createdAt }`
- 상태: 201 Created, 409 Conflict (중복 이메일)

**POST /api/auth/login**
- 요청: `{ email, password }`
- 응답: `{ accessToken, user: { id, email, nickname } }`
- 상태: 200 OK, 401 Unauthorized (인증 실패)

### 9.2 프로젝트 API

**POST /api/projects**
- 인증: 필수
- 요청: `{ name, description? }`
- 응답: `{ id, name, description, createdAt }`
- 상태: 201 Created

**GET /api/projects**
- 인증: 필수
- 응답: `[{ id, name, description, createdAt }]`
- 상태: 200 OK

### 9.3 이슈 API

**POST /api/projects/:projectId/issues**
- 인증: 필수
- 요청: `{ title, description?, assigneeId? }`
- 응답: `{ id, title, status, reporter, assignee?, ... }`
- 상태: 201 Created, 404 Not Found (프로젝트 없음)

**GET /api/projects/:projectId/issues?status=&page=&size=**
- 인증: 필수
- 쿼리 파라미터:
  - `status`: OPEN | IN_PROGRESS | RESOLVED | CLOSED
  - `page`: 페이지 번호 (기본: 1)
  - `size`: 페이지 크기 (기본: 10, 최대: 100)
- 응답: `{ items: [...], total, page, size }`
- 상태: 200 OK

**GET /api/issues/:id**
- 인증: 필수
- 응답: `{ id, title, status, reporter, assignee?, comments?, ... }`
- 상태: 200 OK, 404 Not Found

**PUT /api/issues/:id**
- 인증: 필수
- 요청: `{ title?, description?, status?, assigneeId? }`
- 응답: `{ id, title, status, ... }`
- 상태: 200 OK, 404 Not Found

**DELETE /api/issues/:id**
- 인증: 필수
- 응답: 없음
- 상태: 204 No Content, 404 Not Found

### 9.4 댓글 API

**POST /api/issues/:issueId/comments**
- 인증: 필수
- 요청: `{ content }`
- 응답: `{ id, content, author, createdAt }`
- 상태: 201 Created, 404 Not Found (이슈 없음)

**GET /api/issues/:issueId/comments**
- 인증: 필수
- 응답: `[{ id, content, author, createdAt, updatedAt }]`
- 상태: 200 OK

---

## 10. 검증 체크리스트

### 10.1 기능 검증

- [ ] 회원가입 성공 (비밀번호 해싱 확인)
- [ ] 로그인 성공 (JWT 토큰 발급)
- [ ] 중복 이메일 가입 실패 (409 Conflict)
- [ ] 잘못된 비밀번호 로그인 실패 (401 Unauthorized)
- [ ] 프로젝트 생성/조회 성공
- [ ] 이슈 생성/조회/수정/삭제 CRUD 성공
- [ ] 존재하지 않는 이슈 조회 시 404
- [ ] 댓글 작성/조회 성공
- [ ] 페이지네이션 동작 (page, size 파라미터)
- [ ] status 필터링 동작

### 10.2 인증 검증

- [ ] 토큰 없이 요청 시 401
- [ ] 만료된 토큰 요청 시 401
- [ ] 유효한 토큰으로 요청 시 성공

### 10.3 검증 규칙 테스트

- [ ] 빈 제목 이슈 생성 시 400 (Length 검증)
- [ ] 잘못된 이메일 형식 가입 시 400
- [ ] page < 1 요청 시 400
- [ ] size > 100 요청 시 400

### 10.4 코드 품질

- [ ] Service 단위 테스트 통과
- [ ] e2e 테스트 통과
- [ ] ESLint 경고 0개
- [ ] DTO에 모든 필드 검증 데코레이터 적용

---

## 11. 다음 마일스톤과의 연결

### N2.1에서 확립된 것

- Controller/Service 레이어 패턴
- Prisma CRUD 작업
- DTO 검증 및 변환
- JWT 인증 (JwtAuthGuard)
- 커스텀 예외 처리
- 페이지네이션 패턴

### N2.2에서 추가될 것

- Team, TeamMember 도메인
- RBAC (역할 기반 권한)
- 커스텀 Guard (RolesGuard)
- 커스텀 데코레이터 (@Roles)
- 403 Forbidden 응답 처리
- 트랜잭션 활용 (팀 생성 시)

---

## 12. 완료 기준

✅ User, Project, Issue, Comment 모델 Prisma 스키마 작성
✅ 마이그레이션 실행 완료
✅ UserService, AuthService, ProjectService, IssueService, CommentService 구현
✅ 모든 Controller 구현 (인증 가드 적용)
✅ DTO 검증 규칙 적용
✅ JWT 인증 구현 (Passport + JwtStrategy)
✅ bcrypt 비밀번호 해싱
✅ Service 단위 테스트 작성
✅ e2e 테스트 작성 (Issue CRUD 플로우)
✅ CI 테스트 통과
✅ Postman/Insomnia로 API 수동 테스트 완료

---

## 13. 참고 자료

- [NestJS Authentication](https://docs.nestjs.com/security/authentication)
- [Prisma Transactions](https://www.prisma.io/docs/concepts/components/prisma-client/transactions)
- [class-validator Decorators](https://github.com/typestack/class-validator#validation-decorators)
- [JWT Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
