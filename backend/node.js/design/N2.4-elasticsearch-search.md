# Elasticsearch 검색 설계 일지 (N2.4)
> Product 카탈로그 전문 검색을 통한 Elasticsearch 통합 및 검색 인덱스 동기화 학습

## 1. 문제 정의 & 요구사항

### 1.1 목표

**RDB와 분리된 검색 인덱스** 설계 및 구현:
- Product 도메인 모델링
- Elasticsearch 클라이언트 통합
- 전문 검색(full-text search) API
- DB ↔ ES 동기화 전략

### 1.2 기능 요구사항

#### 1.2.1 Product 도메인

**엔티티:**
- `Product`: 상품
  - `id`: 고유 ID
  - `name`: 상품명
  - `description`: 설명
  - `category`: 카테고리
  - `brand`: 브랜드
  - `price`: 가격
  - `status`: 상태 (ACTIVE/INACTIVE)

#### 1.2.2 Elasticsearch 인덱스

**인덱스명:** `products`

**매핑:**
```json
{
  "mappings": {
    "properties": {
      "id": { "type": "integer" },
      "name": { "type": "text" },
      "description": { "type": "text" },
      "category": { "type": "keyword" },
      "brand": { "type": "keyword" },
      "price": { "type": "float" },
      "status": { "type": "keyword" },
      "created_at": { "type": "date" }
    }
  }
}
```

**타입 설명:**
- `text`: 전문 검색 (토큰화, 분석)
- `keyword`: 정확 일치, 필터링
- `float`: 범위 쿼리
- `date`: 날짜 범위

#### 1.2.3 API 엔드포인트

**상품 CRUD (DB):**
- `POST /api/products` - 상품 생성 (DB + ES)
- `GET /api/products/:id` - 상품 조회 (DB)
- `PUT /api/products/:id` - 상품 수정 (DB + ES)
- `DELETE /api/products/:id` - 상품 삭제 (DB + ES)

**검색 API (ES):**
- `GET /api/search/products?q=&category=&brand=&minPrice=&maxPrice=&page=&size=`
  - `q`: 키워드 (name, description 검색)
  - `category`: 카테고리 필터
  - `brand`: 브랜드 필터
  - `minPrice`, `maxPrice`: 가격 범위
  - `page`, `size`: 페이지네이션

**관리 API:**
- `POST /api/admin/reindex/products` - 전체 재색인 (DB → ES)

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 검색 응답 시간 < 100ms (1000개 문서 기준)
- 페이지네이션 지원

#### 1.3.2 일관성
- 상품 생성/수정/삭제 시 ES 자동 업데이트
- 재색인 API로 불일치 복구 가능

#### 1.3.3 확장성
- ES 연결 실패 시 애플리케이션 시작 가능 (ELASTICSEARCH_ENABLED=false)
- 환경별 ES 설정 (개발/프로덕션)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 Elasticsearch인가?

**RDB 전문 검색의 한계:**
```sql
-- ❌ LIKE 쿼리: 느리고 인덱스 사용 불가
SELECT * FROM products WHERE name LIKE '%노트북%' OR description LIKE '%노트북%';
```

**문제점:**
- 인덱스 활용 불가 (full table scan)
- 형태소 분석 없음 ("노트북"은 검색되지만 "노트북의" 검색 안 됨)
- 동의어, 오타 보정 불가
- 검색 순위(relevance score) 없음

**Elasticsearch의 강점:**
- **역인덱스 (Inverted Index)**: 빠른 전문 검색
- **분석기 (Analyzer)**: 토큰화, 소문자 변환, 불용어 제거
- **점수 계산 (TF-IDF, BM25)**: 관련도 순 정렬
- **집계 (Aggregations)**: 카테고리별 상품 수 등
- **확장성**: 샤드/레플리카로 수평 확장

### 2.2 RDB vs ES 역할 분담

| 역할 | RDB (Prisma) | Elasticsearch |
|------|--------------|---------------|
| 데이터 저장소 | ✅ 원본 (Source of Truth) | ❌ 복제본 |
| CRUD 작업 | ✅ 주 저장소 | ❌ 동기화만 |
| 상품 상세 조회 | ✅ ID 기반 조회 | ❌ |
| 전문 검색 | ❌ 느림 | ✅ 전용 |
| 복잡한 필터링 | ❌ 조인 비용 | ✅ 효율적 |
| 트랜잭션 | ✅ ACID 보장 | ❌ |

**원칙:**
- **Write**: RDB 먼저 → 성공 시 ES 업데이트
- **Read**: 검색은 ES, 상세는 RDB

### 2.3 동기화 전략

**단순 전략 (이 프로젝트 선택):**
```text
상품 생성/수정/삭제
  ↓
RDB 작업 성공
  ↓
ES 인덱스 갱신
  ↓
완료
```

**장점:** 구현 간단, 코드 한 곳에서 관리
**단점:** RDB 커밋 후 ES 실패 시 불일치 발생

**대안:**
- **이벤트 기반 (N2.5 방식)**: Kafka로 변경 이벤트 발행 → Consumer가 ES 업데이트
- **Change Data Capture (CDC)**: Debezium 등으로 DB binlog 읽어서 ES 동기화

---

## 3. 데이터베이스 스키마 설계

### 3.1 Prisma 스키마 (N2.4 도메인)

```prisma
// Product 모델
// Valid status values: ACTIVE, INACTIVE
model Product {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  category    String
  brand       String
  price       Float
  status      String   @default("ACTIVE")  // ACTIVE, INACTIVE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([brand])
  @@index([status])
  @@index([price])
}
```

**인덱스 전략:**
- 자주 필터링되는 필드에 인덱스
- ES로 검색하더라도 RDB 조회 시 성능 보장

---

## 4. Elasticsearch 통합

### 4.1 ElasticsearchService

```typescript
// src/elasticsearch/elasticsearch.service.ts
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Client } from '@elastic/elasticsearch';

@Injectable()
export class ElasticsearchService implements OnModuleInit {
  private readonly logger = new Logger(ElasticsearchService.name);
  private client: Client;
  private enabled: boolean;

  constructor(private configService: ConfigService) {
    this.enabled = this.configService.get<boolean>('ELASTICSEARCH_ENABLED', false);

    if (this.enabled) {
      this.client = new Client({
        node: this.configService.get<string>('ELASTICSEARCH_NODE', 'http://localhost:9200'),
      });
    }
  }

  async onModuleInit() {
    if (!this.enabled) {
      this.logger.warn('Elasticsearch is disabled');
      return;
    }

    try {
      await this.client.ping();
      this.logger.log('Elasticsearch connection established');
      await this.ensureProductIndex();
    } catch (error) {
      this.logger.error('Failed to connect to Elasticsearch', error.stack);
    }
  }

  private async ensureProductIndex() {
    const indexName = 'products';
    const exists = await this.client.indices.exists({ index: indexName });

    if (!exists) {
      await this.client.indices.create({
        index: indexName,
        body: {
          mappings: {
            properties: {
              id: { type: 'integer' },
              name: { type: 'text' },
              description: { type: 'text' },
              category: { type: 'keyword' },
              brand: { type: 'keyword' },
              price: { type: 'float' },
              status: { type: 'keyword' },
              created_at: { type: 'date' },
            },
          },
        },
      });
      this.logger.log('Created products index');
    }
  }

  async indexProduct(product: any) {
    if (!this.enabled) return;

    await this.client.index({
      index: 'products',
      id: product.id.toString(),
      document: {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    });
  }

  async updateProduct(id: number, product: any) {
    if (!this.enabled) return;

    await this.client.update({
      index: 'products',
      id: id.toString(),
      doc: product,
    });
  }

  async deleteProduct(id: number) {
    if (!this.enabled) return;

    await this.client.delete({
      index: 'products',
      id: id.toString(),
    });
  }

  async searchProducts(params: any) {
    if (!this.enabled) {
      return { data: [], total: 0, page: 1, size: 10 };
    }

    const { q, category, brand, minPrice, maxPrice, page = 1, size = 10 } = params;
    const from = (page - 1) * size;

    const must: any[] = [];
    const filter: any[] = [];

    // 키워드 검색 (name, description)
    if (q) {
      must.push({
        multi_match: {
          query: q,
          fields: ['name^2', 'description'],  // name에 가중치 2배
        },
      });
    }

    // 필터
    if (category) filter.push({ term: { category } });
    if (brand) filter.push({ term: { brand } });
    if (minPrice || maxPrice) {
      filter.push({
        range: {
          price: {
            ...(minPrice && { gte: minPrice }),
            ...(maxPrice && { lte: maxPrice }),
          },
        },
      });
    }

    const result = await this.client.search({
      index: 'products',
      body: {
        query: {
          bool: {
            must,
            filter,
          },
        },
        from,
        size,
      },
    });

    const hits = result.hits.hits;
    const total = typeof result.hits.total === 'number'
      ? result.hits.total
      : result.hits.total.value;

    return {
      data: hits.map(hit => hit._source),
      total,
      page,
      size,
    };
  }

  async reindexAllProducts(products: any[]) {
    if (!this.enabled) return;

    const operations = products.flatMap(product => [
      { index: { _index: 'products', _id: product.id.toString() } },
      {
        id: product.id,
        name: product.name,
        description: product.description,
        category: product.category,
        brand: product.brand,
        price: product.price,
        status: product.status,
        created_at: product.createdAt,
      },
    ]);

    if (operations.length > 0) {
      await this.client.bulk({ operations });
      this.logger.log(`Reindexed ${products.length} products`);
    }
  }
}
```

**설계 포인트:**
- `enabled` 플래그: ES 비활성화 시 gracefully 처리
- `ensureProductIndex`: 인덱스 자동 생성
- `multi_match`: 여러 필드 동시 검색
- `^2`: name 필드에 점수 가중치
- `bulk`: 대량 재색인 시 효율적

---

## 5. ProductService 통합

```typescript
// src/product/product.service.ts
@Injectable()
export class ProductService {
  constructor(
    private prisma: PrismaService,
    private elasticsearchService: ElasticsearchService,
  ) {}

  async create(createProductDto: CreateProductDto) {
    // 1. RDB에 저장
    const product = await this.prisma.product.create({
      data: createProductDto,
    });

    // 2. ES에 인덱싱
    await this.elasticsearchService.indexProduct(product);

    return product;
  }

  async update(id: number, updateProductDto: UpdateProductDto) {
    // 1. RDB 업데이트
    const product = await this.prisma.product.update({
      where: { id },
      data: updateProductDto,
    });

    // 2. ES 업데이트
    await this.elasticsearchService.updateProduct(id, updateProductDto);

    return product;
  }

  async delete(id: number) {
    // 1. RDB 삭제
    await this.prisma.product.delete({ where: { id } });

    // 2. ES 삭제
    await this.elasticsearchService.deleteProduct(id);
  }
}
```

---

## 6. SearchService

```typescript
// src/search/search.service.ts
@Injectable()
export class SearchService {
  constructor(private elasticsearchService: ElasticsearchService) {}

  async searchProducts(searchDto: SearchProductsDto): Promise<SearchResultDto> {
    const result = await this.elasticsearchService.searchProducts({
      q: searchDto.q,
      category: searchDto.category,
      brand: searchDto.brand,
      minPrice: searchDto.minPrice,
      maxPrice: searchDto.maxPrice,
      page: searchDto.page || 1,
      size: searchDto.size || 10,
    });

    return new SearchResultDto(
      result.data,
      result.total,
      result.page,
      result.size,
    );
  }
}
```

---

## 7. AdminService - 재색인

```typescript
// src/admin/admin.service.ts
@Injectable()
export class AdminService {
  constructor(
    private prisma: PrismaService,
    private elasticsearchService: ElasticsearchService,
  ) {}

  async reindexProducts() {
    // 1. RDB에서 모든 상품 조회
    const products = await this.prisma.product.findMany({
      where: { status: 'ACTIVE' },
    });

    // 2. ES 재색인
    await this.elasticsearchService.reindexAllProducts(products);

    return { reindexed: products.length };
  }
}
```

---

## 8. DTO 설계

### 8.1 요청 DTO

```typescript
// search-products.dto.ts
export class SearchProductsDto {
  @IsString()
  @IsOptional()
  q?: string;

  @IsString()
  @IsOptional()
  category?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsNumber()
  @IsOptional()
  @Min(0)
  minPrice?: number;

  @IsNumber()
  @IsOptional()
  @Min(0)
  maxPrice?: number;

  @IsInt()
  @IsOptional()
  @Min(1)
  page?: number = 1;

  @IsInt()
  @IsOptional()
  @Min(1)
  @Max(100)
  size?: number = 10;
}
```

### 8.2 응답 DTO

```typescript
// search-result.dto.ts
export class SearchResultDto<T> {
  items: T[];
  total: number;
  page: number;
  size: number;

  constructor(items: T[], total: number, page: number, size: number) {
    this.items = items;
    this.total = total;
    this.page = page;
    this.size = size;
  }
}
```

---

## 9. API 엔드포인트 명세

### 9.1 검색 API

**GET /api/search/products?q=노트북&category=electronics&minPrice=1000&maxPrice=5000&page=1&size=10**
- 인증: 선택
- 쿼리 파라미터:
  - `q`: 검색 키워드
  - `category`: 카테고리 필터
  - `brand`: 브랜드 필터
  - `minPrice`: 최소 가격
  - `maxPrice`: 최대 가격
  - `page`: 페이지 (기본: 1)
  - `size`: 페이지 크기 (기본: 10)
- 응답:
  ```json
  {
    "items": [
      {
        "id": 1,
        "name": "고성능 노트북",
        "description": "최신 노트북",
        "category": "electronics",
        "brand": "Samsung",
        "price": 1500000,
        "status": "ACTIVE"
      }
    ],
    "total": 45,
    "page": 1,
    "size": 10
  }
  ```

### 9.2 관리 API

**POST /api/admin/reindex/products**
- 인증: 필수 (관리자만)
- 응답:
  ```json
  {
    "reindexed": 1000
  }
  ```

---

## 10. 테스트 전략

### 10.1 통합 테스트 (이상적)

```typescript
describe('Product Search (e2e)', () => {
  beforeAll(async () => {
    // Docker Compose로 ES 띄우기
    // 또는 Testcontainers
  });

  it('should search products by keyword', async () => {
    // 1. 상품 생성
    await request(app.getHttpServer())
      .post('/api/products')
      .send({ name: '노트북', category: 'electronics', ... });

    // 2. ES 인덱싱 대기 (refresh interval)
    await sleep(1000);

    // 3. 검색
    const res = await request(app.getHttpServer())
      .get('/api/search/products?q=노트북')
      .expect(200);

    expect(res.body.items.length).toBeGreaterThan(0);
    expect(res.body.items[0].name).toContain('노트북');
  });
});
```

### 10.2 현실 타협 (ES Mock)

```typescript
it('should call ElasticsearchService correctly', async () => {
  const mockResult = {
    data: [{ id: 1, name: 'Test' }],
    total: 1,
    page: 1,
    size: 10,
  };

  jest.spyOn(elasticsearchService, 'searchProducts').mockResolvedValue(mockResult);

  const result = await searchService.searchProducts({ q: 'test' });

  expect(result.items.length).toBe(1);
});
```

---

## 11. 환경 설정

```env
# .env
ELASTICSEARCH_NODE=http://localhost:9200
ELASTICSEARCH_ENABLED=true

# .env.test
ELASTICSEARCH_ENABLED=false  # 테스트 시 비활성화
```

### Docker Compose (로컬 개발)

```yaml
# docker-compose.yml
version: '3.8'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
```

---

## 12. 검증 체크리스트

### 12.1 기능 검증

- [ ] 상품 생성 시 ES에 자동 인덱싱
- [ ] 상품 수정 시 ES 업데이트
- [ ] 상품 삭제 시 ES 삭제
- [ ] 키워드 검색 동작 (name, description)
- [ ] 카테고리/브랜드 필터 동작
- [ ] 가격 범위 검색 동작
- [ ] 페이지네이션 동작
- [ ] 재색인 API 동작

### 12.2 성능 검증

- [ ] 1000개 상품 검색 < 100ms
- [ ] 관련도 순 정렬 (높은 점수 우선)

### 12.3 장애 대응

- [ ] ES 연결 실패 시 앱 시작 가능 (ELASTICSEARCH_ENABLED=false)
- [ ] ES 비활성화 시 검색 API 빈 배열 반환

---

## 13. 완료 기준

✅ Product 모델 Prisma 스키마 작성
✅ ElasticsearchService 구현
✅ ProductService에 ES 통합
✅ SearchService 구현
✅ 검색 API 구현
✅ 재색인 API 구현
✅ 통합 테스트 작성 (또는 Mock 테스트)
✅ CI 테스트 통과

---

## 14. 다음 마일스톤과의 연결

### N2.4에서 확립된 것

- Elasticsearch 통합
- 전문 검색 API
- RDB ↔ ES 동기화
- 인덱스 매핑 설계

### N2.5에서 추가될 것

- Kafka 이벤트 기반 아키텍처
- Producer/Consumer 패턴
- 비동기 이벤트 처리
- 이벤트 기반 동기화 (대안)

---

## 15. 참고 자료

- [Elasticsearch Official Docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
- [@elastic/elasticsearch](https://www.npmjs.com/package/@elastic/elasticsearch)
- [Elasticsearch Mapping](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html)
- [Testcontainers for Elasticsearch](https://testcontainers.com/guides/testing-spring-boot-rest-api-using-testcontainers/)
