# 팀 & 역할 기반 접근 제어(RBAC) 설계 일지 (N2.2)
> 팀 도메인 설계를 통한 역할 기반 권한 관리 및 403/404 상태 코드 구분 학습

## 1. 문제 정의 & 요구사항

### 1.1 목표

**팀 도메인**과 **역할 기반 접근 제어(RBAC)** 패턴 구현:
- Team, TeamMember, WorkspaceItem 도메인 모델링
- 역할별 권한 관리 (OWNER, MANAGER, MEMBER)
- 서비스 레이어에서 권한 검증
- 401(미인증), 403(권한 없음), 404(리소스 없음) 상태 코드 구분

### 1.2 기능 요구사항

#### 1.2.1 팀 도메인 모델

**엔티티:**
- `Team`: 팀
- `TeamMember`: 팀 멤버 (User와 Team의 중간 테이블)
- `WorkspaceItem`: 팀 작업 공간 아이템

**역할 (TeamRole enum):**
- `OWNER`: 팀 소유자 (모든 권한)
- `MANAGER`: 관리자 (멤버 관리 가능)
- `MEMBER`: 일반 멤버 (읽기만 가능)

**권한 매트릭스:**

| 기능 | OWNER | MANAGER | MEMBER |
|------|-------|---------|--------|
| 팀 정보 조회 | ✅ | ✅ | ✅ |
| 멤버 목록 조회 | ✅ | ✅ | ✅ |
| 워크스페이스 아이템 조회 | ✅ | ✅ | ✅ |
| 멤버 추가 | ✅ | ✅ | ❌ |
| 멤버 역할 변경 | ✅ | ✅ | ❌ |
| 멤버 제거 | ✅ | ✅ | ❌ |
| OWNER 역할 변경 | ✅ | ❌ | ❌ |
| 마지막 OWNER 변경/삭제 | ❌ | ❌ | ❌ |

#### 1.2.2 API 엔드포인트

**팀 관리:**
- `POST /api/teams` - 팀 생성 (생성자가 OWNER로 자동 할당)
- `GET /api/teams` - 내가 속한 팀 목록
- `GET /api/teams/:id` - 팀 상세 정보

**멤버 관리:**
- `POST /api/teams/:id/members` - 멤버 추가 (OWNER, MANAGER만)
- `GET /api/teams/:id/members` - 멤버 목록 조회
- `PATCH /api/teams/:id/members/:memberId` - 멤버 역할 변경 (OWNER, MANAGER만)
- `DELETE /api/teams/:id/members/:memberId` - 멤버 제거 (OWNER, MANAGER만)

**워크스페이스 아이템:**
- `POST /api/teams/:teamId/items` - 아이템 생성 (팀 멤버만)
- `GET /api/teams/:teamId/items` - 아이템 목록 조회 (팀 멤버만)

### 1.3 비기능 요구사항

#### 1.3.1 보안
- 팀 멤버만 팀 리소스 접근 가능
- 역할별 권한 검증
- 민감 정보 노출 방지 (다른 팀 존재 여부 숨김)

#### 1.3.2 데이터 일관성
- 팀 생성 시 OWNER 자동 할당 (트랜잭션)
- 마지막 OWNER의 역할 변경/삭제 방지
- 멤버 중복 방지 (unique constraint)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 RBAC인가?

**단순 인증(Authentication)만의 문제:**
- "로그인했다" != "이 작업을 할 수 있다"
- 모든 사용자가 모든 데이터에 접근 가능
- 비즈니스 규칙 표현 불가

**RBAC (Role-Based Access Control):**
```text
User → Role → Permission
```

**예시:**
```typescript
// ❌ 나쁜 예 (인증만)
async deleteTeam(teamId: number) {
  return this.prisma.team.delete({ where: { id: teamId } });
}

// ✅ 좋은 예 (인증 + 인가)
async deleteTeam(teamId: number, userId: number) {
  const member = await this.getTeamMember(teamId, userId);
  if (member.role !== TeamRole.OWNER) {
    throw new ForbiddenException('Only OWNER can delete team');
  }
  return this.prisma.team.delete({ where: { id: teamId } });
}
```

### 2.2 401 vs 403 vs 404 구분

**상태 코드 선택 기준:**

| 코드 | 의미 | 사용 시나리오 | 보안 고려사항 |
|------|------|--------------|--------------|
| 401 Unauthorized | 인증 필요 | JWT 토큰 없음/만료 | 로그인 유도 |
| 403 Forbidden | 권한 없음 | 팀 멤버가 아님, 역할 부족 | 리소스 존재 암시 |
| 404 Not Found | 리소스 없음 | 실제로 없음 OR 권한 없음 | 존재 여부 숨김 |

**설계 결정:**
```typescript
// 패턴 1: 403 명시 (투명한 에러)
async getTeamById(teamId: number, userId: number) {
  const team = await this.prisma.team.findUnique({ where: { id: teamId } });
  if (!team) throw new NotFoundException('Team not found');

  const isMember = team.members.some(m => m.userId === userId);
  if (!isMember) throw new ForbiddenException('You are not a member of this team');

  return team;
}

// 패턴 2: 404 반환 (보안 강화, 팀 존재 여부 숨김)
async getTeamById(teamId: number, userId: number) {
  const team = await this.prisma.team.findFirst({
    where: {
      id: teamId,
      members: { some: { userId } }  // 멤버인 팀만 조회
    }
  });
  if (!team) throw new NotFoundException('Team not found');
  return team;
}
```

**이 프로젝트 선택: 패턴 1 (403 명시)**
- 학습 목적: 에러 메시지가 명확해야 디버깅 용이
- 내부 도구: 팀 존재 여부 숨길 필요 낮음

---

## 3. 데이터베이스 스키마 설계

### 3.1 Prisma 스키마 (N2.2 도메인)

```prisma
// Team 모델
model Team {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())

  // Relations
  members        TeamMember[]
  workspaceItems WorkspaceItem[]
}

// TeamMember 모델 (중간 테이블)
// Valid role values: OWNER, MANAGER, MEMBER
model TeamMember {
  id       Int      @id @default(autoincrement())
  teamId   Int
  userId   Int
  role     String   // OWNER, MANAGER, MEMBER
  joinedAt DateTime @default(now())

  // Relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])  // 한 사용자는 한 팀에 한 번만 참여
  @@index([teamId])
  @@index([userId])
}

// WorkspaceItem 모델
model WorkspaceItem {
  id        Int      @id @default(autoincrement())
  teamId    Int
  title     String
  content   String?
  createdBy Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  team    Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  creator User @relation("CreatedWorkspaceItems", fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([teamId])
  @@index([createdBy])
}
```

### 3.2 스키마 설계 결정

**unique constraint `[teamId, userId]`:**
- 같은 팀에 중복 가입 방지
- DB 레벨 제약으로 race condition 방지

**onDelete: Cascade:**
- 팀 삭제 시 멤버/아이템도 자동 삭제
- User 삭제 시 멤버십도 삭제

**role을 String으로:**
- SQLite가 enum 미지원
- 주석으로 valid values 명시
- TypeScript enum으로 타입 안전성 보완

---

## 4. 역할 Enum 정의

```typescript
// src/common/enums/team-role.enum.ts
export enum TeamRole {
  OWNER = 'OWNER',
  MANAGER = 'MANAGER',
  MEMBER = 'MEMBER',
}

// 역할 비교 헬퍼
export function canManageMembers(role: TeamRole): boolean {
  return role === TeamRole.OWNER || role === TeamRole.MANAGER;
}

export function isOwner(role: TeamRole): boolean {
  return role === TeamRole.OWNER;
}
```

---

## 5. TeamService 구현 패턴

### 5.1 팀 생성 (트랜잭션 패턴)

```typescript
async createTeam(userId: number, createTeamDto: CreateTeamDto) {
  return this.prisma.$transaction(async (tx) => {
    // 1. 팀 생성
    const team = await tx.team.create({
      data: { name: createTeamDto.name },
    });

    // 2. 생성자를 OWNER로 추가
    await tx.teamMember.create({
      data: {
        teamId: team.id,
        userId: userId,
        role: TeamRole.OWNER,
      },
    });

    return team;
  });
}
```

**설계 포인트:**
- 팀과 멤버 생성을 원자적으로 처리
- 실패 시 둘 다 롤백
- OWNER 없는 팀이 생성되는 것 방지

### 5.2 권한 검증 패턴

```typescript
// 헬퍼 메서드: 팀 멤버 검증
private async verifyTeamMember(teamId: number, userId: number) {
  const member = await this.prisma.teamMember.findFirst({
    where: { teamId, userId },
  });

  if (!member) {
    throw new ForbiddenException('You are not a member of this team');
  }

  return member;
}

// 헬퍼 메서드: 관리 권한 검증
private async verifyManagementPermission(teamId: number, userId: number) {
  const member = await this.verifyTeamMember(teamId, userId);

  if (!canManageMembers(member.role as TeamRole)) {
    throw new ForbiddenException('Only OWNER or MANAGER can manage members');
  }

  return member;
}

// 사용 예시
async addMember(teamId: number, userId: number, addMemberDto: AddMemberDto) {
  // 권한 검증 (Controller에서 userId 전달)
  await this.verifyManagementPermission(teamId, userId);

  // 멤버 추가 로직
  return this.prisma.teamMember.create({ ... });
}
```

### 5.3 비즈니스 규칙 검증

**규칙 1: 마지막 OWNER 보호**
```typescript
async updateMemberRole(teamId: number, memberId: number, updateRoleDto: UpdateMemberRoleDto) {
  const member = await this.prisma.teamMember.findUnique({
    where: { id: memberId },
  });

  if (!member || member.teamId !== teamId) {
    throw new NotFoundException('Team member not found');
  }

  // 마지막 OWNER의 역할 변경 방지
  if (member.role === TeamRole.OWNER && updateRoleDto.role !== TeamRole.OWNER) {
    const ownerCount = await this.prisma.teamMember.count({
      where: { teamId, role: TeamRole.OWNER },
    });

    if (ownerCount <= 1) {
      throw new BadRequestException('Cannot change the role of the last owner');
    }
  }

  return this.prisma.teamMember.update({
    where: { id: memberId },
    data: { role: updateRoleDto.role },
  });
}
```

**규칙 2: 멤버 중복 방지**
```typescript
async addMember(teamId: number, addMemberDto: AddMemberDto) {
  // 중복 체크
  const existingMember = await this.prisma.teamMember.findFirst({
    where: {
      teamId,
      userId: addMemberDto.userId,
    },
  });

  if (existingMember) {
    throw new BadRequestException('User is already a member of this team');
  }

  // 멤버 추가
  return this.prisma.teamMember.create({ ... });
}
```

---

## 6. Controller 구현

### 6.1 팀 Controller

```typescript
@Controller('teams')
@UseGuards(JwtAuthGuard)
export class TeamController {
  constructor(private teamService: TeamService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  async createTeam(
    @CurrentUser() user: UserPayload,
    @Body() createTeamDto: CreateTeamDto,
  ): Promise<TeamResponseDto> {
    const team = await this.teamService.createTeam(user.id, createTeamDto);
    return new TeamResponseDto(team);
  }

  @Get()
  async getMyTeams(@CurrentUser() user: UserPayload): Promise<TeamResponseDto[]> {
    const teams = await this.teamService.getMyTeams(user.id);
    return teams.map(team => new TeamResponseDto(team));
  }

  @Get(':id')
  async getTeamById(
    @Param('id', ParseIntPipe) id: number,
    @CurrentUser() user: UserPayload,
  ): Promise<TeamDetailResponseDto> {
    const team = await this.teamService.getTeamById(id, user.id);
    return new TeamDetailResponseDto(team);
  }

  // 멤버 관리 엔드포인트
  @Post(':id/members')
  @HttpCode(HttpStatus.CREATED)
  async addMember(
    @Param('id', ParseIntPipe) teamId: number,
    @CurrentUser() user: UserPayload,
    @Body() addMemberDto: AddMemberDto,
  ) {
    // 권한 검증은 서비스 레이어에서
    return this.teamService.addMember(teamId, user.id, addMemberDto);
  }

  @Patch(':id/members/:memberId')
  async updateMemberRole(
    @Param('id', ParseIntPipe) teamId: number,
    @Param('memberId', ParseIntPipe) memberId: number,
    @CurrentUser() user: UserPayload,
    @Body() updateRoleDto: UpdateMemberRoleDto,
  ) {
    await this.teamService.verifyManagementPermission(teamId, user.id);
    return this.teamService.updateMemberRole(teamId, memberId, updateRoleDto);
  }

  @Delete(':id/members/:memberId')
  @HttpCode(HttpStatus.NO_CONTENT)
  async removeMember(
    @Param('id', ParseIntPipe) teamId: number,
    @Param('memberId', ParseIntPipe) memberId: number,
    @CurrentUser() user: UserPayload,
  ) {
    await this.teamService.verifyManagementPermission(teamId, user.id);
    await this.teamService.removeMember(teamId, memberId);
  }
}
```

---

## 7. DTO 설계

### 7.1 요청 DTO

```typescript
// create-team.dto.ts
export class CreateTeamDto {
  @IsString()
  @Length(1, 100)
  name: string;
}

// add-member.dto.ts
export class AddMemberDto {
  @IsInt()
  userId: number;

  @IsEnum(TeamRole)
  role: TeamRole;
}

// update-member-role.dto.ts
export class UpdateMemberRoleDto {
  @IsEnum(TeamRole)
  role: TeamRole;
}

// create-workspace-item.dto.ts
export class CreateWorkspaceItemDto {
  @IsString()
  @Length(1, 200)
  title: string;

  @IsString()
  @IsOptional()
  content?: string;
}
```

### 7.2 응답 DTO

```typescript
// team-response.dto.ts
export class TeamResponseDto {
  id: number;
  name: string;
  createdAt: string;

  constructor(team: any) {
    this.id = team.id;
    this.name = team.name;
    this.createdAt = team.createdAt.toISOString();
  }
}

// team-detail-response.dto.ts
export class TeamDetailResponseDto extends TeamResponseDto {
  members: TeamMemberResponseDto[];

  constructor(team: any) {
    super(team);
    this.members = team.members.map(m => new TeamMemberResponseDto(m));
  }
}

// team-member-response.dto.ts
export class TeamMemberResponseDto {
  id: number;
  role: string;
  user: UserResponseDto;
  joinedAt: string;

  constructor(member: any) {
    this.id = member.id;
    this.role = member.role;
    this.user = new UserResponseDto(member.user);
    this.joinedAt = member.joinedAt.toISOString();
  }
}
```

---

## 8. 테스트 전략

### 8.1 권한 테스트 시나리오

```typescript
describe('Team RBAC (e2e)', () => {
  let ownerToken: string;
  let managerToken: string;
  let memberToken: string;
  let outsiderToken: string;
  let teamId: number;

  beforeAll(async () => {
    // 사용자 생성 및 로그인
    ownerToken = await createUserAndLogin('owner@example.com');
    managerToken = await createUserAndLogin('manager@example.com');
    memberToken = await createUserAndLogin('member@example.com');
    outsiderToken = await createUserAndLogin('outsider@example.com');

    // 팀 생성 (owner)
    const teamRes = await request(app.getHttpServer())
      .post('/api/teams')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ name: 'Test Team' });
    teamId = teamRes.body.id;

    // 멤버 추가
    await request(app.getHttpServer())
      .post(`/api/teams/${teamId}/members`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ userId: managerId, role: 'MANAGER' });

    await request(app.getHttpServer())
      .post(`/api/teams/${teamId}/members`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ userId: memberId, role: 'MEMBER' });
  });

  it('OWNER should be able to add members', async () => {
    await request(app.getHttpServer())
      .post(`/api/teams/${teamId}/members`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ userId: newUserId, role: 'MEMBER' })
      .expect(201);
  });

  it('MANAGER should be able to add members', async () => {
    await request(app.getHttpServer())
      .post(`/api/teams/${teamId}/members`)
      .set('Authorization', `Bearer ${managerToken}`)
      .send({ userId: newUserId, role: 'MEMBER' })
      .expect(201);
  });

  it('MEMBER should NOT be able to add members (403)', async () => {
    await request(app.getHttpServer())
      .post(`/api/teams/${teamId}/members`)
      .set('Authorization', `Bearer ${memberToken}`)
      .send({ userId: newUserId, role: 'MEMBER' })
      .expect(403);
  });

  it('Outsider should NOT be able to view team (403)', async () => {
    await request(app.getHttpServer())
      .get(`/api/teams/${teamId}`)
      .set('Authorization', `Bearer ${outsiderToken}`)
      .expect(403);
  });

  it('Should NOT change last OWNER role (400)', async () => {
    await request(app.getHttpServer())
      .patch(`/api/teams/${teamId}/members/${ownerId}`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ role: 'MANAGER' })
      .expect(400)
      .expect((res) => {
        expect(res.body.message).toContain('last owner');
      });
  });
});
```

---

## 9. API 엔드포인트 명세

### 9.1 팀 관리

**POST /api/teams**
- 인증: 필수
- 요청: `{ name }`
- 응답: `{ id, name, createdAt }`
- 상태: 201 Created

**GET /api/teams**
- 인증: 필수
- 응답: `[{ id, name, createdAt }]`
- 설명: 현재 사용자가 속한 팀 목록

**GET /api/teams/:id**
- 인증: 필수
- 응답: `{ id, name, members: [...], createdAt }`
- 상태: 200 OK, 403 Forbidden (멤버 아님), 404 Not Found

### 9.2 멤버 관리

**POST /api/teams/:id/members**
- 인증: 필수, 권한: OWNER/MANAGER
- 요청: `{ userId, role }`
- 응답: `{ id, role, user: {...}, joinedAt }`
- 상태: 201 Created, 403 Forbidden, 400 Bad Request (중복)

**PATCH /api/teams/:id/members/:memberId**
- 인증: 필수, 권한: OWNER/MANAGER
- 요청: `{ role }`
- 응답: `{ id, role, user: {...}, joinedAt }`
- 상태: 200 OK, 403 Forbidden, 400 Bad Request (마지막 OWNER)

**DELETE /api/teams/:id/members/:memberId**
- 인증: 필수, 권한: OWNER/MANAGER
- 상태: 204 No Content, 403 Forbidden, 400 Bad Request (마지막 OWNER)

---

## 10. 검증 체크리스트

### 10.1 기능 검증

- [ ] 팀 생성 시 생성자가 OWNER로 자동 할당
- [ ] OWNER/MANAGER가 멤버 추가 가능
- [ ] MEMBER가 멤버 추가 시 403
- [ ] 멤버가 아닌 사용자가 팀 조회 시 403
- [ ] 중복 멤버 추가 시 400
- [ ] 마지막 OWNER 역할 변경 시 400
- [ ] 마지막 OWNER 삭제 시 400

### 10.2 상태 코드 검증

- [ ] 토큰 없이 요청 → 401
- [ ] 멤버 아닌 사용자가 팀 접근 → 403
- [ ] 존재하지 않는 팀 조회 → 404
- [ ] MEMBER가 관리 작업 → 403

---

## 11. 완료 기준

✅ Team, TeamMember, WorkspaceItem 모델 Prisma 스키마 작성
✅ TeamRole enum 정의
✅ TeamService 구현 (권한 검증 포함)
✅ TeamController 구현
✅ 트랜잭션으로 팀 생성 + OWNER 할당
✅ 권한별 e2e 테스트 작성
✅ 401/403/404 상태 코드 구분 테스트
✅ CI 테스트 통과

---

## 12. 다음 마일스톤과의 연결

### N2.2에서 확립된 것

- RBAC 패턴
- 서비스 레이어 권한 검증
- 트랜잭션 활용 (팀 생성)
- 비즈니스 규칙 검증 (마지막 OWNER 보호)
- 상태 코드 구분 (401/403/404)

### N2.3에서 추가될 것

- 배치 작업 스케줄러 (@nestjs/schedule)
- 통계 테이블 및 집계
- 캐싱 (인기 이슈)
- 외부 API 호출 (재시도 로직)

---

## 13. 참고 자료

- [NestJS Guards](https://docs.nestjs.com/guards)
- [Prisma Transactions](https://www.prisma.io/docs/concepts/components/prisma-client/transactions)
- [RBAC Design Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)
