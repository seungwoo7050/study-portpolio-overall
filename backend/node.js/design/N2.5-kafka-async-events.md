# Kafka 비동기 이벤트 처리 설계 일지 (N2.5)
> Order 도메인 이벤트 기반 아키텍처를 통한 Kafka Producer/Consumer 패턴 학습

## 1. 문제 정의 & 요구사항

### 1.1 목표

**이벤트 기반 비동기 처리** 패턴 구현:
- Order, OrderItem, Notification 도메인
- Kafka Producer로 주문 이벤트 발행
- Kafka Consumer로 알림 생성
- 동기 vs 비동기 처리 이해

### 1.2 기능 요구사항

#### 1.2.1 Order 도메인

**엔티티:**
- `Order`: 주문
  - `id`: 고유 ID
  - `userId`: 주문자 ID
  - `totalAmount`: 총 금액
  - `status`: 상태 (PENDING, PAID, CANCELLED)
- `OrderItem`: 주문 항목
  - `orderId`: 주문 ID
  - `productId`: 상품 ID
  - `quantity`: 수량
  - `price`: 단가 (주문 시점 가격)
- `Notification`: 알림
  - `userId`: 사용자 ID
  - `type`: 알림 타입
  - `message`: 알림 메시지

#### 1.2.2 Kafka 이벤트

**토픽:** `order-events`

**이벤트 스키마:**
```json
{
  "eventId": "uuid",
  "eventType": "ORDER_CREATED" | "ORDER_PAID" | "ORDER_CANCELLED",
  "timestamp": "2025-01-30T10:15:30.123Z",
  "orderId": 123,
  "userId": 45,
  "totalAmount": 50000
}
```

#### 1.2.3 API 엔드포인트

**주문 API:**
- `POST /api/orders` - 주문 생성 (Producer)
- `GET /api/orders` - 내 주문 목록
- `GET /api/orders/:id` - 주문 상세
- `PATCH /api/orders/:id/pay` - 결제 완료 (Producer)
- `PATCH /api/orders/:id/cancel` - 주문 취소 (Producer)

**알림 API:**
- `GET /api/notifications` - 내 알림 목록

#### 1.2.4 비동기 플로우

```text
[사용자 요청]
     ↓
POST /api/orders
     ↓
[OrderService]
  1. DB 트랜잭션 (Order + OrderItem 생성)
  2. Kafka Producer: ORDER_CREATED 이벤트 발행
     ↓
[201 Created 응답 즉시 반환]
     ↓
[Kafka Broker]
     ↓
[NotificationConsumer]
  3. ORDER_CREATED 이벤트 수신
  4. Notification DB 저장
     ↓
[완료] (사용자는 이미 응답 받음)
```

**핵심:** 주문 생성 API는 DB 저장 후 즉시 응답, 알림 생성은 백그라운드에서 비동기 처리

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 주문 API 응답 시간 < 200ms (Kafka 발행 대기 안 함)
- Consumer 처리 지연 < 1초 (이벤트 수신 ~ DB 저장)

#### 1.3.2 안정성
- Producer 실패 시에도 주문은 성공 (이벤트 발행은 best-effort)
- Consumer 실패 시 재처리 (Kafka offset commit 전략)
- Consumer 중단 시 Kafka에 이벤트 보관 → 재시작 후 처리

#### 1.3.3 확장성
- Kafka 비활성화 가능 (KAFKA_ENABLED=false)
- 여러 Consumer 인스턴스로 부하 분산 (Consumer Group)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 동기 vs 비동기 처리

**동기 처리 (Before):**
```typescript
// ❌ 느리고 결합도 높음
async createOrder(userId, createOrderDto) {
  const order = await this.prisma.order.create({ ... });

  // 알림 생성 (동기)
  await this.notificationService.createNotification({
    userId,
    type: 'ORDER_CREATED',
    message: `Order ${order.id} created`,
  });

  // 이메일 발송 (동기)
  await this.emailService.sendOrderConfirmation(order);

  // 재고 차감 (동기)
  await this.inventoryService.decreaseStock(order.items);

  return order;  // 모든 작업 완료 후 응답 (느림!)
}
```

**문제점:**
- 응답 시간 증가 (모든 작업 대기)
- 하나의 서비스 실패 시 전체 실패
- 결합도 증가 (Order 서비스가 Email, Inventory 의존)

**비동기 처리 (After):**
```typescript
// ✅ 빠르고 결합도 낮음
async createOrder(userId, createOrderDto) {
  const order = await this.prisma.order.create({ ... });

  // 이벤트 발행 (fire-and-forget)
  await this.kafkaProducer.publishOrderEvent({
    eventType: 'ORDER_CREATED',
    orderId: order.id,
    userId,
    totalAmount: order.totalAmount,
  });

  return order;  // DB 저장 + 이벤트 발행만 하고 즉시 응답
}
```

**장점:**
- 빠른 응답 (알림/이메일 대기 안 함)
- 느슨한 결합 (Order 서비스는 이벤트만 발행)
- 확장성 (Consumer 추가로 기능 확장)

### 2.2 왜 Kafka인가?

**대안들:**
- **RabbitMQ**: 메시지 큐, 복잡한 라우팅
- **Redis Pub/Sub**: 간단, 영속성 없음
- **AWS SQS**: 클라우드 전용
- **Kafka**:
  - **영속성**: 이벤트를 디스크에 저장 (replay 가능)
  - **확장성**: 파티션으로 수평 확장
  - **Consumer Group**: 여러 Consumer가 협력
  - **이벤트 소싱**: 이벤트 로그 활용 가능

### 2.3 At-Least-Once vs At-Most-Once

**At-Most-Once (최대 한 번):**
- Kafka 메시지 읽자마자 offset commit
- 처리 중 실패 시 → 메시지 소실
- 빠르지만 데이터 손실 위험

**At-Least-Once (최소 한 번, 이 프로젝트 선택):**
- 메시지 처리 성공 후 offset commit
- 처리 중 실패 시 → 재처리 (중복 가능)
- 멱등성 보장 필요 (같은 이벤트 2번 처리해도 결과 동일)

**멱등성 예시:**
```typescript
// ✅ 멱등성 보장
async handleOrderCreated(event) {
  // 이미 알림 존재하면 스킵
  const existing = await this.prisma.notification.findFirst({
    where: {
      userId: event.userId,
      type: 'ORDER_CREATED',
      // 이벤트 ID로 중복 체크 가능
    },
  });

  if (existing) {
    this.logger.log('Notification already exists, skipping');
    return;
  }

  await this.prisma.notification.create({ ... });
}
```

---

## 3. 데이터베이스 스키마 설계

### 3.1 Prisma 스키마 (N2.5 도메인)

```prisma
// Order 모델
// Valid status values: PENDING, PAID, CANCELLED
model Order {
  id          Int      @id @default(autoincrement())
  userId      Int
  totalAmount Float
  status      String   @default("PENDING")  // PENDING, PAID, CANCELLED
  createdAt   DateTime @default(now())

  // Relations
  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items OrderItem[]

  @@index([userId])
  @@index([status])
}

// OrderItem 모델
model OrderItem {
  id        Int   @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int
  price     Float  // 주문 시점 가격 (스냅샷)

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([productId])
}

// Notification 모델
// Valid notification types: ORDER_CREATED, ORDER_PAID, ORDER_CANCELLED
model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String
  message   String
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
}
```

**설계 포인트:**
- `OrderItem.price`: 주문 시점 가격 저장 (Product 가격 변경되어도 주문 금액 유지)
- `Notification.type`: 이벤트 타입과 매핑

---

## 4. Kafka 통합

### 4.1 KafkaProducerService

```typescript
// src/kafka/kafka.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Kafka, Producer } from 'kafkajs';

@Injectable()
export class KafkaProducerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(KafkaProducerService.name);
  private kafka: Kafka;
  private producer: Producer;
  private enabled: boolean;

  constructor(private configService: ConfigService) {
    this.enabled = this.configService.get<boolean>('KAFKA_ENABLED', false);

    if (this.enabled) {
      this.kafka = new Kafka({
        clientId: this.configService.get<string>('KAFKA_CLIENT_ID', 'web-phase1-5-node'),
        brokers: this.configService.get<string>('KAFKA_BROKERS', 'localhost:9092').split(','),
      });

      this.producer = this.kafka.producer();
    }
  }

  async onModuleInit() {
    if (!this.enabled) {
      this.logger.warn('Kafka is disabled');
      return;
    }

    try {
      await this.producer.connect();
      this.logger.log('Kafka producer connected');
    } catch (error) {
      this.logger.error('Failed to connect Kafka producer', error.stack);
    }
  }

  async onModuleDestroy() {
    if (this.enabled && this.producer) {
      await this.producer.disconnect();
      this.logger.log('Kafka producer disconnected');
    }
  }

  async publishOrderEvent(event: OrderEvent) {
    if (!this.enabled) return;

    try {
      await this.producer.send({
        topic: 'order-events',
        messages: [
          {
            key: event.orderId.toString(),  // 파티션 키
            value: JSON.stringify(event),
          },
        ],
      });

      this.logger.log(`Published ${event.eventType} for order ${event.orderId}`);
    } catch (error) {
      this.logger.error('Failed to publish order event', error);
      throw error;
    }
  }
}
```

**설계 포인트:**
- `enabled` 플래그: Kafka 비활성화 시 gracefully 처리
- `key`: 파티션 키 (같은 orderId 이벤트는 같은 파티션 → 순서 보장)
- `onModuleInit/Destroy`: 애플리케이션 라이프사이클과 통합

### 4.2 NotificationConsumer

```typescript
// src/notification/notification.consumer.ts
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Kafka, Consumer } from 'kafkajs';
import { NotificationService } from './notification.service';
import { OrderEventType } from '../kafka/kafka.types';

@Injectable()
export class NotificationConsumer implements OnModuleInit {
  private readonly logger = new Logger(NotificationConsumer.name);
  private kafka: Kafka;
  private consumer: Consumer;
  private enabled: boolean;

  constructor(
    private configService: ConfigService,
    private notificationService: NotificationService,
  ) {
    this.enabled = this.configService.get<boolean>('KAFKA_ENABLED', false);

    if (this.enabled) {
      this.kafka = new Kafka({
        clientId: this.configService.get<string>('KAFKA_CLIENT_ID'),
        brokers: this.configService.get<string>('KAFKA_BROKERS').split(','),
      });

      this.consumer = this.kafka.consumer({
        groupId: this.configService.get<string>('KAFKA_GROUP_ID', 'notification-consumer-group'),
      });
    }
  }

  async onModuleInit() {
    if (!this.enabled) {
      this.logger.warn('Kafka consumer is disabled');
      return;
    }

    try {
      await this.consumer.connect();
      await this.consumer.subscribe({ topic: 'order-events', fromBeginning: false });

      this.logger.log('Kafka consumer connected and subscribed to order-events');

      // 메시지 처리 루프
      await this.consumer.run({
        eachMessage: async ({ topic, partition, message }) => {
          const eventJson = message.value?.toString();
          if (!eventJson) return;

          try {
            const event = JSON.parse(eventJson);
            this.logger.log(`Received ${event.eventType} for order ${event.orderId}`);

            await this.handleOrderEvent(event);
          } catch (error) {
            this.logger.error('Failed to process message', error);
            // At-Least-Once: 에러 던지면 offset commit 안 됨 → 재처리
            throw error;
          }
        },
      });
    } catch (error) {
      this.logger.error('Failed to start Kafka consumer', error.stack);
    }
  }

  private async handleOrderEvent(event: any) {
    const { eventType, userId, orderId, totalAmount } = event;

    let message = '';
    switch (eventType) {
      case OrderEventType.ORDER_CREATED:
        message = `Your order #${orderId} has been created. Total: $${totalAmount}`;
        break;
      case OrderEventType.ORDER_PAID:
        message = `Your order #${orderId} has been paid. Total: $${totalAmount}`;
        break;
      case OrderEventType.ORDER_CANCELLED:
        message = `Your order #${orderId} has been cancelled.`;
        break;
      default:
        this.logger.warn(`Unknown event type: ${eventType}`);
        return;
    }

    await this.notificationService.create({
      userId,
      type: eventType,
      message,
    });

    this.logger.log(`Notification created for user ${userId}`);
  }
}
```

**설계 포인트:**
- `groupId`: Consumer Group (여러 인스턴스가 협력)
- `fromBeginning: false`: 최신 이벤트부터 처리 (재시작 시 중복 처리 방지)
- `eachMessage`: 메시지 하나씩 처리
- 예외 발생 시 `throw` → offset commit 안 됨 → 재처리

---

## 5. OrderService 통합

```typescript
// src/order/order.service.ts
@Injectable()
export class OrderService {
  private readonly logger = new Logger(OrderService.name);

  constructor(
    private prisma: PrismaService,
    private kafkaProducer: KafkaProducerService,
  ) {}

  async createOrder(userId: number, createOrderDto: CreateOrderDto) {
    // 1. 상품 검증 및 가격 조회
    const products = await this.prisma.product.findMany({
      where: { id: { in: createOrderDto.items.map(i => i.productId) }, status: 'ACTIVE' },
    });

    if (products.length !== createOrderDto.items.length) {
      throw new NotFoundException('One or more products not found or inactive');
    }

    const productPriceMap = new Map(products.map(p => [p.id, p.price]));

    // 2. 총 금액 계산
    let totalAmount = 0;
    const orderItems = createOrderDto.items.map(item => {
      const price = productPriceMap.get(item.productId)!;
      totalAmount += price * item.quantity;
      return { productId: item.productId, quantity: item.quantity, price };
    });

    // 3. 트랜잭션: Order + OrderItem 생성
    const order = await this.prisma.$transaction(async (tx) => {
      return tx.order.create({
        data: {
          userId,
          totalAmount,
          status: 'PENDING',
          items: { create: orderItems },
        },
        include: { items: true },
      });
    });

    this.logger.log(`Order ${order.id} created`);

    // 4. Kafka 이벤트 발행 (best-effort)
    try {
      await this.kafkaProducer.publishOrderEvent({
        eventId: randomUUID(),
        eventType: OrderEventType.ORDER_CREATED,
        timestamp: new Date().toISOString(),
        orderId: order.id,
        userId: order.userId,
        totalAmount: order.totalAmount,
      });
    } catch (error) {
      this.logger.error('Failed to publish ORDER_CREATED event', error);
      // 주문은 이미 성공했으므로 예외 던지지 않음
    }

    return order;
  }

  async markAsPaid(id: number, userId: number) {
    const order = await this.prisma.order.update({
      where: { id, userId },
      data: { status: 'PAID' },
    });

    await this.kafkaProducer.publishOrderEvent({
      eventId: randomUUID(),
      eventType: OrderEventType.ORDER_PAID,
      timestamp: new Date().toISOString(),
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
    });

    return order;
  }
}
```

**설계 포인트:**
- DB 트랜잭션 성공 후 이벤트 발행
- Kafka 실패해도 주문은 성공 (best-effort)
- 이벤트에 `eventId` 포함 (멱등성 체크용)

---

## 6. NotificationService

```typescript
// src/notification/notification.service.ts
@Injectable()
export class NotificationService {
  constructor(private prisma: PrismaService) {}

  async create(createNotificationDto: CreateNotificationDto) {
    return this.prisma.notification.create({
      data: createNotificationDto,
    });
  }

  async findByUser(userId: number) {
    return this.prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });
  }
}
```

---

## 7. API 엔드포인트 명세

### 7.1 주문 API

**POST /api/orders**
- 인증: 필수
- 요청:
  ```json
  {
    "items": [
      { "productId": 1, "quantity": 2 },
      { "productId": 3, "quantity": 1 }
    ]
  }
  ```
- 응답:
  ```json
  {
    "id": 1,
    "userId": 10,
    "totalAmount": 15000,
    "status": "PENDING",
    "createdAt": "...",
    "items": [...]
  }
  ```
- 상태: 201 Created
- 비동기: ORDER_CREATED 이벤트 발행

**PATCH /api/orders/:id/pay**
- 인증: 필수
- 응답: 업데이트된 주문
- 비동기: ORDER_PAID 이벤트 발행

**PATCH /api/orders/:id/cancel**
- 인증: 필수
- 응답: 업데이트된 주문
- 비동기: ORDER_CANCELLED 이벤트 발행

### 7.2 알림 API

**GET /api/notifications**
- 인증: 필수
- 응답:
  ```json
  [
    {
      "id": 1,
      "userId": 10,
      "type": "ORDER_CREATED",
      "message": "Your order #1 has been created. Total: $15000",
      "createdAt": "..."
    }
  ]
  ```

---

## 8. 환경 설정

```env
# .env
KAFKA_BROKERS=localhost:9092
KAFKA_CLIENT_ID=web-phase1-5-node
KAFKA_GROUP_ID=notification-consumer-group
KAFKA_ENABLED=true

# .env.test
KAFKA_ENABLED=false
```

### Docker Compose (로컬 개발)

```yaml
# docker-compose.yml
version: '3.8'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    depends_on:
      - zookeeper
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    ports:
      - "9092:9092"
```

---

## 9. 테스트 전략

### 9.1 통합 테스트 (이상적)

```typescript
describe('Order Events (e2e)', () => {
  it('should create order and notification asynchronously', async () => {
    // 1. 주문 생성
    const orderRes = await request(app.getHttpServer())
      .post('/api/orders')
      .set('Authorization', `Bearer ${token}`)
      .send({
        items: [{ productId: 1, quantity: 2 }],
      })
      .expect(201);

    const orderId = orderRes.body.id;

    // 2. 이벤트 처리 대기 (Consumer가 처리할 시간)
    await sleep(2000);

    // 3. 알림 생성 확인
    const notificationRes = await request(app.getHttpServer())
      .get('/api/notifications')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(notificationRes.body.length).toBeGreaterThan(0);
    expect(notificationRes.body[0].type).toBe('ORDER_CREATED');
    expect(notificationRes.body[0].message).toContain(orderId.toString());
  });
});
```

### 9.2 현실 타협 (Kafka Mock)

```typescript
it('should call kafkaProducer on order creation', async () => {
  jest.spyOn(kafkaProducer, 'publishOrderEvent').mockResolvedValue();

  await orderService.createOrder(userId, createOrderDto);

  expect(kafkaProducer.publishOrderEvent).toHaveBeenCalledWith(
    expect.objectContaining({
      eventType: 'ORDER_CREATED',
      orderId: expect.any(Number),
    }),
  );
});
```

---

## 10. 검증 체크리스트

### 10.1 기능 검증

- [ ] 주문 생성 시 ORDER_CREATED 이벤트 발행
- [ ] Consumer가 이벤트 수신하여 Notification 생성
- [ ] 결제 완료 시 ORDER_PAID 이벤트 발행
- [ ] 주문 취소 시 ORDER_CANCELLED 이벤트 발행
- [ ] 여러 주문 동시 생성 시 모두 처리

### 10.2 비동기 특성

- [ ] 주문 API 응답 < 200ms (이벤트 처리 대기 안 함)
- [ ] Consumer 중단 후 재시작 시 밀린 이벤트 처리
- [ ] Kafka 실패 시에도 주문은 성공

### 10.3 멱등성

- [ ] 같은 이벤트 2번 처리해도 알림 1개만 생성 (선택)

---

## 11. 완료 기준

✅ Order, OrderItem, Notification 모델 Prisma 스키마 작성
✅ KafkaProducerService 구현
✅ NotificationConsumer 구현
✅ OrderService에 Kafka 통합
✅ 주문 생성/결제/취소 API 구현
✅ 알림 조회 API 구현
✅ Docker Compose로 Kafka 로컬 환경 구성
✅ 통합 테스트 작성 (또는 Mock 테스트)
✅ CI 테스트 통과

---

## 12. N2.0~N2.5 총정리

### 확립된 패턴

| 마일스톤 | 핵심 패턴 |
|---------|-----------|
| N2.0 | NestJS 부트스트랩, CI/CD, Prisma, ValidationPipe |
| N2.1 | Controller/Service 레이어, JWT 인증, DTO, 트랜잭션 |
| N2.2 | RBAC, 권한 검증, 401/403/404 구분, 비즈니스 규칙 |
| N2.3 | 배치 스케줄러, 통계 집계, 캐싱, 외부 API 재시도 |
| N2.4 | Elasticsearch 통합, 전문 검색, RDB↔ES 동기화 |
| N2.5 | Kafka Producer/Consumer, 이벤트 기반, 비동기 처리 |

### 학습 성과

✅ **아키텍처**: 레이어드, CQRS (읽기/쓰기 분리), 이벤트 기반
✅ **데이터베이스**: Prisma, 트랜잭션, 인덱스 전략
✅ **인증/인가**: JWT, RBAC, Guard
✅ **성능**: 캐싱, 페이지네이션, 검색 인덱스
✅ **비동기**: 배치, Kafka, Consumer Group
✅ **통합**: Elasticsearch, Kafka, 외부 API
✅ **테스트**: 단위, e2e, Mock, 통합
✅ **CI/CD**: GitHub Actions, 자동 테스트, 빌드 검증

---

## 13. 참고 자료

- [KafkaJS Official Docs](https://kafka.js.org/)
- [Kafka Concepts](https://kafka.apache.org/documentation/)
- [Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
- [At-Least-Once vs Exactly-Once](https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/)
