# Docker, PostgreSQL, Redis 인프라 설계 일지 (N2.6)
> 프로덕션 배포를 위한 데이터베이스 전환, 분산 캐싱, 컨테이너 오케스트레이션

## 1. 문제 정의 & 요구사항

### 1.1 목표

N2.0~N2.5까지 구축한 **기능들을 프로덕션 환경에서 운영 가능하도록** 인프라를 강화한다:
- SQLite → PostgreSQL 전환 (프로덕션 DB)
- In-memory → Redis 캐시 전환 (분산 캐싱)
- Docker Compose 기반 전체 스택 컨테이너화
- 클라우드 배포 준비 (환경 분리)

### 1.2 기능 요구사항

#### 1.2.1 데이터베이스 전환 (SQLite → PostgreSQL)

**문제:**
- SQLite는 개발/테스트에는 편리하지만 프로덕션 환경에 부적합:
  - 동시 쓰기 제약 (파일 잠금)
  - 확장성 한계 (단일 파일)
  - 네트워크 접근 불가 (서버-DB 분리 불가)

**요구사항:**
1. **PostgreSQL 16 사용**
   - ACID 트랜잭션 보장
   - 동시성 지원 (MVCC)
   - 확장 가능한 아키텍처

2. **Prisma Schema 변경**
   - `provider = "sqlite"` → `provider = "postgresql"`
   - 마이그레이션 재생성

3. **환경별 DB 분리**
   - **개발**: SQLite 유지 (빠른 로컬 개발)
   - **테스트**: SQLite in-memory (빠른 테스트)
   - **프로덕션**: PostgreSQL (안정성)

#### 1.2.2 Redis 캐시 전환

**문제:**
- N2.3에서 구현한 in-memory 캐시는 단일 인스턴스 전용:
  - 서버 재시작 시 캐시 손실
  - 다중 인스턴스 환경에서 캐시 불일치
  - 메모리 제약

**요구사항:**
1. **Redis 7 통합**
   - 분산 캐시 지원
   - 영속성 옵션 (RDB/AOF)
   - TTL 자동 관리

2. **Fallback 전략**
   - Redis 미설정 시 in-memory 캐시 사용
   - 개발 환경 편의성 유지

3. **기존 코드 호환성**
   - N2.3 캐싱 코드 수정 없이 동작
   - `CACHE_MANAGER` 주입 패턴 유지

#### 1.2.3 Docker & 컨테이너화

**요구사항:**
1. **Dockerfile**
   - Multi-stage build (의존성 설치 + 빌드 + 실행)
   - Node 20 Alpine (경량 이미지)
   - Prisma 클라이언트 생성 포함

2. **docker-compose.yml**
   - 전체 스택 오케스트레이션:
     - `app`: NestJS 애플리케이션
     - `db`: PostgreSQL 16
     - `redis`: Redis 7
     - `elasticsearch`: Elasticsearch 8.11 (N2.4용)
     - `kafka`, `zookeeper`: Kafka 스트리밍 (N2.5용)
   - 네트워크 격리 (`app-network`)
   - 볼륨 영속성 (`postgres_data`, `redis_data`)

3. **환경 변수 관리**
   - `.env.example`: 템플릿
   - Docker Compose 내부 환경 변수 설정
   - 민감 정보 분리 (`.env.local`, Secrets)

### 1.3 비기능 요구사항

#### 1.3.1 성능
- PostgreSQL 연결 풀링 (Prisma 내장)
- Redis 캐시 히트율 80% 이상 (인기 이슈)
- Docker 이미지 크기 < 500MB

#### 1.3.2 안정성
- PostgreSQL 트랜잭션 ACID 보장
- Redis 장애 시 in-memory 캐시로 자동 전환
- 컨테이너 재시작 정책 (`restart: unless-stopped`)

#### 1.3.3 확장성
- 수평 확장 가능 (Redis 공유 캐시)
- DB 연결 풀 설정 (동시 연결 제어)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 PostgreSQL인가?

**SQLite의 한계:**
```text
동시성:
  - 쓰기 작업 시 전체 DB 잠금
  - 읽기-쓰기 동시 처리 제한

확장성:
  - 단일 파일, 네트워크 분리 불가
  - 대용량 데이터 처리 시 성능 저하

타입 지원:
  - ENUM, ARRAY 타입 미지원
  - JSON 지원 제한적
```

**PostgreSQL의 강점:**
```text
동시성:
  - MVCC (Multi-Version Concurrency Control)
  - 읽기-쓰기 블로킹 최소화

확장성:
  - 네트워크 DB (서버-DB 분리)
  - 파티셔닝, 리플리케이션 지원

타입 시스템:
  - ENUM, ARRAY, JSONB 네이티브 지원
  - 전문 검색 (tsquery, tsvector)
```

**마이그레이션 전략:**
- Prisma ORM 덕분에 `provider` 변경만으로 전환 가능
- 개발 환경은 SQLite 유지 (빠른 프로토타이핑)
- CI/CD는 PostgreSQL로 통일

### 2.2 왜 Redis인가?

**In-memory 캐시의 문제:**
```typescript
// ❌ 문제: 다중 인스턴스 환경
[서버 A] → 캐시 A (인기 이슈: [1, 2, 3])
[서버 B] → 캐시 B (캐시 없음, DB 재조회)
→ 로드 밸런서 뒤에서 캐시 불일치
```

**Redis의 장점:**
```text
분산 캐시:
  - 모든 인스턴스가 동일 캐시 공유
  - 수평 확장 시에도 일관성 유지

영속성:
  - RDB 스냅샷, AOF 로그
  - 재시작 후 캐시 복구 가능

확장성:
  - 클러스터 모드 (수십 GB 캐시)
  - Pub/Sub, Stream 등 고급 기능
```

**Fallback 전략:**
```typescript
// app.module.ts
if (!process.env.REDIS_HOST) {
  logger.warn('Redis not configured, using in-memory cache');
  return { ttl: 300 }; // in-memory
}
return {
  store: await redisStore({ socket: { host, port } }),
  ttl: 300,
};
```
→ 개발 환경에서는 Redis 없이도 동작

### 2.3 Docker Compose의 역할

**왜 Docker Compose인가:**
- **로컬 개발 환경 일관성**: 팀원 모두 동일한 PostgreSQL, Redis 버전 사용
- **통합 테스트**: 전체 스택 실행 후 e2e 테스트
- **프로덕션 유사 환경**: 배포 전 로컬에서 검증

**대안 비교:**

| 방식 | 장점 | 단점 |
|------|------|------|
| 로컬 설치 | 설정 자유도 높음 | 환경 차이, 설치 복잡 |
| Docker Compose | 일관성, 재현성 | 초기 학습 곡선 |
| Kubernetes | 프로덕션 수준 오케스트레이션 | 과도한 복잡도 (개발 단계) |

→ N2.6에서는 Docker Compose 채택 (적절한 복잡도)

---

## 3. 데이터베이스 마이그레이션 설계

### 3.1 Prisma Schema 변경

```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql"  // sqlite → postgresql 변경
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// 모델은 기존 N2.0~N2.5와 동일
model User { ... }
model Issue { ... }
// ...
```

### 3.2 마이그레이션 재생성

```bash
# 기존 SQLite 마이그레이션 삭제 (선택)
rm -rf prisma/migrations

# PostgreSQL용 마이그레이션 생성
npx prisma migrate dev --name init-postgresql

# migration_lock.toml 자동 생성
# provider = "postgresql"
```

### 3.3 환경별 DATABASE_URL 설정

**개발 환경 (`.env.local`):**
```env
# SQLite 유지 (빠른 로컬 개발)
DATABASE_URL="file:./dev.db"
```

**테스트 환경 (`.env.test`):**
```env
# In-memory SQLite (빠른 테스트)
DATABASE_URL="file::memory:?cache=shared"
```

**프로덕션 환경 (docker-compose.yml):**
```yaml
environment:
  DATABASE_URL: postgresql://app:app@db:5432/app?schema=public
```

### 3.4 PrismaService 변경 없음

```typescript
// src/common/prisma/prisma.service.ts
// 코드 수정 불필요 - Prisma Client가 자동으로 PostgreSQL 쿼리 생성
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

**Prisma의 장점:**
- ORM 덕분에 SQL 방언 차이 추상화
- 마이그레이션 파일만 재생성하면 됨
- 서비스 레이어 코드 변경 없음

---

## 4. Redis 캐시 통합

### 4.1 패키지 설치

```json
// package.json
{
  "dependencies": {
    "@nestjs/cache-manager": "^3.0.1",
    "cache-manager": "^7.2.5",
    "cache-manager-redis-store": "^3.0.1"
  }
}
```

### 4.2 AppModule 설정

```typescript
// src/app.module.ts
import { CacheModule } from '@nestjs/cache-manager';
import { redisStore } from 'cache-manager-redis-store';

@Module({
  imports: [
    CacheModule.registerAsync({
      isGlobal: true,
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const logger = new Logger(AppModule.name);
        const host = configService.get<string>('REDIS_HOST');
        const port = Number(configService.get<string>('REDIS_PORT')) || 6379;

        // Fallback: Redis 미설정 시 in-memory 사용
        if (!host) {
          logger.warn('REDIS_HOST not set. Falling back to in-memory cache store.');
          return {
            ttl: 300, // 5분
          };
        }

        // Redis 설정
        return {
          store: await redisStore({
            socket: {
              host,
              port,
            },
          }),
          ttl: 300, // 5분
        };
      },
    }),
    // ...
  ],
})
export class AppModule {}
```

**설계 포인트:**
- `useFactory`: 비동기 Redis 연결 설정
- `isGlobal: true`: 모든 모듈에서 `CACHE_MANAGER` 주입 가능
- Fallback: `REDIS_HOST` 없으면 in-memory 캐시 사용
- TTL 글로벌 설정: 5분 (개별 설정 가능)

### 4.3 기존 캐싱 코드 호환성

**N2.3에서 작성한 코드 변경 없음:**
```typescript
// src/issue/issue.service.ts (N2.3에서 작성)
@Inject(CACHE_MANAGER) private cacheManager: Cache

async findPopular(): Promise<IssueResponseDto[]> {
  const cacheKey = 'popular_issues:v1';

  // 1. 캐시 조회 (Redis 또는 in-memory)
  const cached = await this.cacheManager.get<IssueResponseDto[]>(cacheKey);
  if (cached) {
    return cached;
  }

  // 2. DB 조회 + 계산
  const popularIssues = await this.calculatePopularIssues();

  // 3. 캐시 저장 (Redis 또는 in-memory)
  await this.cacheManager.set(cacheKey, popularIssues, 300);

  return popularIssues;
}
```

**추상화 레벨:**
- `CacheManager` 인터페이스 덕분에 백엔드(Redis/in-memory) 투명
- 서비스 코드는 캐시 구현체 모름
- 환경 변수만으로 캐시 전환

### 4.4 타입 정의 (TypeScript)

```typescript
// src/types/cache-manager-redis-store.d.ts
declare module 'cache-manager-redis-store' {
  import { CacheStore } from '@nestjs/cache-manager';

  export function redisStore(config: {
    socket: {
      host: string;
      port: number;
    };
  }): Promise<CacheStore>;
}
```

---

## 5. Docker & 컨테이너화

### 5.1 Dockerfile

```dockerfile
# backend/node.js/Dockerfile
FROM node:20-alpine

WORKDIR /app

# 1. 의존성 설치
COPY package*.json ./
RUN npm ci

# 2. 소스 복사 & Prisma 클라이언트 생성
COPY . .
RUN npx prisma generate
RUN npm run build

# 3. 실행 환경 설정
ENV NODE_ENV=production
ENV PORT=3000
EXPOSE 3000

# 4. 애플리케이션 시작
CMD ["node", "dist/main.js"]
```

**설계 결정:**
- **Node 20 Alpine**: 경량 베이스 이미지 (~100MB)
- **npm ci**: `package-lock.json` 정확한 버전 설치
- **Prisma generate**: 런타임 전에 클라이언트 코드 생성
- **Multi-stage 없음**: 개발 단계에서는 단순화 (추후 최적화 가능)

### 5.2 docker-compose.yml

```yaml
version: '3.8'

services:
  # NestJS 애플리케이션
  app:
    build: .
    container_name: web-phase1-5-node
    depends_on:
      - db
      - redis
    environment:
      PORT: 3000
      NODE_ENV: production
      DATABASE_URL: postgresql://app:app@db:5432/app?schema=public
      REDIS_HOST: redis
      REDIS_PORT: 6379
      ELASTICSEARCH_NODE: http://elasticsearch:9200
      ELASTICSEARCH_ENABLED: 'false'
      KAFKA_BROKERS: kafka:29092
      KAFKA_CLIENT_ID: web-phase1-5-node
      KAFKA_GROUP_ID: notification-consumer-group
      KAFKA_ENABLED: 'false'
      JWT_SECRET: change-me-in-prod
      JWT_EXPIRES_IN: 1d
    ports:
      - '3000:3000'
    networks:
      - app-network

  # PostgreSQL 16
  db:
    image: postgres:16
    container_name: postgres
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: app
      POSTGRES_DB: app
    ports:
      - '5432:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network

  # Redis 7
  redis:
    image: redis:7
    container_name: redis
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # Zookeeper (Kafka 의존성)
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    hostname: zookeeper
    container_name: zookeeper
    ports:
      - '2181:2181'
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    networks:
      - app-network

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:7.5.0
    hostname: kafka
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - '9092:9092'
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: 'true'
    networks:
      - app-network

  # Kafka UI
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    depends_on:
      - kafka
    ports:
      - '8080:8080'
    environment:
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    networks:
      - app-network

  # Elasticsearch (N2.4용)
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - 'ES_JAVA_OPTS=-Xms512m -Xmx512m'
    ports:
      - '9200:9200'
      - '9300:9300'
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
```

**설계 포인트:**

1. **의존성 관리**
   - `depends_on`: 시작 순서 제어 (db, redis 먼저 시작)
   - 애플리케이션은 DB 준비 후 시작

2. **네트워크 격리**
   - `app-network`: 모든 컨테이너 연결
   - 서비스 간 호스트명으로 통신 (예: `db:5432`)

3. **볼륨 영속성**
   - `postgres_data`: PostgreSQL 데이터 보존 (재시작 후에도 유지)
   - `redis_data`: Redis 스냅샷 보존

4. **포트 매핑**
   - 로컬 개발: `localhost:3000`, `localhost:5432`, `localhost:6379`
   - 컨테이너 내부: 서비스명으로 접근

### 5.3 실행 명령어

```bash
# 전체 스택 시작 (백그라운드)
docker-compose up -d

# 로그 확인
docker-compose logs -f app

# 마이그레이션 실행 (최초 1회)
docker-compose exec app npx prisma migrate deploy

# 전체 스택 중지
docker-compose down

# 볼륨까지 삭제 (DB 데이터 초기화)
docker-compose down -v
```

---

## 6. 환경 변수 관리

### 6.1 .env.example (템플릿)

```env
# Application
PORT=3000
NODE_ENV=development

# Database (SQLite)
DATABASE_URL="file:./dev.db"

# JWT
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=1d

# Elasticsearch
ELASTICSEARCH_NODE=http://localhost:9200
ELASTICSEARCH_ENABLED=false

# Kafka
KAFKA_BROKERS=localhost:9092
KAFKA_CLIENT_ID=web-phase1-5-node
KAFKA_GROUP_ID=notification-consumer-group
KAFKA_ENABLED=true

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
```

### 6.2 환경별 설정 전략

**로컬 개발 (`.env.local`):**
```env
DATABASE_URL="file:./dev.db"  # SQLite
REDIS_HOST=  # 비어있음 → in-memory 캐시 사용
```

**Docker Compose (docker-compose.yml):**
```yaml
environment:
  DATABASE_URL: postgresql://app:app@db:5432/app?schema=public
  REDIS_HOST: redis
```

**프로덕션 (클라우드):**
```env
DATABASE_URL=postgresql://user:pass@prod-db.example.com:5432/app
REDIS_HOST=prod-redis.example.com
JWT_SECRET=<강력한-시크릿>
```

---

## 7. 검증 체크리스트

### 7.1 PostgreSQL 전환

- [ ] `npx prisma migrate dev --name init-postgresql` 성공
- [ ] `migration_lock.toml`에 `provider = "postgresql"` 확인
- [ ] Docker Compose로 PostgreSQL 실행 (`docker-compose up -d db`)
- [ ] 애플리케이션이 PostgreSQL에 연결되어 정상 동작
- [ ] 트랜잭션 테스트 (N2.1) 통과

### 7.2 Redis 캐시

- [ ] Docker Compose로 Redis 실행 (`docker-compose up -d redis`)
- [ ] `GET /api/issues/popular` 첫 호출 → DB 조회
- [ ] `GET /api/issues/popular` 두 번째 호출 → Redis 캐시 히트
- [ ] Redis CLI로 캐시 키 확인 (`docker-compose exec redis redis-cli KEYS '*'`)
- [ ] `REDIS_HOST` 제거 → in-memory 캐시로 전환 확인

### 7.3 Docker

- [ ] `docker-compose build` 성공
- [ ] `docker-compose up -d` 전체 스택 시작
- [ ] `docker-compose logs app` 에러 없이 실행
- [ ] `docker-compose exec app npx prisma migrate deploy` 마이그레이션 성공
- [ ] `curl http://localhost:3000/api/health` 200 응답

### 7.4 환경 분리

- [ ] 로컬 개발: SQLite + in-memory 캐시로 실행
- [ ] Docker: PostgreSQL + Redis로 실행
- [ ] 테스트: SQLite in-memory로 e2e 테스트 통과

---

## 8. 완료 기준 (Definition of Done)

✅ Prisma Schema `provider = "postgresql"` 변경 완료
✅ PostgreSQL 16 Docker 서비스 추가
✅ Redis 7 Docker 서비스 추가
✅ `CacheModule` Redis 통합 (Fallback 포함)
✅ Dockerfile 작성 (Multi-stage build)
✅ docker-compose.yml 전체 스택 오케스트레이션
✅ 환경 변수 관리 (`.env.example` 업데이트)
✅ 로컬/Docker 환경 모두 정상 동작
✅ e2e 테스트 통과 (PostgreSQL 환경)
✅ README.md에 Docker 실행 가이드 추가

---

## 9. 다음 마일스톤과의 연결

### N2.6에서 확립된 것

- PostgreSQL 프로덕션 DB
- Redis 분산 캐시
- Docker Compose 전체 스택
- 환경별 설정 분리 전략

### N2.7+ (향후 확장)

- **Kubernetes 배포**
  - Helm Chart
  - ConfigMap/Secret 관리
  - HPA (Horizontal Pod Autoscaler)

- **모니터링 & 로깅**
  - Prometheus + Grafana
  - ELK Stack (Elasticsearch, Logstash, Kibana)
  - APM (Application Performance Monitoring)

- **CI/CD 고도화**
  - Docker 이미지 자동 빌드
  - 레지스트리 Push (Docker Hub, ECR)
  - 자동 배포 (ArgoCD, Flux)

---

## 10. 알려진 제약 & 향후 개선점

### 10.1 현재 제약

1. **마이그레이션 전략**
   - SQLite → PostgreSQL 데이터 이관 스크립트 없음
   - 개선: `pg_dump`, ETL 스크립트 작성

2. **Redis 고가용성**
   - 단일 인스턴스 (SPOF)
   - 개선: Redis Sentinel, Redis Cluster

3. **Docker 이미지 크기**
   - ~400MB (최적화 여지)
   - 개선: Multi-stage build, Alpine 베이스

4. **환경 변수 검증**
   - 필수 변수 누락 시 런타임 에러
   - 개선: `joi` 스키마 부트스트랩 검증

### 10.2 확장 포인트

- **데이터베이스 복제**: Primary-Replica 구성
- **Redis Pub/Sub**: 실시간 알림
- **Nginx 리버스 프록시**: 로드 밸런싱
- **SSL/TLS**: HTTPS 적용

---

## 11. 참고 자료

- [PostgreSQL 공식 문서](https://www.postgresql.org/docs/)
- [Redis 공식 문서](https://redis.io/documentation)
- [Docker Compose 공식 문서](https://docs.docker.com/compose/)
- [Prisma Database Providers](https://www.prisma.io/docs/reference/database-reference/supported-databases)
- [NestJS Caching](https://docs.nestjs.com/techniques/caching)
