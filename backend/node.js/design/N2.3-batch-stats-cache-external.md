# 배치, 통계, 캐시, 외부 API 설계 일지 (N2.3)
> 스케줄러 기반 배치 작업, 통계 집계, 캐싱 전략, 외부 API 통합 패턴 학습

## 1. 문제 정의 & 요구사항

### 1.1 목표

**운영/성능 관련 백엔드 패턴** 4가지를 한 마일스톤에서 경험:
- **배치 작업**: 정기적인 통계 집계
- **통계 테이블**: 분석용 데이터 별도 저장
- **캐싱**: 자주 조회되는 데이터 성능 최적화
- **외부 API**: HTTP 클라이언트, 재시도, 타임아웃 처리

### 1.2 기능 요구사항

#### 1.2.1 배치 작업 (Scheduler)

**일별 이슈 통계 집계:**
- 매일 새벽 3시 자동 실행
- 전날(yesterday) 기준 집계:
  - 생성된 이슈 수
  - RESOLVED/CLOSED로 변경된 이슈 수
  - 작성된 댓글 수
- `DailyIssueStats` 테이블에 upsert

**수동 트리거:**
- 테스트/관리 목적 수동 실행 API

#### 1.2.2 통계 조회 API

**GET /api/stats/daily?from=2025-01-01&to=2025-01-31**
- 날짜 범위 내 통계 배열 반환
- 정렬: 날짜 오름차순

#### 1.2.3 캐싱

**인기 이슈 캐싱:**
- 정의: 최근 7일간 `viewCount + commentCount` 기준 상위 10개
- `GET /api/issues/popular`
- 캐시 전략:
  - 캐시 미스 → DB 조회/계산 → 캐시 저장 (TTL 5분)
  - 캐시 히트 → 캐시 직접 반환
- 캐시 백엔드: in-memory (`@nestjs/cache-manager`)

#### 1.2.4 외부 API 통합

**GET /api/external/posts/:id**
- JSONPlaceholder API 호출 예시: `https://jsonplaceholder.typicode.com/posts/{id}`
- 요구사항:
  - 타임아웃: 5초
  - 재시도: 최대 3회 (지수 백오프)
  - 최종 실패 시 fallback 응답 + 로그

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 캐시 히트 시 응답 시간 < 10ms
- 배치 작업이 서비스 응답에 영향 없음 (백그라운드 실행)

#### 1.3.2 안정성
- 배치 작업 실패 시 로그 기록, 서버 계속 운영
- 외부 API 실패 시 서비스 가용성 유지

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 배치 작업인가?

**실시간 집계의 문제:**
```typescript
// ❌ 나쁜 예: 매번 전체 이슈 스캔
async getDailyStats(date: string) {
  const createdCount = await this.prisma.issue.count({
    where: {
      createdAt: {
        gte: new Date(`${date}T00:00:00`),
        lt: new Date(`${date}T23:59:59`),
      },
    },
  });
  // 느리고 DB 부하 큼
}
```

**배치 집계의 장점:**
- 한 번 계산 → 여러 번 조회
- 통계 테이블 인덱스 최적화
- 과거 데이터 변경 없으므로 캐싱 효과적

### 2.2 왜 @nestjs/schedule인가?

**대안들:**
- **Cron 스크립트 (외부)**: 별도 프로세스, 코드 베이스 분리
- **setInterval (Node.js)**: 재시작 시 타이밍 보장 어려움
- **@nestjs/schedule**:
  - 애플리케이션 라이프사이클과 통합
  - DI 컨테이너 사용 가능 (PrismaService 주입)
  - Cron 표현식 지원

```typescript
@Cron(CronExpression.EVERY_DAY_AT_3AM)
async handleDailyStats() {
  // 배치 로직
}
```

### 2.3 캐싱 전략

**Cache-Aside 패턴:**
```text
1. 캐시 조회
   ├─ 히트 → 반환
   └─ 미스 → DB 조회 → 캐시 저장 → 반환
```

**TTL (Time To Live):**
- 5분: 데이터 신선도와 DB 부하 균형
- 너무 짧으면: 캐시 효과 ↓
- 너무 길면: 오래된 데이터 노출

**캐시 무효화:**
- 이슈 생성/댓글 추가 시 캐시 삭제 가능
- 이 프로젝트에서는 TTL만 사용 (간단함)

### 2.4 외부 API 재시도 전략

**일시적 실패 vs 영구적 실패:**
- 일시적: 네트워크 순간 단절, 서버 순간 과부하 → 재시도 효과적
- 영구적: 인증 실패, 잘못된 파라미터 → 재시도 무의미

**지수 백오프 (Exponential Backoff):**
```text
1차 시도 실패 → 2초 대기 → 2차 시도
2차 시도 실패 → 4초 대기 → 3차 시도
3차 시도 실패 → fallback
```

---

## 3. 데이터베이스 스키마 설계

### 3.1 Prisma 스키마 (N2.3 도메인)

```prisma
// DailyIssueStats 모델
model DailyIssueStats {
  id             Int      @id @default(autoincrement())
  date           String   @unique  // Format: YYYY-MM-DD
  createdCount   Int      @default(0)
  resolvedCount  Int      @default(0)
  commentCount   Int      @default(0)
  createdAt      DateTime @default(now())

  @@index([date])
}

// Issue 모델에 viewCount 추가 (N2.1에서 정의, N2.3에서 활용)
model Issue {
  // ... 기존 필드
  viewCount   Int      @default(0)  // 인기 이슈 계산용
}
```

### 3.2 스키마 설계 결정

**date를 String으로:**
- SQLite는 Date 타입 없음
- `YYYY-MM-DD` 형식으로 저장
- `@unique` constraint로 중복 방지

**통계 테이블 vs VIEW:**
- VIEW: 실시간 집계, 느림
- 테이블: 미리 계산, 빠름, 배치로 갱신

---

## 4. 배치 작업 구현

### 4.1 StatsScheduler

```typescript
// src/stats/stats.scheduler.ts
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { StatsService } from './stats.service';

@Injectable()
export class StatsScheduler {
  private readonly logger = new Logger(StatsScheduler.name);

  constructor(private statsService: StatsService) {}

  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async handleDailyStatsAggregation() {
    this.logger.log('Starting daily stats aggregation job');

    try {
      // 어제 날짜 계산
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const dateStr = yesterday.toISOString().split('T')[0]; // YYYY-MM-DD

      await this.statsService.aggregateDailyStats(dateStr);

      this.logger.log('Daily stats aggregation job completed successfully');
    } catch (error) {
      this.logger.error('Daily stats aggregation job failed', error.stack);
    }
  }

  // 수동 트리거 (테스트/관리용)
  async triggerManualAggregation(date?: string): Promise<void> {
    const targetDate = date || new Date().toISOString().split('T')[0];
    this.logger.log(`Manually triggering aggregation for date: ${targetDate}`);
    await this.statsService.aggregateDailyStats(targetDate);
  }
}
```

**설계 포인트:**
- `@Cron` 데코레이터: 선언적 스케줄 정의
- `Logger`: 배치 실행/성공/실패 기록
- try-catch: 배치 실패해도 애플리케이션 계속 운영
- `triggerManualAggregation`: 테스트/디버깅용

### 4.2 StatsService - 집계 로직

```typescript
// src/stats/stats.service.ts
@Injectable()
export class StatsService {
  constructor(private prisma: PrismaService) {}

  async aggregateDailyStats(date: string): Promise<void> {
    const startOfDay = new Date(`${date}T00:00:00Z`);
    const endOfDay = new Date(`${date}T23:59:59Z`);

    // 1. 생성된 이슈 수
    const createdCount = await this.prisma.issue.count({
      where: {
        createdAt: {
          gte: startOfDay,
          lte: endOfDay,
        },
      },
    });

    // 2. Resolved/Closed 된 이슈 수
    const resolvedCount = await this.prisma.issue.count({
      where: {
        status: { in: ['RESOLVED', 'CLOSED'] },
        updatedAt: {
          gte: startOfDay,
          lte: endOfDay,
        },
      },
    });

    // 3. 작성된 댓글 수
    const commentCount = await this.prisma.comment.count({
      where: {
        createdAt: {
          gte: startOfDay,
          lte: endOfDay,
        },
      },
    });

    // 4. Upsert (중복 실행 방지)
    await this.prisma.dailyIssueStats.upsert({
      where: { date },
      update: {
        createdCount,
        resolvedCount,
        commentCount,
      },
      create: {
        date,
        createdCount,
        resolvedCount,
        commentCount,
      },
    });
  }

  async getDailyStats(from: string, to: string) {
    return this.prisma.dailyIssueStats.findMany({
      where: {
        date: {
          gte: from,
          lte: to,
        },
      },
      orderBy: { date: 'asc' },
    });
  }
}
```

**설계 포인트:**
- `upsert`: 중복 실행해도 덮어쓰기 (멱등성)
- 날짜 범위 쿼리: `gte`, `lte` 조합
- 별도 서비스 메서드: 스케줄러와 로직 분리 (테스트 용이)

---

## 5. 캐싱 구현

### 5.1 CacheModule 설정

```typescript
// app.module.ts
import { CacheModule } from '@nestjs/cache-manager';

@Module({
  imports: [
    CacheModule.register({
      isGlobal: true,
      ttl: 300, // 5분 (초 단위)
      max: 100, // 최대 캐시 아이템 수
    }),
    // ...
  ],
})
export class AppModule {}
```

### 5.2 IssueService - 인기 이슈 캐싱

```typescript
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class IssueService {
  constructor(
    private prisma: PrismaService,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  async getPopularIssues(): Promise<IssueResponseDto[]> {
    const cacheKey = 'popular_issues';

    // 1. 캐시 조회
    const cached = await this.cacheManager.get<IssueResponseDto[]>(cacheKey);
    if (cached) {
      return cached;
    }

    // 2. 캐시 미스 → DB 조회
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const issues = await this.prisma.issue.findMany({
      where: {
        createdAt: { gte: sevenDaysAgo },
      },
      include: {
        reporter: true,
        assignee: true,
        comments: true,  // 댓글 수 계산용
      },
      take: 100,  // 정렬 전 후보군
    });

    // 3. 인기도 계산 및 정렬
    const ranked = issues
      .map(issue => ({
        issue,
        score: issue.viewCount + issue.comments.length,
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 10)
      .map(item => this.mapToResponse(item.issue));

    // 4. 캐시 저장
    await this.cacheManager.set(cacheKey, ranked, 300); // TTL 5분

    return ranked;
  }
}
```

**설계 포인트:**
- Cache-Aside 패턴
- 캐시 키: 고정 문자열 (단일 캐시)
- 복잡한 계산 (정렬, 점수): DB가 아닌 애플리케이션 레벨
- TTL 명시적 설정

### 5.3 캐시 무효화 (선택)

```typescript
async createIssue(...) {
  const issue = await this.prisma.issue.create({ ... });

  // 인기 이슈 캐시 무효화
  await this.cacheManager.del('popular_issues');

  return issue;
}
```

---

## 6. 외부 API 통합

### 6.1 ExternalService

```typescript
// src/external/external.service.ts
import { Injectable, Logger, HttpException } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { AxiosError } from 'axios';

@Injectable()
export class ExternalService {
  private readonly logger = new Logger(ExternalService.name);
  private readonly BASE_URL = 'https://jsonplaceholder.typicode.com';

  constructor(private httpService: HttpService) {}

  async getPost(id: number): Promise<any> {
    const maxRetries = 3;
    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        this.logger.log(`Fetching post ${id}, attempt ${attempt}`);

        const response = await firstValueFrom(
          this.httpService.get(`${this.BASE_URL}/posts/${id}`, {
            timeout: 5000, // 5초 타임아웃
          }),
        );

        return response.data;
      } catch (error) {
        lastError = error;
        this.logger.warn(`Attempt ${attempt} failed: ${error.message}`);

        if (attempt < maxRetries) {
          // 지수 백오프: 2^attempt 초
          const delayMs = Math.pow(2, attempt) * 1000;
          await this.sleep(delayMs);
        }
      }
    }

    // 모든 재시도 실패 → Fallback
    this.logger.error(`All ${maxRetries} attempts failed for post ${id}`);

    return {
      id,
      title: 'Fallback: Post Unavailable',
      body: 'External API is currently unavailable',
      error: true,
    };
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

**설계 포인트:**
- `@nestjs/axios`: RxJS 기반 HTTP 클라이언트
- `firstValueFrom`: Observable → Promise 변환
- 재시도 루프: `for` 문으로 간단 구현
- 지수 백오프: `2^attempt` 초
- Fallback: 최종 실패 시 안전한 기본 응답

### 6.2 ExternalController

```typescript
@Controller('external')
export class ExternalController {
  constructor(private externalService: ExternalService) {}

  @Get('posts/:id')
  async getPost(@Param('id', ParseIntPipe) id: number) {
    return this.externalService.getPost(id);
  }
}
```

---

## 7. 모듈 구성

### 7.1 StatsModule

```typescript
// src/stats/stats.module.ts
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { StatsController } from './stats.controller';
import { StatsService } from './stats.service';
import { StatsScheduler } from './stats.scheduler';

@Module({
  imports: [ScheduleModule.forRoot()],
  controllers: [StatsController],
  providers: [StatsService, StatsScheduler],
})
export class StatsModule {}
```

### 7.2 ExternalModule

```typescript
// src/external/external.module.ts
import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { ExternalController } from './external.controller';
import { ExternalService } from './external.service';

@Module({
  imports: [HttpModule],
  controllers: [ExternalController],
  providers: [ExternalService],
})
export class ExternalModule {}
```

---

## 8. API 엔드포인트 명세

### 8.1 통계 API

**GET /api/stats/daily?from=2025-01-01&to=2025-01-31**
- 인증: 필수
- 쿼리 파라미터:
  - `from`: 시작 날짜 (YYYY-MM-DD)
  - `to`: 종료 날짜 (YYYY-MM-DD)
- 응답:
  ```json
  [
    {
      "id": 1,
      "date": "2025-01-15",
      "createdCount": 10,
      "resolvedCount": 5,
      "commentCount": 20,
      "createdAt": "2025-01-16T03:00:00Z"
    }
  ]
  ```

### 8.2 인기 이슈 API

**GET /api/issues/popular**
- 인증: 필수
- 응답: 이슈 배열 (최대 10개)
- 캐시: 5분 TTL

### 8.3 외부 API

**GET /api/external/posts/:id**
- 인증: 선택 (공개 가능)
- 응답:
  ```json
  {
    "userId": 1,
    "id": 1,
    "title": "...",
    "body": "..."
  }
  ```
- 실패 시:
  ```json
  {
    "id": 1,
    "title": "Fallback: Post Unavailable",
    "body": "External API is currently unavailable",
    "error": true
  }
  ```

---

## 9. 테스트 전략

### 9.1 배치 작업 테스트

```typescript
describe('StatsService', () => {
  it('should aggregate daily stats correctly', async () => {
    // 1. 테스트 데이터 생성
    const date = '2025-01-15';
    await createTestIssues(date, 10);
    await createTestComments(date, 20);

    // 2. 집계 실행
    await statsService.aggregateDailyStats(date);

    // 3. 검증
    const stats = await prisma.dailyIssueStats.findUnique({
      where: { date },
    });

    expect(stats.createdCount).toBe(10);
    expect(stats.commentCount).toBe(20);
  });

  it('should be idempotent (multiple runs same result)', async () => {
    const date = '2025-01-15';
    await statsService.aggregateDailyStats(date);
    await statsService.aggregateDailyStats(date); // 중복 실행

    const count = await prisma.dailyIssueStats.count({
      where: { date },
    });

    expect(count).toBe(1); // 하나만 존재
  });
});
```

### 9.2 캐시 테스트

```typescript
it('should return cached data on second call', async () => {
  // 1차 호출 (캐시 미스)
  const result1 = await issueService.getPopularIssues();

  // DB 쿼리 spy
  const spy = jest.spyOn(prisma.issue, 'findMany');

  // 2차 호출 (캐시 히트)
  const result2 = await issueService.getPopularIssues();

  expect(spy).not.toHaveBeenCalled(); // DB 조회 안 함
  expect(result1).toEqual(result2);
});
```

### 9.3 외부 API 재시도 테스트

```typescript
it('should retry on failure and succeed on 2nd attempt', async () => {
  let attempts = 0;

  jest.spyOn(httpService, 'get').mockImplementation(() => {
    attempts++;
    if (attempts === 1) {
      throw new Error('Network error');
    }
    return of({ data: { id: 1, title: 'Success' } }) as any;
  });

  const result = await externalService.getPost(1);

  expect(attempts).toBe(2);
  expect(result.title).toBe('Success');
});

it('should return fallback after all retries fail', async () => {
  jest.spyOn(httpService, 'get').mockImplementation(() => {
    throw new Error('Network error');
  });

  const result = await externalService.getPost(1);

  expect(result.error).toBe(true);
  expect(result.title).toContain('Fallback');
});
```

---

## 10. 환경 설정

```env
# .env
# Stats Scheduler
STATS_CRON_SCHEDULE="0 3 * * *"  # 매일 3시 (옵션)

# External API
EXTERNAL_API_TIMEOUT=5000
EXTERNAL_API_MAX_RETRIES=3
```

---

## 11. 검증 체크리스트

### 11.1 배치 작업

- [ ] 매일 3시 자동 실행 (로컬 테스트: EVERY_5_MINUTES로 변경)
- [ ] 통계 정확성 검증 (수동 집계와 비교)
- [ ] 중복 실행 시 멱등성 (upsert)
- [ ] 실패 시 로그 기록, 서버 계속 운영

### 11.2 캐시

- [ ] 첫 호출 시 DB 조회
- [ ] 두 번째 호출 시 캐시 사용 (DB 조회 없음)
- [ ] 5분 후 캐시 만료, 다시 DB 조회

### 11.3 외부 API

- [ ] 정상 응답 시 데이터 반환
- [ ] 1차 실패 시 재시도
- [ ] 3회 실패 시 fallback 반환
- [ ] 타임아웃 5초 동작

---

## 12. 완료 기준

✅ DailyIssueStats 모델 Prisma 스키마 작성
✅ StatsScheduler 구현 (@Cron)
✅ StatsService 집계 로직 구현
✅ 통계 조회 API 구현
✅ CacheModule 설정
✅ 인기 이슈 캐싱 구현
✅ ExternalService 재시도 로직 구현
✅ 배치/캐시/외부 API 테스트 작성
✅ CI 테스트 통과

---

## 13. 다음 마일스톤과의 연결

### N2.3에서 확립된 것

- 배치 스케줄러 패턴
- 통계 테이블 설계
- 캐싱 전략 (Cache-Aside)
- 외부 API 재시도/타임아웃

### N2.4에서 추가될 것

- Elasticsearch 통합
- 전문 검색 (full-text search)
- 인덱스 매핑
- 검색 API 구현

---

## 14. 참고 자료

- [@nestjs/schedule](https://docs.nestjs.com/techniques/task-scheduling)
- [@nestjs/cache-manager](https://docs.nestjs.com/techniques/caching)
- [@nestjs/axios](https://docs.nestjs.com/techniques/http-module)
- [Exponential Backoff](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)
