# 문서 1. 전체 아키텍처 & 로드맵 개요

## 1. 이 문서의 역할

이 문서는 **"전체 그림"만 보여주는 인덱스 문서**다.

* 대상: C로 서버/시스템 프로그래밍은 해봤지만, 현대 C++/Boost/비동기 I/O는 처음인 개발자
* 목표:
  * C++17 / Boost.Asio / WebSocket / PostgreSQL이 **어떤 구조로 연결되는지** 한 번에 이해
  * 어떤 순서(Stage)로 문서 2, 3, 4를 보면 되는지 파악
  * 각 Stage에서 **무엇을 만들고, 통과 기준이 뭔지** 명확히 정리

세부 문법, 코드, 설정은 각각:

* **문서 2**: C에서 C++17로 - RAII, 스마트 포인터, STL, 람다, 스레드
* **문서 3**: Boost.Asio 비동기 I/O + Boost.Beast WebSocket 실전
* **문서 4**: CMake 빌드 시스템 + PostgreSQL + Prometheus 통합

에서 다룬다. 이 문서는 그 위에 얹는 "지도"라고 생각하면 된다.

---

## 2. 최종 목표: 어떤 서버를 만들 것인가

최종적으로 목표하는 시스템은 명확하다:

> **60 TPS로 실행되는 1v1 실시간 듀얼 게임 서버**
> WebSocket으로 플레이어 입력을 받아 서버 권위 물리 시뮬레이션을 실행하고,
> 매치메이킹, 전투, 통계/순위를 모두 처리하는 프로덕션급 게임 서버

구체적으로:

1. **GameLoop (60 TPS 고정 시간 단계)**
   * 16.67ms마다 콜백 실행
   * 결정론적 물리 시뮬레이션
   * 틱 지속 시간 메트릭 수집

2. **WebSocket 서버 (Boost.Beast)**
   * 비동기 I/O로 여러 클라이언트 처리
   * 텍스트 프레임으로 입력/상태 동기화
   * 클라이언트별 세션 관리

3. **게임 로직**
   * 플레이어 이동 (WASD + 마우스)
   * 발사체 물리 (30 m/s, 원-원 충돌)
   * 체력/데미지 시스템 (100 HP, 20 HP/히트)

4. **매치메이킹**
   * ELO 기반 매칭 (±100 기본 허용 오차)
   * 동적 허용 오차 확장 (대기 시간 기반)
   * 결정론적 페어링

5. **통계 & 순위**
   * 매치 후 통계 수집
   * ELO 등급 계산 (K-factor 25)
   * 리더보드 (등급별 정렬)
   * HTTP API (프로필, 순위)

6. **데이터베이스 & 메트릭**
   * PostgreSQL (세션 이벤트 영속화)
   * Prometheus 메트릭 (틱 레이트, 레이턴시, 매치 수)

**이 전체 플로우를 Stage 1 → 2 → 3으로 쪼개서 올라간다.**

---

## 3. 전체 아키텍처 한 번에 보기

### 3.1 논리적 구성도

```text
[WebSocket Clients (Browser/Native)]
  - 입력 전송 (WASD, 마우스, fire)
  - 상태 수신 (위치, 체력, 사망)
          │  WebSocket (텍스트 프레임)
          ▼
[WebSocketServer (Boost.Beast)]
  - 비동기 Accept/Read/Write
  - 클라이언트 세션 관리
  - 입력 파싱 → GameSession
  - 상태 브로드캐스트
          │
          ├──→ [GameLoop (60 TPS)]
          │      - 고정 시간 단계 (16.67ms)
          │      - 콜백 기반 틱
          │      - 메트릭 수집
          │
          ├──→ [GameSession]
          │      - 플레이어 상태 (위치, 방향, 체력)
          │      - 발사체 시뮬레이션
          │      - 충돌 감지
          │      - 전투 로그
          │
          ├──→ [Matchmaker]
          │      - ELO 기반 큐
          │      - 동적 허용 오차 확장
          │      - 매치 생성 이벤트
          │
          └──→ [PlayerProfileService]
                 - 통계 집계
                 - ELO 등급 계산
                 - 리더보드 관리
          │
          ├──→ [PostgreSQL]
          │      - 세션 이벤트 로그
          │      - 파라미터화된 쿼리
          │
          └──→ [Prometheus]
                 - 게임 루프 메트릭
                 - 매치메이킹 메트릭
                 - HTTP /metrics 엔드포인트
```

관점 정리:

* **GameLoop**: 고정 시간 단계 스케줄러. C 세계의 메인 루프와 동일하지만 정밀한 타이밍 보장.
* **WebSocketServer**: 비동기 I/O로 수백 개의 연결 처리. epoll/kqueue 같은 다중화.
* **GameSession**: 게임 상태 및 물리. C에서 작성하던 로직과 동일하지만 C++17 스타일.
* **Boost.Asio**: 이벤트 루프 및 비동기 I/O 프레임워크. libuv/libevent와 유사.

---

### 3.2 요청–응답 시퀀스 (대표 시나리오)

예시 시나리오: **플레이어 접속 → 매칭 → 게임 → 사망 → 통계 기록**

```text
1. 플레이어가 WebSocket으로 연결 (ws://server:8080)
2. WebSocketServer가 TCP Accept → WebSocket Handshake
3. ClientSession 생성 → ReadLoop 시작
4. 첫 입력 메시지 수신 → player_id 추출
5. on_join 콜백 → GameSession::UpsertPlayer
6. on_join 콜백 → Matchmaker::Enqueue (ELO 1200)
7. Matchmaker::RunMatching (200ms 타이머)
   - 대기 중인 플레이어 페어링
   - Match 생성 → 알림
8. GameLoop Tick (60 Hz):
   - ClientSession::ReadLoop에서 입력 수신
     Format: input <player_id> <seq> <up> <down> <left> <right> <mouse_x> <mouse_y> <fire>
   - GameSession::ApplyInput (이동 벡터 정규화, 위치 업데이트)
   - fire=1 시 발사체 생성 (발사 속도 제한 0.1초)
   - GameSession::Tick (발사체 업데이트, 충돌 감지, 데미지 적용)
   - WebSocketServer::BroadcastState
     Format: state <player_id> <x> <y> <angle> <tick> <health> <alive> ...
9. 충돌 발생:
   - 히트 이벤트 생성 (shooter, target, damage=20)
   - HealthComponent::ApplyDamage → health 0 체크
   - 사망 시 death 이벤트 생성
10. 사망 브로드캐스트:
    - WebSocketServer::BroadcastState에서 death 이벤트 소비
    - Format: death <player_id> <tick>
11. 매치 완료:
    - MatchStatsCollector::Collect (전투 로그 회고적 분석)
    - MatchResult 생성 (승자, 패자, 통계)
    - PlayerProfileService::RecordMatch
      - ELO 등급 업데이트 (승자 +9, 패자 -9)
      - 통계 집계 (킬, 데스, 샷, 히트, 데미지)
      - 리더보드 동기화
12. 연결 해제:
    - ClientSession::Stop → on_leave 콜백
    - Matchmaker::Cancel
    - GameSession::RemovePlayer
```

이 "한 줄 시나리오"를 위해 필요한 지식들을 Stage로 쪼갠 게 뒤에 나오는 로드맵이다.

---

## 4. Stage별 로드맵 개요

Stage는 "기술 이름" 기준이 아니라 **"검증 가능한 기능 단위"** 기준으로 나눈다.

* **Stage 1**: C++17 기초 + 단순 게임 로직 (동기 방식)
* **Stage 2**: Boost.Asio 비동기 I/O + WebSocket 서버
* **Stage 3**: 전체 통합 (매치메이킹, 통계, DB, 메트릭)

각 Stage마다:

* 필요 기술
* 만들어야 할 최소 기능
* 통과 체크리스트

를 명확하게 정의한다.

---

## 5. Stage 1 – C++17 기초 + 동기 게임 로직

### 5.1 Stage 1의 목표

* C에서 C++17로의 전환을 이해하고,
* RAII, 스마트 포인터, STL 컨테이너를 사용할 수 있으며,
* 간단한 **동기 방식 게임 로직**을 C++로 작성할 수 있는 수준.

이 Stage에서는 **네트워크/비동기는 아직 안 건드린다.**
목표는 "C++ 문법과 패턴에 적응하는 것".

### 5.2 다루는 기술

* **C++17 핵심 문법**
  * `auto`, `nullptr`, range-based for
  * `std::string`, `std::vector`, `std::map`
  * RAII (생성자/소멸자)
  * `std::unique_ptr`, `std::shared_ptr`
  * 람다 표현식 `[capture](params) { body }`
  * `std::function` (함수 객체)

* **STL 컨테이너 & 알고리즘**
  * `std::vector<T>` (동적 배열)
  * `std::unordered_map<K, V>` (해시 맵)
  * `std::sort`, `std::find_if` 등 알고리즘

* **멀티스레딩 기초**
  * `std::thread`
  * `std::mutex`, `std::lock_guard`
  * `std::atomic<T>`
  * `std::condition_variable`

* **예외 처리**
  * `try` / `catch` / `throw`
  * RAII와 예외 안전성

### 5.3 이 Stage에서 완성해야 할 기능

최소 기능:

1. **PlayerState 구조체**
   * `std::string player_id`
   * `double x, y, facing_radians`
   * `int health`

2. **GameSession 클래스 (동기 버전)**
   * `std::unordered_map<std::string, PlayerState>` 플레이어 맵
   * `void ApplyInput(player_id, up, down, left, right, mouse_x, mouse_y)`
     * 이동 벡터 정규화
     * 위치 업데이트
   * `void Tick(double delta_seconds)`
     * 틱 카운터 증가
     * (나중에 발사체 업데이트 추가)
   * `std::vector<PlayerState> Snapshot()`
     * 모든 플레이어 상태 복사

3. **간단한 테스트 프로그램**
   * main에서 GameSession 생성
   * 2명의 플레이어 추가
   * 입력 시뮬레이션 (WASD)
   * 여러 틱 실행
   * 상태 출력

### 5.4 통과 체크리스트

아래 항목에 "예"라고 말할 수 있으면 Stage 1 통과로 본다.

* [ ] C++17 `auto`, `nullptr`, range-based for를 이해하고 사용할 수 있다.
* [ ] `std::unique_ptr`, `std::shared_ptr`로 메모리를 관리하고, 소멸자에서 자동 정리되는 것을 확인했다.
* [ ] `std::vector`, `std::unordered_map`, `std::string`을 사용해 동적 컨테이너를 다룰 수 있다.
* [ ] 람다 표현식과 `std::function`을 사용해 콜백을 구현할 수 있다.
* [ ] `std::thread`와 `std::mutex`로 간단한 멀티스레드 프로그램을 작성하고 데이터 레이스를 방지할 수 있다.
* [ ] `try/catch`로 예외를 처리하고, RAII로 리소스 누수를 방지할 수 있다.
* [ ] GameSession 클래스를 작성하고, 입력 적용 및 틱 업데이트를 구현했다.

Stage 1이 끝나면 **"C++ 스타일로 게임 로직을 작성할 수 있는 상태"**가 된다.

---

## 6. Stage 2 – Boost.Asio 비동기 I/O + WebSocket

### 6.1 Stage 2의 목표

* Boost.Asio의 이벤트 루프(`io_context`)를 이해하고,
* 비동기 I/O 패턴(`async_read`, `async_write`)을 사용할 수 있으며,
* Boost.Beast로 **WebSocket 서버**를 구현해서 클라이언트와 실시간 통신할 수 있는 수준.

이 Stage까지가 사실상 "실시간 게임 서버의 네트워크 레이어"를 완성하는 단계다.

### 6.2 다루는 기술

* **Boost.Asio 핵심**
  * `io_context` (이벤트 루프)
  * `async_accept`, `async_read`, `async_write`
  * 콜백 핸들러 (`std::bind`, 람다)
  * `boost::asio::ip::tcp::acceptor`

* **Boost.Beast WebSocket**
  * WebSocket Handshake
  * 텍스트/바이너리 프레임
  * `async_accept`, `async_read`, `async_write`
  * 연결 종료 처리

* **GameLoop와 통합**
  * `std::thread`로 GameLoop 전용 스레드
  * `std::mutex`로 GameSession 보호
  * 틱 콜백에서 상태 브로드캐스트

### 6.3 이 Stage에서 완성해야 할 기능

대표 시나리오 하나를 확실히 끝까지 구현하는 게 좋다.

**권장 시나리오**

1. WebSocket 서버 시작 (포트 8080)

2. 클라이언트 연결 (wscat 또는 브라우저)

3. 클라이언트가 입력 메시지 전송:
   ```
   input player1 0 1 0 0 0 150.0 200.0 0
   ```

4. WebSocketServer가 메시지 파싱 → GameSession::ApplyInput

5. GameLoop (60 Hz)가 틱마다:
   * GameSession::Tick 호출
   * BroadcastState → 모든 클라이언트에 상태 전송:
     ```
     state player1 100.0 200.0 0.0 60
     ```

6. 클라이언트가 연결 해제 → GameSession::RemovePlayer

### 6.4 통과 체크리스트

* [ ] Boost.Asio `io_context`를 생성하고 `run()`으로 이벤트 루프를 실행할 수 있다.
* [ ] `async_accept`로 TCP 연결을 비동기로 수락하고, 핸들러 체인을 이해한다.
* [ ] Boost.Beast로 WebSocket Handshake를 수행하고, 텍스트 프레임을 주고받을 수 있다.
* [ ] 여러 클라이언트가 동시에 연결해도 서버가 안정적으로 동작하는 것을 확인했다.
* [ ] GameLoop를 별도 스레드에서 실행하고, 틱마다 WebSocket으로 상태를 브로드캐스트할 수 있다.
* [ ] 클라이언트 연결/해제 시 리소스가 올바르게 정리되는 것을 확인했다.

여기까지 구현하면, **"실시간 입력을 받아 상태를 브로드캐스트하는 게임 서버의 골격"이 완성된 상태**다.

---

## 7. Stage 3 – 전체 통합 (매치메이킹, 통계, DB, 메트릭)

### 7.1 Stage 3의 목표

이 Stage에서 **프로덕션급 게임 서버의 모든 기능**을 통합한다:

* 매치메이킹 시스템 (ELO 기반)
* 전투 로직 (발사체, 충돌, 데미지)
* 통계 & 순위 (ELO 등급, 리더보드)
* PostgreSQL 연동 (세션 이벤트 로그)
* Prometheus 메트릭 (틱 레이트, 매치 수)
* CMake 빌드 시스템

### 7.2 다루는 기술

* **CMake 빌드**
  * `CMakeLists.txt` 작성
  * Boost, PostgreSQL, 라이브러리 링크
  * Debug/Release 빌드 구성

* **PostgreSQL libpq**
  * `PQconnectdb` (연결)
  * `PQexecParams` (파라미터화된 쿼리)
  * 에러 처리 (`PQresultStatus`)

* **Prometheus 메트릭**
  * Exposition 형식 (텍스트)
  * Gauge, Counter, Histogram
  * HTTP /metrics 엔드포인트

* **전투 시스템**
  * Projectile 클래스 (선형 운동, 만료)
  * 원-원 충돌 감지
  * HealthComponent (데미지 적용)
  * CombatLog (링 버퍼)

* **매치메이킹**
  * ELO 버킷팅 MatchQueue
  * 동적 허용 오차 확장
  * 탐욕적 순차 매칭

* **통계 & 순위**
  * PlayerProfileService (집계)
  * EloRatingCalculator (K=25)
  * LeaderboardStore (이중 인덱스)

### 7.3 이 Stage에서 완성해야 할 기능 (예시)

**전체 플로우 검증**

1. 서버 시작 (CMake 빌드 → 실행)
   * PostgreSQL 연결 확인
   * GameLoop 시작 (60 TPS)
   * WebSocketServer 리스닝
   * Matchmaker 타이머 시작

2. 2명의 플레이어 접속
   * WebSocket 연결
   * 각각 매칭 큐에 등록 (ELO 1200)

3. 매치메이킹
   * Matchmaker::RunMatching (200ms마다)
   * 2명 페어링 → Match 생성
   * 알림 → 게임 세션 시작

4. 게임 플레이
   * 입력 전송 (이동, 발사)
   * 발사체 생성 → 충돌 감지 → 데미지
   * 체력 0 → 사망

5. 매치 완료
   * MatchStatsCollector → MatchResult
   * PlayerProfileService::RecordMatch
   * ELO 업데이트 (승자 1209, 패자 1191)
   * 리더보드 갱신

6. 메트릭 확인
   * `curl http://localhost:9090/metrics`
   * `game_tick_rate`, `matchmaking_matches_total` 등

### 7.4 통과 체크리스트

* [ ] CMake로 프로젝트를 빌드하고, Boost/PostgreSQL 라이브러리를 링크할 수 있다.
* [ ] PostgreSQL에 연결하고, 세션 이벤트를 파라미터화된 쿼리로 기록할 수 있다.
* [ ] 발사체 물리, 충돌 감지, 데미지 시스템을 구현하고 테스트했다.
* [ ] 매치메이킹 알고리즘을 구현하고, 2명의 플레이어를 매칭할 수 있다.
* [ ] ELO 등급 계산 및 리더보드 업데이트를 구현했다.
* [ ] Prometheus 메트릭을 HTTP /metrics로 노출하고, 브라우저/curl로 확인했다.
* [ ] 전체 플로우 (접속 → 매칭 → 게임 → 사망 → 통계)가 정상 작동하는 것을 확인했다.

---

## 8. 정리: 학습 순서 요약

추천 순서는 아래와 같다.

1. **문서 1 (지금 이 문서)**
   * 전체 구조/Stage/목표 확인

2. **문서 2 – C에서 C++17로: 현대 C++ 기초**
   * Stage 1 내용을 채우는 문서
   * RAII, 스마트 포인터, STL, 람다, 스레드
   * 동기 방식 GameSession 구현

3. **문서 3 – Boost.Asio 비동기 I/O와 WebSocket**
   * Stage 2에 해당
   * io_context 이벤트 루프
   * Boost.Beast WebSocket 서버
   * GameLoop와 통합

4. **문서 4 – 빌드 시스템과 실전 통합**
   * Stage 3에 해당
   * CMake 빌드
   * PostgreSQL 연동
   * Prometheus 메트릭
   * 전투/매치메이킹/통계 통합

이 문서는 여기까지.
다음 단계로는 **문서 2**에서 Stage 1 내용을 실제 코드/예제로 채우면 된다.

---

## 9. 참고: MVP 1.0-1.3과의 대응

이 로드맵의 각 Stage는 `arena/design/`의 MVP 문서들과 다음과 같이 대응된다:

* **Stage 1 (C++17 기초)** → MVP 1.0 구현을 위한 언어 기초
  * `design/mvp-1.0.md` (GameLoop, GameSession, PlayerState)

* **Stage 2 (Boost.Asio/WebSocket)** → MVP 1.0 네트워크 레이어
  * `design/mvp-1.0.md` (WebSocketServer, 비동기 I/O)

* **Stage 3 (전체 통합)** → MVP 1.1, 1.2, 1.3 구현
  * `design/mvp-1.1.md` (Projectile, Combat, HealthComponent)
  * `design/mvp-1.2.md` (Matchmaker, MatchQueue, ELO 매칭)
  * `design/mvp-1.3.md` (PlayerProfileService, Leaderboard, ELO 등급)

**각 Stage를 완료하면 대응하는 design/ 문서를 다시 읽어보면, 설계 의도와 구현 세부사항이 명확하게 연결될 것이다.**
