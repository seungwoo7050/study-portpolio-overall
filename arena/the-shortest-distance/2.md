# 문서 2. C에서 C++17로: 현대 C++ 기초

> 이 문서는 **Stage 1 - C++17 기초 + 동기 게임 로직**을 채우는 문서다.
> Boost.Asio/WebSocket은 문서 3에서 다룬다.

---

## 0. 전제 / 목표

### 전제 (이미 알고 있다고 가정하는 것)

* C 문법: 포인터, struct, malloc/free, 함수 포인터
* 멀티스레드 개념 (pthread 또는 유사 라이브러리)
* 기본 자료구조 (배열, 링크드 리스트, 해시 테이블)

### 이 문서의 목표

* C와 C++의 **근본적인 차이점** 이해
* RAII와 스마트 포인터로 **메모리 안전성** 확보
* STL 컨테이너로 **동적 자료구조** 다루기
* 람다와 std::function으로 **콜백** 구현
* std::thread와 std::mutex로 **스레드 안전** 보장

최종적으로 이 정도를 목표로 한다:

* C++ 스타일로 GameSession 클래스 작성
* 플레이어 상태 관리 (std::unordered_map)
* 입력 처리 및 틱 업데이트
* 스레드 안전한 상태 스냅샷

---

## 1. C에서 C++로: 핵심 개념

C++은 C의 상위 집합이 아니다. **다른 패러다임의 언어**다. C 프로그래머가 혼란스러워하는 핵심 차이점들을 먼저 정리한다.

### 1.1 C vs C++ 비교 테이블

| 측면 | C | C++17 |
|------|---|-------|
| 메모리 관리 | 수동 (malloc/free) | RAII (생성자/소멸자) + 스마트 포인터 |
| 문자열 | `char*` (널 종료) | `std::string` (자동 메모리 관리) |
| 배열 | 고정 크기 또는 malloc | `std::vector<T>` (동적 확장) |
| 해시 테이블 | 직접 구현 또는 라이브러리 | `std::unordered_map<K,V>` |
| 함수 포인터 | `void (*func)(int)` | `std::function<void(int)>` + 람다 |
| 에러 처리 | 리턴 코드 또는 errno | 예외 (`try/catch/throw`) |
| 네임스페이스 | 없음 (prefix로 해결) | `namespace` |
| 제네릭 | 매크로 또는 void* | 템플릿 `template<typename T>` |
| 동시성 | pthread | `std::thread`, `std::mutex` |
| NULL | `NULL` (매크로) | `nullptr` (타입 안전) |

---

## 2. RAII: 자동 리소스 관리

RAII (Resource Acquisition Is Initialization)는 C++의 **가장 중요한 패러다임**이다.

**핵심 아이디어**: 리소스 획득은 객체 생성 시, 리소스 해제는 객체 소멸 시.

### 2.1 C 스타일: 수동 관리의 문제점

```c
// C: 파일을 열고 닫는 코드
#include <stdio.h>
#include <stdlib.h>

int process_file(const char* path) {
    FILE* f = fopen(path, "r");
    if (f == NULL) {
        return -1;  // 에러
    }

    char buffer[1024];
    if (fgets(buffer, sizeof(buffer), f) == NULL) {
        fclose(f);  // 잊으면 리소스 누수!
        return -1;
    }

    // 처리 중 에러 발생 시...
    if (some_condition) {
        fclose(f);  // 여기도 닫아야 함!
        return -1;
    }

    // ... 여러 리턴 경로마다 fclose 필요

    fclose(f);  // 정상 종료 시에도 닫아야 함
    return 0;
}
```

**문제점**:
* 모든 리턴 경로에서 `fclose()` 호출 필요
* 하나라도 빼먹으면 리소스 누수
* 복잡한 제어 흐름에서 추적 어려움

### 2.2 C++ 스타일: RAII로 자동 정리

```cpp
// C++: RAII 래퍼 클래스
#include <fstream>
#include <string>

class File {
public:
    // 생성자: 리소스 획득
    explicit File(const std::string& path)
        : stream_(path) {
        if (!stream_.is_open()) {
            throw std::runtime_error("Failed to open file");
        }
    }

    // 소멸자: 리소스 해제 (자동 호출)
    ~File() {
        if (stream_.is_open()) {
            stream_.close();  // 소멸 시 자동으로 닫힘
        }
    }

    // 복사 금지 (파일은 공유하지 않음)
    File(const File&) = delete;
    File& operator=(const File&) = delete;

    std::string readLine() {
        std::string line;
        if (!std::getline(stream_, line)) {
            throw std::runtime_error("Failed to read line");
        }
        return line;
    }

private:
    std::ifstream stream_;
};

int processFile(const std::string& path) {
    try {
        File file(path);  // 생성자에서 파일 열림

        std::string line = file.readLine();

        if (some_condition) {
            return -1;  // File 객체 소멸 → 자동으로 닫힘!
        }

        // ... 어떤 경로로 리턴해도 자동 정리

        return 0;
    } catch (const std::exception& e) {
        // 예외 발생해도 File 소멸자 호출됨
        return -1;
    }
    // 여기서도 File 소멸자 자동 호출
}
```

**장점**:
* 소멸자가 **자동으로** 호출됨 (스택 언와인딩)
* 예외 발생 시에도 안전
* 리소스 누수 원천 차단

---

## 3. 스마트 포인터: 자동 메모리 관리

C의 `malloc/free` 대신 **스마트 포인터**를 사용한다.

### 3.1 std::unique_ptr (단독 소유권)

**개념**: 하나의 포인터만 객체를 소유. 소멸 시 자동 delete.

**C 스타일**:
```c
// C: 수동 메모리 관리
typedef struct {
    char* player_id;
    double x, y;
} PlayerState;

PlayerState* create_player(const char* id) {
    PlayerState* p = (PlayerState*)malloc(sizeof(PlayerState));
    p->player_id = strdup(id);
    p->x = 0.0;
    p->y = 0.0;
    return p;
}

void destroy_player(PlayerState* p) {
    if (p != NULL) {
        free(p->player_id);
        free(p);
    }
}

int main() {
    PlayerState* p = create_player("player1");

    // ... 사용

    destroy_player(p);  // 잊으면 누수!
    return 0;
}
```

**C++ 스타일**:
```cpp
// C++: std::unique_ptr
#include <memory>
#include <string>

struct PlayerState {
    std::string player_id;  // 자동 메모리 관리
    double x{0.0};
    double y{0.0};
};

std::unique_ptr<PlayerState> createPlayer(const std::string& id) {
    auto p = std::make_unique<PlayerState>();
    p->player_id = id;
    p->x = 0.0;
    p->y = 0.0;
    return p;  // 소유권 이동
}

int main() {
    auto p = createPlayer("player1");

    // ... 사용

    // 소멸자 자동 호출, delete 자동!
    return 0;
}
```

**핵심**:
* `std::make_unique<T>()`: 객체 생성 + unique_ptr 반환
* 스코프 벗어나면 **자동 delete**
* 복사 불가, 이동만 가능 (`std::move`)

### 3.2 std::shared_ptr (공유 소유권)

**개념**: 여러 포인터가 하나의 객체를 공유. 마지막 포인터 소멸 시 delete.

```cpp
#include <memory>
#include <iostream>

class GameSession {
public:
    GameSession(int id) : id_(id) {
        std::cout << "GameSession " << id_ << " created\n";
    }

    ~GameSession() {
        std::cout << "GameSession " << id_ << " destroyed\n";
    }

private:
    int id_;
};

int main() {
    std::shared_ptr<GameSession> session1 = std::make_shared<GameSession>(1);

    {
        std::shared_ptr<GameSession> session2 = session1;  // 참조 카운트 2

        std::cout << "Use count: " << session1.use_count() << "\n";  // 2

    }  // session2 소멸 → 참조 카운트 1

    std::cout << "Use count: " << session1.use_count() << "\n";  // 1

    // main 종료 시 session1 소멸 → 참조 카운트 0 → GameSession 자동 delete
}
```

**언제 사용?**
* `unique_ptr`: 명확한 소유권 (기본 선택)
* `shared_ptr`: 여러 곳에서 참조 (필요할 때만)

---

## 4. STL 컨테이너: 동적 자료구조

### 4.1 std::vector (동적 배열)

**C 스타일**:
```c
// C: realloc로 동적 배열
typedef struct {
    int* data;
    size_t size;
    size_t capacity;
} Vector;

void vector_push_back(Vector* v, int value) {
    if (v->size >= v->capacity) {
        v->capacity = v->capacity == 0 ? 1 : v->capacity * 2;
        v->data = (int*)realloc(v->data, v->capacity * sizeof(int));
    }
    v->data[v->size++] = value;
}

void vector_free(Vector* v) {
    free(v->data);
    v->data = NULL;
    v->size = v->capacity = 0;
}
```

**C++ 스타일**:
```cpp
#include <vector>

int main() {
    std::vector<int> vec;  // 빈 벡터

    vec.push_back(10);  // 자동 확장
    vec.push_back(20);
    vec.push_back(30);

    std::cout << "Size: " << vec.size() << "\n";  // 3

    // 범위 기반 for (C++11)
    for (int val : vec) {
        std::cout << val << " ";
    }

    // 인덱스 접근
    vec[0] = 100;

    // 자동 메모리 해제 (소멸자)
}
```

**핵심**:
* `push_back()`: 끝에 추가, 자동 확장
* `size()`, `capacity()`: 크기/용량
* 범위 기반 for: `for (auto& item : vec)`
* 소멸자에서 자동 메모리 해제

### 4.2 std::string (문자열)

**C 스타일**:
```c
// C: char* + strlen/strcpy
char* concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    strcpy(result, a);
    strcat(result, b);
    return result;  // 호출자가 free 해야 함!
}
```

**C++ 스타일**:
```cpp
#include <string>

std::string concat(const std::string& a, const std::string& b) {
    return a + b;  // 연산자 오버로딩
}

int main() {
    std::string player_id = "player1";

    player_id += "_suffix";  // 자동 확장

    std::cout << "ID: " << player_id << "\n";
    std::cout << "Length: " << player_id.size() << "\n";

    // 서브스트링
    std::string prefix = player_id.substr(0, 6);  // "player"

    // 비교
    if (player_id == "player1_suffix") {
        std::cout << "Match!\n";
    }

    // 자동 메모리 해제
}
```

### 4.3 std::unordered_map (해시 테이블)

GameSession에서 플레이어를 player_id로 조회할 때 사용.

```cpp
#include <unordered_map>
#include <string>

struct PlayerState {
    std::string player_id;
    double x, y;
    int health;
};

class GameSession {
public:
    void addPlayer(const std::string& id) {
        PlayerState state;
        state.player_id = id;
        state.x = 100.0;
        state.y = 200.0;
        state.health = 100;

        players_[id] = state;  // O(1) 삽입
    }

    PlayerState* getPlayer(const std::string& id) {
        auto it = players_.find(id);  // O(1) 조회
        if (it == players_.end()) {
            return nullptr;
        }
        return &it->second;
    }

    void removePlayer(const std::string& id) {
        players_.erase(id);  // O(1) 삭제
    }

    size_t playerCount() const {
        return players_.size();
    }

private:
    std::unordered_map<std::string, PlayerState> players_;
};
```

**핵심**:
* `players_[key]`: 삽입/조회 (없으면 생성)
* `find(key)`: 조회 (없으면 `end()`)
* `erase(key)`: 삭제

---

## 5. 람다 표현식: 익명 함수

C의 함수 포인터보다 훨씬 강력하다.

### 5.1 기본 문법

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9};

    // 람다: [캡처](매개변수) { 본문 }
    std::sort(numbers.begin(), numbers.end(),
        [](int a, int b) {
            return a < b;  // 오름차순
        });

    for (int n : numbers) {
        std::cout << n << " ";  // 1 2 5 8 9
    }
}
```

### 5.2 캡처 (Capture)

외부 변수를 람다 내부에서 사용하려면 **캡처**해야 한다.

```cpp
int threshold = 5;

auto is_above_threshold = [threshold](int value) {
    return value > threshold;
};

std::cout << is_above_threshold(3) << "\n";  // 0 (false)
std::cout << is_above_threshold(7) << "\n";  // 1 (true)
```

**캡처 방식**:
* `[threshold]`: 값 복사 (const)
* `[&threshold]`: 참조 (변경 가능)
* `[=]`: 모든 외부 변수 값 복사
* `[&]`: 모든 외부 변수 참조
* `[this]`: 클래스 멤버 접근

### 5.3 실전 예: 콜백

```cpp
#include <functional>
#include <iostream>

class GameLoop {
public:
    using TickCallback = std::function<void(int tick)>;

    void setCallback(TickCallback callback) {
        callback_ = callback;
    }

    void runTicks(int count) {
        for (int i = 0; i < count; i++) {
            if (callback_) {
                callback_(i);  // 콜백 호출
            }
        }
    }

private:
    TickCallback callback_;
};

int main() {
    GameLoop loop;

    int total = 0;

    // 람다를 콜백으로 등록
    loop.setCallback([&total](int tick) {
        std::cout << "Tick " << tick << "\n";
        total += tick;
    });

    loop.runTicks(5);

    std::cout << "Total: " << total << "\n";  // 0+1+2+3+4 = 10
}
```

---

## 6. std::thread와 std::mutex: 멀티스레딩

### 6.1 기본 스레드 생성

```cpp
#include <iostream>
#include <thread>
#include <chrono>

void worker(int id) {
    for (int i = 0; i < 3; i++) {
        std::cout << "Thread " << id << " tick " << i << "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);

    t1.join();  // 대기
    t2.join();

    std::cout << "All threads done\n";
}
```

### 6.2 std::mutex로 데이터 보호

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::mutex mutex;
int counter = 0;

void increment() {
    for (int i = 0; i < 1000; i++) {
        std::lock_guard<std::mutex> lock(mutex);  // RAII 잠금
        counter++;
    }  // 스코프 벗어나면 자동 unlock
}

int main() {
    std::vector<std::thread> threads;

    for (int i = 0; i < 10; i++) {
        threads.emplace_back(increment);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Counter: " << counter << "\n";  // 10000 (보장)
}
```

**핵심**:
* `std::lock_guard`: RAII로 자동 lock/unlock
* `std::mutex`: 뮤텍스 (상호 배제)

### 6.3 std::atomic (원자적 연산)

간단한 카운터는 `std::atomic`으로 더 효율적.

```cpp
#include <atomic>
#include <thread>
#include <vector>

std::atomic<int> counter{0};

void increment() {
    for (int i = 0; i < 1000; i++) {
        counter++;  // 원자적 증가
    }
}

int main() {
    std::vector<std::thread> threads;

    for (int i = 0; i < 10; i++) {
        threads.emplace_back(increment);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Counter: " << counter << "\n";  // 10000
}
```

---

## 7. 예외 처리

### 7.1 try/catch/throw

```cpp
#include <stdexcept>
#include <iostream>

double divide(double a, double b) {
    if (b == 0.0) {
        throw std::invalid_argument("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        double result = divide(10.0, 0.0);
        std::cout << "Result: " << result << "\n";
    } catch (const std::invalid_argument& e) {
        std::cerr << "Error: " << e.what() << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Unexpected error: " << e.what() << "\n";
    }
}
```

### 7.2 RAII와 예외 안전성

예외가 발생해도 소멸자는 호출된다.

```cpp
#include <fstream>
#include <iostream>

void processFile(const std::string& path) {
    std::ifstream file(path);  // RAII

    if (!file.is_open()) {
        throw std::runtime_error("Cannot open file");
    }

    // ... 처리 중 예외 발생 가능

    // file 소멸자 자동 호출 (예외 발생해도)
}

int main() {
    try {
        processFile("data.txt");
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
    }
    // 파일은 이미 닫혔음
}
```

---

## 8. 실전 예제: GameSession 구현

이제 배운 내용을 종합해 GameSession을 구현한다.

```cpp
// game_session.h
#pragma once

#include <string>
#include <unordered_map>
#include <vector>
#include <mutex>
#include <cmath>

struct MovementInput {
    uint64_t sequence;
    bool up, down, left, right;
    double mouse_x, mouse_y;
};

struct PlayerState {
    std::string player_id;
    double x{100.0};
    double y{200.0};
    double facing_radians{0.0};
    uint64_t last_sequence{0};
    int health{100};
    bool is_alive{true};
};

class GameSession {
public:
    explicit GameSession(double speed = 5.0)
        : speed_per_second_(speed) {}

    void upsertPlayer(const std::string& player_id) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (players_.find(player_id) != players_.end()) {
            return;  // 이미 존재
        }

        PlayerState state;
        state.player_id = player_id;
        players_[player_id] = state;
    }

    void removePlayer(const std::string& player_id) {
        std::lock_guard<std::mutex> lock(mutex_);
        players_.erase(player_id);
    }

    void applyInput(const std::string& player_id,
                   const MovementInput& input,
                   double delta_seconds) {
        std::lock_guard<std::mutex> lock(mutex_);

        auto it = players_.find(player_id);
        if (it == players_.end()) {
            return;
        }

        auto& state = it->second;

        // 시퀀스 체크
        if (input.sequence <= state.last_sequence) {
            return;
        }
        state.last_sequence = input.sequence;

        // 이동 벡터
        double dx = 0.0, dy = 0.0;
        if (input.right) dx += 1.0;
        if (input.left)  dx -= 1.0;
        if (input.down)  dy += 1.0;
        if (input.up)    dy -= 1.0;

        // 정규화
        double magnitude = std::sqrt(dx * dx + dy * dy);
        if (magnitude > 0.0) {
            dx /= magnitude;
            dy /= magnitude;
        }

        // 위치 업데이트
        double distance = speed_per_second_ * delta_seconds;
        state.x += dx * distance;
        state.y += dy * distance;

        // 에임 방향
        double aim_dx = input.mouse_x - state.x;
        double aim_dy = input.mouse_y - state.y;
        state.facing_radians = std::atan2(aim_dy, aim_dx);
    }

    void tick(uint64_t tick, double delta_seconds) {
        std::lock_guard<std::mutex> lock(mutex_);
        // 나중에 발사체 업데이트 등 추가
    }

    std::vector<PlayerState> snapshot() const {
        std::lock_guard<std::mutex> lock(mutex_);

        std::vector<PlayerState> states;
        states.reserve(players_.size());

        for (const auto& [id, state] : players_) {
            states.push_back(state);
        }

        return states;
    }

private:
    double speed_per_second_;

    mutable std::mutex mutex_;
    std::unordered_map<std::string, PlayerState> players_;
};
```

**테스트 코드**:
```cpp
// main.cpp
#include <iostream>
#include "game_session.h"

int main() {
    GameSession session(5.0);

    // 플레이어 추가
    session.upsertPlayer("player1");
    session.upsertPlayer("player2");

    // 입력 시뮬레이션
    MovementInput input;
    input.sequence = 1;
    input.up = true;
    input.mouse_x = 150.0;
    input.mouse_y = 100.0;

    session.applyInput("player1", input, 1.0 / 60.0);

    // 틱 실행
    for (int i = 0; i < 60; i++) {
        session.tick(i, 1.0 / 60.0);
    }

    // 상태 출력
    auto states = session.snapshot();
    for (const auto& state : states) {
        std::cout << "Player: " << state.player_id << "\n";
        std::cout << "  Position: (" << state.x << ", " << state.y << ")\n";
        std::cout << "  Facing: " << state.facing_radians << "\n";
    }

    return 0;
}
```

---

## 9. 통과 체크리스트

Stage 1을 완료했는지 확인:

* [ ] `auto`, `nullptr`, range-based for를 이해하고 사용할 수 있다.
* [ ] `std::unique_ptr`, `std::shared_ptr`로 메모리를 관리하고, 소멸자에서 자동 정리되는 것을 확인했다.
* [ ] `std::vector`, `std::unordered_map`, `std::string`을 사용해 동적 컨테이너를 다룰 수 있다.
* [ ] 람다 표현식과 `std::function`을 사용해 콜백을 구현할 수 있다.
* [ ] `std::thread`와 `std::mutex`로 간단한 멀티스레드 프로그램을 작성하고 데이터 레이스를 방지할 수 있다.
* [ ] `try/catch`로 예외를 처리하고, RAII로 리소스 누수를 방지할 수 있다.
* [ ] GameSession 클래스를 작성하고, 입력 적용 및 틱 업데이트를 구현했다.

---

## 10. 다음 단계

**문서 3**에서 Boost.Asio 비동기 I/O와 WebSocket을 배운다.
