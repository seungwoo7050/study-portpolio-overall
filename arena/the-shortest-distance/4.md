# 문서 4. 빌드 시스템과 실전 통합

> 이 문서는 **Stage 3 - 전체 통합 (매치메이킹, 통계, DB, 메트릭)**을 채우는 문서다.

---

## 0. 전제 / 목표

### 전제

* 문서 2, 3 완료 (C++17, Boost.Asio, WebSocket)
* 동기 GameSession + 비동기 WebSocketServer 구현 완료

### 이 문서의 목표

* **CMake**로 프로젝트 빌드 시스템 구축
* **PostgreSQL** 연동 (libpq)
* **Prometheus** 메트릭 노출
* 전투/매치메이킹/통계 **전체 통합**

최종 목표:

* 전체 플로우 동작 (접속 → 매칭 → 게임 → 통계)
* 프로덕션급 빌드 시스템
* 모니터링 가능한 서버

---

## 1. CMake 빌드 시스템

### 1.1 기본 CMakeLists.txt

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(Arena60 VERSION 1.0 LANGUAGES CXX)

# C++17 표준
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Boost 찾기
find_package(Boost 1.82 REQUIRED COMPONENTS system)

# PostgreSQL 찾기
find_package(PostgreSQL REQUIRED)

# 소스 파일
set(SOURCES
    src/main.cpp
    src/core/config.cpp
    src/core/game_loop.cpp
    src/game/game_session.cpp
    src/game/combat.cpp
    src/game/projectile.cpp
    src/network/websocket_server.cpp
    src/network/metrics_http_server.cpp
    src/matchmaking/matchmaker.cpp
    src/matchmaking/match_queue.cpp
    src/stats/player_profile_service.cpp
    src/stats/leaderboard_store.cpp
    src/storage/postgres_storage.cpp
)

# 실행 파일
add_executable(arena60_server ${SOURCES})

# 인클루드 경로
target_include_directories(arena60_server
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/include
        ${Boost_INCLUDE_DIRS}
        ${PostgreSQL_INCLUDE_DIRS}
)

# 라이브러리 링크
target_link_libraries(arena60_server
    PRIVATE
        Boost::system
        ${PostgreSQL_LIBRARIES}
        pthread
)

# 컴파일 옵션
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_options(arena60_server PRIVATE -Wall -Wextra -g)
else()
    target_compile_options(arena60_server PRIVATE -O3 -DNDEBUG)
endif()
```

### 1.2 빌드 명령

```bash
# 빌드 디렉토리 생성
mkdir build
cd build

# CMake 설정 (Release)
cmake .. -DCMAKE_BUILD_TYPE=Release

# 빌드
make -j$(nproc)

# 실행
./arena60_server
```

---

## 2. PostgreSQL 연동

### 2.1 PostgresStorage 구현

```cpp
// include/arena60/storage/postgres_storage.h
#pragma once

#include <libpq-fe.h>
#include <string>
#include <memory>
#include <atomic>

class PostgresStorage {
public:
    explicit PostgresStorage(std::string dsn);
    ~PostgresStorage();

    bool connect();
    bool isConnected() const;

    bool recordSessionEvent(const std::string& player_id,
                           const std::string& event);

    std::string metricsSnapshot() const;

private:
    struct ConnDeleter {
        void operator()(PGconn* conn) {
            if (conn) PQfinish(conn);
        }
    };

    std::string dsn_;
    std::unique_ptr<PGconn, ConnDeleter> connection_;
    std::atomic<double> last_query_seconds_{0.0};
};
```

```cpp
// src/storage/postgres_storage.cpp
#include "arena60/storage/postgres_storage.h"
#include <iostream>
#include <chrono>

PostgresStorage::PostgresStorage(std::string dsn)
    : dsn_(std::move(dsn)) {}

PostgresStorage::~PostgresStorage() = default;

bool PostgresStorage::connect() {
    connection_.reset(PQconnectdb(dsn_.c_str()));

    if (PQstatus(connection_.get()) != CONNECTION_OK) {
        std::cerr << "PostgreSQL connection failed: "
                  << PQerrorMessage(connection_.get()) << std::endl;
        connection_.reset();
        return false;
    }

    std::cout << "PostgreSQL connected" << std::endl;
    return true;
}

bool PostgresStorage::isConnected() const {
    return connection_ && PQstatus(connection_.get()) == CONNECTION_OK;
}

bool PostgresStorage::recordSessionEvent(const std::string& player_id,
                                        const std::string& event) {
    if (!isConnected()) {
        return false;
    }

    const char* params[2] = {player_id.c_str(), event.c_str()};

    const char* query =
        "INSERT INTO session_events(player_id, event_type, created_at) "
        "VALUES($1, $2, NOW())";

    auto start = std::chrono::steady_clock::now();

    auto result = PQexecParams(connection_.get(), query, 2, nullptr,
                              params, nullptr, nullptr, 0);

    auto end = std::chrono::steady_clock::now();
    last_query_seconds_ =
        std::chrono::duration<double>(end - start).count();

    bool success = (PQresultStatus(result) == PGRES_COMMAND_OK);
    PQclear(result);

    return success;
}

std::string PostgresStorage::metricsSnapshot() const {
    std::ostringstream oss;
    oss << "# TYPE database_query_duration_seconds gauge\n";
    oss << "database_query_duration_seconds " << last_query_seconds_ << "\n";
    return oss.str();
}
```

### 2.2 데이터베이스 스키마

```sql
-- schema.sql
CREATE TABLE session_events (
    id SERIAL PRIMARY KEY,
    player_id VARCHAR(255) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_session_events_player_id ON session_events(player_id);
CREATE INDEX idx_session_events_created_at ON session_events(created_at);
```

---

## 3. Prometheus 메트릭

### 3.1 메트릭 형식 (Exposition Format)

```cpp
// include/arena60/network/metrics_http_server.h
#pragma once

#include <boost/asio.hpp>
#include <string>
#include <functional>

class MetricsHttpServer {
public:
    using RequestHandler = std::function<std::string(
        const std::string& method,
        const std::string& path)>;

    MetricsHttpServer(boost::asio::io_context& io,
                     uint16_t port,
                     RequestHandler handler);

    void start();
    void stop();

private:
    void doAccept();

    boost::asio::io_context& io_;
    boost::asio::ip::tcp::acceptor acceptor_;
    RequestHandler handler_;
};
```

### 3.2 메트릭 집계

```cpp
// main.cpp에서
std::string buildMetrics(
    const GameLoop& loop,
    const GameSession& session,
    const Matchmaker& matchmaker,
    const PlayerProfileService& profile_service,
    const PostgresStorage& storage) {

    std::ostringstream oss;

    // GameLoop 메트릭
    oss << loop.prometheusSnapshot();

    // GameSession 메트릭
    oss << session.metricsSnapshot();

    // Matchmaker 메트릭
    oss << matchmaker.metricsSnapshot();

    // ProfileService 메트릭
    oss << profile_service.metricsSnapshot();

    // PostgreSQL 메트릭
    oss << storage.metricsSnapshot();

    return oss.str();
}

int main() {
    // ...

    MetricsHttpServer metrics_server(io, 9090, [&](auto method, auto path) {
        if (path == "/metrics") {
            return buildMetrics(loop, session, matchmaker, profile_service, storage);
        }
        return std::string("HTTP/1.1 404 Not Found\r\n\r\n");
    });

    metrics_server.start();

    // ...
}
```

### 3.3 메트릭 예시

```
# TYPE game_tick_rate gauge
game_tick_rate 60.02

# TYPE game_tick_duration_seconds gauge
game_tick_duration_seconds 0.002156

# TYPE projectiles_active gauge
projectiles_active 8

# TYPE projectiles_spawned_total counter
projectiles_spawned_total 145

# TYPE matchmaking_queue_size gauge
matchmaking_queue_size 3

# TYPE matchmaking_matches_total counter
matchmaking_matches_total 42
```

---

## 4. 전투 시스템 통합

### 4.1 Projectile 클래스

```cpp
// include/arena60/game/projectile.h
#pragma once

#include <string>

class Projectile {
public:
    static constexpr double kSpeed = 30.0;      // m/s
    static constexpr double kLifetime = 1.5;    // 초
    static constexpr double kRadius = 0.2;      // 미터

    Projectile(std::string id, std::string owner_id,
              double x, double y, double dir_x, double dir_y,
              double spawn_time);

    void advance(double delta_seconds);
    bool isExpired(double elapsed_time) const;

    std::string id() const { return id_; }
    std::string ownerId() const { return owner_id_; }
    double x() const { return x_; }
    double y() const { return y_; }
    bool isActive() const { return active_; }
    void deactivate() { active_ = false; }

private:
    std::string id_;
    std::string owner_id_;
    double x_, y_;
    double dir_x_, dir_y_;
    double spawn_time_;
    bool active_{true};
};
```

### 4.2 GameSession 확장 (발사체 + 충돌)

```cpp
void GameSession::tick(uint64_t tick, double delta_seconds) {
    std::lock_guard<std::mutex> lock(mutex_);

    elapsed_time_ += delta_seconds;

    // 발사체 업데이트
    updateProjectilesLocked(tick, delta_seconds);
}

void GameSession::updateProjectilesLocked(uint64_t tick, double delta_seconds) {
    // 1. 발사체 이동
    for (auto& proj : projectiles_) {
        if (proj.isActive()) {
            proj.advance(delta_seconds);
        }
    }

    // 2. 만료 제거
    auto remove_it = std::remove_if(
        projectiles_.begin(), projectiles_.end(),
        [this](const Projectile& p) {
            return !p.isActive() || p.isExpired(elapsed_time_);
        });
    projectiles_.erase(remove_it, projectiles_.end());

    // 3. 충돌 감지
    constexpr double kPlayerRadius = 0.5;
    const double radius_sum = Projectile::kRadius + kPlayerRadius;
    const double radius_sum_sq = radius_sum * radius_sum;

    for (auto& proj : projectiles_) {
        if (!proj.isActive()) continue;

        for (auto& [player_id, runtime] : players_) {
            if (!runtime.state.is_alive) continue;
            if (proj.ownerId() == player_id) continue;

            double dx = proj.x() - runtime.state.x;
            double dy = proj.y() - runtime.state.y;
            double dist_sq = dx * dx + dy * dy;

            collisions_checked_total_++;

            if (dist_sq <= radius_sum_sq) {
                handleCollision(proj, runtime, tick);
                proj.deactivate();
                break;
            }
        }
    }

    // 4. 사망 감지
    for (auto& [player_id, runtime] : players_) {
        if (!runtime.state.is_alive && !runtime.death_announced) {
            CombatEvent death_event;
            death_event.type = CombatEventType::Death;
            death_event.target_id = player_id;
            death_event.tick = tick;

            pending_deaths_.push_back(death_event);
            combat_log_.append(death_event);

            runtime.death_announced = true;
            runtime.deaths++;
            players_dead_total_++;
        }
    }
}
```

---

## 5. 매치메이킹 통합

### 5.1 Matchmaker 타이머

```cpp
// main.cpp에서
class MatchmakerTimer {
public:
    MatchmakerTimer(boost::asio::io_context& io,
                   Matchmaker& matchmaker)
        : timer_(io),
          matchmaker_(matchmaker) {
        schedule();
    }

private:
    void schedule() {
        timer_.expires_after(std::chrono::milliseconds(200));

        timer_.async_wait([this](boost::system::error_code ec) {
            if (!ec) {
                auto now = std::chrono::steady_clock::now();
                matchmaker_.runMatching(now);
                schedule();  // 재스케줄
            }
        });
    }

    boost::asio::steady_timer timer_;
    Matchmaker& matchmaker_;
};
```

### 5.2 매치 생성 콜백

```cpp
matchmaker.setMatchCreatedCallback([&](const Match& match) {
    std::cout << "Match created: " << match.matchId()
              << " players: " << match.players()[0]
              << " vs " << match.players()[1] << std::endl;

    // 게임 세션에 플레이어 추가 (이미 추가됨)
    // 또는 별도 GameSession 인스턴스 생성 (실전)
});
```

---

## 6. 전체 main.cpp

```cpp
#include <iostream>
#include <boost/asio.hpp>

#include "arena60/core/config.h"
#include "arena60/core/game_loop.h"
#include "arena60/game/game_session.h"
#include "arena60/network/websocket_server.h"
#include "arena60/network/metrics_http_server.h"
#include "arena60/matchmaking/matchmaker.h"
#include "arena60/matchmaking/match_queue.h"
#include "arena60/stats/player_profile_service.h"
#include "arena60/stats/leaderboard_store.h"
#include "arena60/storage/postgres_storage.h"

int main() {
    try {
        // 1. 설정 로드
        auto config = GameConfig::fromEnv();

        std::cout << "Arena60 Server\n";
        std::cout << "  Port: " << config.port() << "\n";
        std::cout << "  Metrics: " << config.metricsPort() << "\n";
        std::cout << "  Tick rate: " << config.tickRate() << " Hz\n";

        // 2. 코어 시스템
        boost::asio::io_context io;

        GameSession session(config.tickRate());
        GameLoop loop(config.tickRate());

        PostgresStorage storage(config.databaseDSN());
        storage.connect();

        // 3. 매치메이킹
        auto queue = std::make_shared<InMemoryMatchQueue>();
        Matchmaker matchmaker(queue);

        // 4. 통계 & 순위
        auto leaderboard = std::make_shared<InMemoryLeaderboardStore>();
        PlayerProfileService profile_service(leaderboard);

        // 5. WebSocket 서버
        WebSocketServer ws_server(io, config.port(), session, loop);

        ws_server.setLifecycleHandlers(
            // on_join
            [&](const std::string& player_id) {
                session.upsertPlayer(player_id);
                
                MatchRequest request(player_id, 1200,
                    std::chrono::steady_clock::now());
                matchmaker.enqueue(request);
                
                storage.recordSessionEvent(player_id, "join");
            },
            // on_leave
            [&](const std::string& player_id) {
                matchmaker.cancel(player_id);
                session.removePlayer(player_id);
                
                storage.recordSessionEvent(player_id, "leave");
            }
        );

        ws_server.setMatchCompletedCallback([&](const MatchResult& result) {
            profile_service.recordMatch(result);
        });

        // 6. 매치메이킹 타이머
        MatchmakerTimer mm_timer(io, matchmaker);

        matchmaker.setMatchCreatedCallback([](const Match& match) {
            std::cout << "Match: " << match.matchId() << std::endl;
        });

        // 7. 메트릭 서버
        MetricsHttpServer metrics_server(io, config.metricsPort(),
            [&](auto method, auto path) {
                if (path == "/metrics") {
                    return buildMetrics(loop, session, matchmaker,
                                      profile_service, storage);
                }
                return std::string("HTTP/1.1 404 Not Found\r\n\r\n");
            });

        // 8. 시작
        ws_server.start();
        metrics_server.start();
        loop.start();

        std::cout << "\nServer running...\n";
        std::cout << "  WebSocket: ws://localhost:" << config.port() << "\n";
        std::cout << "  Metrics: http://localhost:" << config.metricsPort() << "/metrics\n";

        // 9. 이벤트 루프
        io.run();

    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

---

## 7. 실행 및 테스트

### 7.1 빌드

```bash
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
```

### 7.2 PostgreSQL 준비

```bash
# Docker로 PostgreSQL 실행
docker run -d \
  --name arena60-postgres \
  -e POSTGRES_DB=arena60 \
  -e POSTGRES_USER=arena60 \
  -e POSTGRES_PASSWORD=arena60 \
  -p 5432:5432 \
  postgres:15

# 스키마 초기화
psql -h localhost -U arena60 -d arena60 < schema.sql
```

### 7.3 서버 실행

```bash
export ARENA60_DATABASE_DSN="host=localhost port=5432 dbname=arena60 user=arena60 password=arena60"
./arena60_server
```

### 7.4 클라이언트 테스트

```bash
# 플레이어 1 접속
wscat -c ws://localhost:8080

> input player1 0 1 0 0 0 150.0 200.0 0
< state player1 100.0 195.0 0.785 60
```

```bash
# 플레이어 2 접속 (다른 터미널)
wscat -c ws://localhost:8080

> input player2 0 0 1 0 0 100.0 150.0 0
< state player2 100.0 205.0 -0.785 61
```

### 7.5 메트릭 확인

```bash
curl http://localhost:9090/metrics

# 출력:
# game_tick_rate 60.02
# projectiles_active 0
# matchmaking_queue_size 0
# matchmaking_matches_total 1
# ...
```

---

## 8. 통과 체크리스트

* [ ] CMake로 프로젝트를 빌드하고, Boost/PostgreSQL 라이브러리를 링크할 수 있다.
* [ ] PostgreSQL에 연결하고, 세션 이벤트를 파라미터화된 쿼리로 기록할 수 있다.
* [ ] 발사체 물리, 충돌 감지, 데미지 시스템을 구현하고 테스트했다.
* [ ] 매치메이킹 알고리즘을 구현하고, 2명의 플레이어를 매칭할 수 있다.
* [ ] ELO 등급 계산 및 리더보드 업데이트를 구현했다.
* [ ] Prometheus 메트릭을 HTTP /metrics로 노출하고, 브라우저/curl로 확인했다.
* [ ] 전체 플로우 (접속 → 매칭 → 게임 → 사망 → 통계)가 정상 작동하는 것을 확인했다.

---

## 9. 최종 점검

**축하합니다!** Arena60 프로젝트를 처음부터 끝까지 완성했습니다.

이제 할 수 있는 것:
* ✅ C++17 현대 문법 활용
* ✅ Boost.Asio 비동기 I/O
* ✅ WebSocket 실시간 통신
* ✅ 60 TPS 게임 루프
* ✅ 매치메이킹 시스템
* ✅ ELO 등급 시스템
* ✅ PostgreSQL 연동
* ✅ Prometheus 모니터링

**다음 단계 (선택)**:
* 프로토콜 버퍼 (바이너리 직렬화)
* Redis 분산 큐
* Kubernetes 배포
* 클라이언트 예측 & 서버 리컨실리에이션

**설계 문서 참조**:
* `arena/design/mvp-1.0.md` - 기본 서버
* `arena/design/mvp-1.1.md` - 전투 시스템
* `arena/design/mvp-1.2.md` - 매치메이킹
* `arena/design/mvp-1.3.md` - 통계 & 순위
