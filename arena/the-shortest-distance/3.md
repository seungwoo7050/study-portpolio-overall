# 문서 3. Boost.Asio 비동기 I/O와 WebSocket

> 이 문서는 **Stage 2 - Boost.Asio 비동기 I/O + WebSocket 서버**를 채우는 문서다.

---

## 0. 전제 / 목표

### 전제

* 문서 2 완료 (C++17 기초, RAII, 스마트 포인터, STL)
* 동기 방식 GameSession 구현 완료
* 비동기 I/O 개념 (epoll/kqueue 또는 유사)

### 이 문서의 목표

* Boost.Asio **이벤트 루프**(io_context) 이해
* **비동기 패턴** (async_read/write, 콜백 체인) 습득
* Boost.Beast로 **WebSocket 서버** 구현
* GameLoop와 **스레드 안전하게 통합**

최종 목표:

* WebSocket 클라이언트가 입력 전송
* 서버가 60 TPS로 게임 로직 실행
* 모든 클라이언트에 상태 브로드캐스트

---

## 1. 동기 vs 비동기 I/O

### 1.1 C 스타일 동기 I/O (블로킹)

```c
// C: 동기 TCP 서버
int server_fd = socket(AF_INET, SOCK_STREAM, 0);
bind(server_fd, ...);
listen(server_fd, 10);

while (1) {
    int client_fd = accept(server_fd, ...);  // 블로킹: 연결 대기

    char buffer[1024];
    int n = read(client_fd, buffer, sizeof(buffer));  // 블로킹: 데이터 대기

    write(client_fd, buffer, n);  // 블로킹: 쓰기 완료 대기

    close(client_fd);
}
```

**문제점**:
* 한 번에 하나의 클라이언트만 처리
* 블로킹 중에는 다른 작업 불가
* 다중 클라이언트는 멀티스레드 필요 (비효율)

### 1.2 비동기 I/O (논블로킹 + 이벤트 루프)

**개념**:
* I/O 작업 **즉시 리턴** (완료 대기 안 함)
* **콜백** 등록 (완료 시 호출)
* **이벤트 루프**가 완료 이벤트 처리

```text
┌──────────────────────────────────────┐
│         io_context (이벤트 루프)       │
│                                      │
│  1. async_accept 등록                │
│  2. async_read 등록                  │
│  3. async_write 등록                 │
│                                      │
│  → 모든 작업이 비동기로 등록됨        │
│  → io_context.run()이 이벤트 디스패치 │
│  → 완료되면 콜백 호출                 │
└──────────────────────────────────────┘
```

**장점**:
* **단일 스레드**로 수천 개의 연결 처리
* CPU 효율적 (블로킹 없음)
* 확장성 좋음

---

## 2. Boost.Asio 핵심 개념

### 2.1 io_context (이벤트 루프)

**역할**: 모든 비동기 작업을 관리하는 중앙 허브.

```cpp
#include <boost/asio.hpp>
#include <iostream>

int main() {
    boost::asio::io_context io;

    // 타이머 등록 (비동기)
    boost::asio::steady_timer timer(io, std::chrono::seconds(2));

    timer.async_wait([](const boost::system::error_code& ec) {
        if (!ec) {
            std::cout << "Timer expired!\n";
        }
    });

    std::cout << "Timer started, running io_context...\n";

    io.run();  // 이벤트 루프 시작 (블로킹)

    std::cout << "io_context finished\n";

    return 0;
}
```

**출력**:
```
Timer started, running io_context...
Timer expired!
io_context finished
```

**핵심**:
* `io.run()`: 모든 작업이 완료될 때까지 실행
* 작업이 없으면 리턴
* 비동기 작업은 콜백으로 완료 처리

### 2.2 비동기 패턴: 콜백 체인

```cpp
#include <boost/asio.hpp>
#include <iostream>

void onTimer1(const boost::system::error_code& ec,
             boost::asio::steady_timer& timer2) {
    std::cout << "Timer 1 expired\n";

    timer2.expires_after(std::chrono::seconds(1));
    timer2.async_wait([](const boost::system::error_code& ec) {
        std::cout << "Timer 2 expired\n";
    });
}

int main() {
    boost::asio::io_context io;

    boost::asio::steady_timer timer1(io, std::chrono::seconds(1));
    boost::asio::steady_timer timer2(io);

    timer1.async_wait(std::bind(onTimer1,
                                std::placeholders::_1,
                                std::ref(timer2)));

    io.run();
    return 0;
}
```

**출력**:
```
Timer 1 expired
Timer 2 expired
```

---

## 3. TCP 서버 기초

### 3.1 async_accept (비동기 Accept)

```cpp
#include <boost/asio.hpp>
#include <iostream>
#include <memory>

using boost::asio::ip::tcp;

class Server {
public:
    Server(boost::asio::io_context& io, uint16_t port)
        : acceptor_(io, tcp::endpoint(tcp::v4(), port)) {
        doAccept();
    }

private:
    void doAccept() {
        acceptor_.async_accept(
            [this](const boost::system::error_code& ec, tcp::socket socket) {
                if (!ec) {
                    std::cout << "Client connected\n";

                    // 새 소켓 처리 (여기서는 즉시 닫음)
                    socket.close();
                }

                doAccept();  // 다음 연결 대기 (재귀)
            });
    }

    tcp::acceptor acceptor_;
};

int main() {
    boost::asio::io_context io;

    Server server(io, 8080);

    std::cout << "Server listening on port 8080\n";

    io.run();

    return 0;
}
```

**패턴**:
* `async_accept`: 비동기로 연결 대기
* 콜백에서 새 소켓 받음
* `doAccept()` 재호출로 계속 대기

### 3.2 async_read/write (비동기 읽기/쓰기)

```cpp
#include <boost/asio.hpp>
#include <iostream>
#include <memory>
#include <array>

using boost::asio::ip::tcp;

class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket socket)
        : socket_(std::move(socket)) {}

    void start() {
        doRead();
    }

private:
    void doRead() {
        auto self(shared_from_this());  // 생명 연장

        socket_.async_read_some(
            boost::asio::buffer(buffer_),
            [this, self](const boost::system::error_code& ec, std::size_t length) {
                if (!ec) {
                    std::cout << "Received: " << std::string(buffer_.data(), length) << "\n";
                    doWrite(length);
                }
            });
    }

    void doWrite(std::size_t length) {
        auto self(shared_from_this());

        boost::asio::async_write(
            socket_,
            boost::asio::buffer(buffer_, length),
            [this, self](const boost::system::error_code& ec, std::size_t /*length*/) {
                if (!ec) {
                    doRead();  // 다음 읽기
                }
            });
    }

    tcp::socket socket_;
    std::array<char, 1024> buffer_;
};

class Server {
public:
    Server(boost::asio::io_context& io, uint16_t port)
        : acceptor_(io, tcp::endpoint(tcp::v4(), port)) {
        doAccept();
    }

private:
    void doAccept() {
        acceptor_.async_accept(
            [this](const boost::system::error_code& ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<Session>(std::move(socket))->start();
                }
                doAccept();
            });
    }

    tcp::acceptor acceptor_;
};

int main() {
    boost::asio::io_context io;

    Server server(io, 8080);

    std::cout << "Echo server on port 8080\n";

    io.run();

    return 0;
}
```

**핵심**:
* `shared_from_this`: 콜백 내에서 객체 생명 보장
* `async_read_some`: 일부 데이터 읽기
* `async_write`: 전체 데이터 쓰기

---

## 4. Boost.Beast WebSocket

### 4.1 WebSocket Handshake

```cpp
#include <boost/beast.hpp>
#include <boost/asio.hpp>
#include <iostream>
#include <memory>

namespace beast = boost::beast;
namespace websocket = beast::websocket;
using tcp = boost::asio::ip::tcp;

class WebSocketSession : public std::enable_shared_from_this<WebSocketSession> {
public:
    WebSocketSession(tcp::socket socket)
        : ws_(std::move(socket)) {}

    void start() {
        ws_.async_accept(
            [self = shared_from_this()](beast::error_code ec) {
                if (!ec) {
                    std::cout << "WebSocket connected\n";
                    self->doRead();
                }
            });
    }

private:
    void doRead() {
        ws_.async_read(
            buffer_,
            [self = shared_from_this()](beast::error_code ec, std::size_t bytes) {
                if (!ec) {
                    std::cout << "Received: " << beast::buffers_to_string(self->buffer_.data()) << "\n";

                    self->buffer_.consume(self->buffer_.size());
                    self->doRead();
                }
            });
    }

    websocket::stream<tcp::socket> ws_;
    beast::flat_buffer buffer_;
};

class Server {
public:
    Server(boost::asio::io_context& io, uint16_t port)
        : acceptor_(io, tcp::endpoint(tcp::v4(), port)) {
        doAccept();
    }

private:
    void doAccept() {
        acceptor_.async_accept(
            [this](beast::error_code ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<WebSocketSession>(std::move(socket))->start();
                }
                doAccept();
            });
    }

    tcp::acceptor acceptor_;
};

int main() {
    boost::asio::io_context io;

    Server server(io, 8080);

    std::cout << "WebSocket server on ws://localhost:8080\n";

    io.run();

    return 0;
}
```

### 4.2 텍스트 메시지 전송

```cpp
void doWrite(const std::string& message) {
    ws_.text(true);  // 텍스트 모드

    ws_.async_write(
        boost::asio::buffer(message),
        [self = shared_from_this()](beast::error_code ec, std::size_t bytes) {
            if (ec) {
                std::cerr << "Write error: " << ec.message() << "\n";
            }
        });
}
```

---

## 5. GameLoop 통합

### 5.1 별도 스레드에서 GameLoop 실행

```cpp
#include <thread>
#include <chrono>
#include <atomic>
#include <iostream>

class GameLoop {
public:
    explicit GameLoop(double tick_rate)
        : tick_rate_(tick_rate),
          target_delta_(1.0 / tick_rate) {}

    void start() {
        running_ = true;
        thread_ = std::thread(&GameLoop::run, this);
    }

    void stop() {
        running_ = false;
        if (thread_.joinable()) {
            thread_.join();
        }
    }

    void setCallback(std::function<void(uint64_t tick, double delta)> callback) {
        callback_ = callback;
    }

private:
    void run() {
        auto next_frame = std::chrono::steady_clock::now();

        while (running_) {
            auto frame_start = next_frame;
            uint64_t tick = tick_counter_++;

            if (callback_) {
                callback_(tick, target_delta_);
            }

            next_frame += std::chrono::duration_cast<std::chrono::steady_clock::duration>(
                std::chrono::duration<double>(target_delta_));

            std::this_thread::sleep_until(next_frame);
        }
    }

    double tick_rate_;
    double target_delta_;
    std::atomic<bool> running_{false};
    std::thread thread_;
    std::function<void(uint64_t, double)> callback_;
    uint64_t tick_counter_{0};
};
```

### 5.2 WebSocketServer와 GameLoop 통합

```cpp
#include "game_session.h"  // 문서 2의 GameSession

class WebSocketServer {
public:
    WebSocketServer(boost::asio::io_context& io,
                   uint16_t port,
                   GameSession& session,
                   GameLoop& loop)
        : io_(io),
          acceptor_(io, tcp::endpoint(tcp::v4(), port)),
          session_(session),
          loop_(loop) {

        // GameLoop 콜백 등록
        loop_.setCallback([this](uint64_t tick, double delta) {
            broadcastState(tick, delta);
        });

        doAccept();
    }

    void start() {
        loop_.start();
    }

    void stop() {
        loop_.stop();
        acceptor_.close();
    }

private:
    void doAccept() {
        acceptor_.async_accept(
            [this](beast::error_code ec, tcp::socket socket) {
                if (!ec) {
                    auto session = std::make_shared<ClientSession>(
                        std::move(socket), session_, *this);
                    session->start();
                }
                doAccept();
            });
    }

    void broadcastState(uint64_t tick, double delta) {
        auto states = session_.snapshot();

        std::lock_guard<std::mutex> lock(clients_mutex_);

        for (const auto& state : states) {
            auto it = clients_.find(state.player_id);
            if (it == clients_.end()) continue;

            auto client = it->second.lock();
            if (!client) continue;

            std::ostringstream oss;
            oss << "state " << state.player_id << " "
                << state.x << " " << state.y << " "
                << state.facing_radians << " " << tick;

            client->sendMessage(oss.str());
        }
    }

    void registerClient(const std::string& player_id,
                       std::weak_ptr<ClientSession> client) {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        clients_[player_id] = client;
    }

    boost::asio::io_context& io_;
    tcp::acceptor acceptor_;
    GameSession& session_;
    GameLoop& loop_;

    std::mutex clients_mutex_;
    std::unordered_map<std::string, std::weak_ptr<ClientSession>> clients_;
};
```

---

## 6. 전체 통합 예제

```cpp
// main.cpp
#include <iostream>
#include "game_session.h"
#include "game_loop.h"
#include "websocket_server.h"

int main() {
    try {
        boost::asio::io_context io;

        GameSession session(5.0);  // 5 m/s 이동 속도
        GameLoop loop(60.0);       // 60 TPS

        WebSocketServer server(io, 8080, session, loop);

        server.start();

        std::cout << "Server running:\n";
        std::cout << "  WebSocket: ws://localhost:8080\n";
        std::cout << "  Game loop: 60 TPS\n";

        io.run();  // 이벤트 루프 실행

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

**클라이언트 테스트 (wscat)**:
```bash
$ wscat -c ws://localhost:8080

# 입력 전송
> input player1 0 1 0 0 0 150.0 200.0 0

# 상태 수신 (60 Hz)
< state player1 100.0 195.0 0.785 60
< state player1 100.0 190.0 0.785 61
< state player1 100.0 185.0 0.785 62
...
```

---

## 7. 통과 체크리스트

* [ ] `io_context`를 생성하고 `run()`으로 이벤트 루프를 실행할 수 있다.
* [ ] `async_accept`로 TCP 연결을 비동기로 수락하고, 핸들러 체인을 이해한다.
* [ ] Boost.Beast로 WebSocket Handshake를 수행하고, 텍스트 프레임을 주고받을 수 있다.
* [ ] 여러 클라이언트가 동시에 연결해도 서버가 안정적으로 동작하는 것을 확인했다.
* [ ] GameLoop를 별도 스레드에서 실행하고, 틱마다 WebSocket으로 상태를 브로드캐스트할 수 있다.
* [ ] 클라이언트 연결/해제 시 리소스가 올바르게 정리되는 것을 확인했다.

---

## 8. 다음 단계

**문서 4**에서 CMake 빌드 시스템과 전체 통합을 다룬다.
