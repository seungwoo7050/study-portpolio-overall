# 문서 3. React + 프론트엔드 ↔ 백엔드 연동 실전

> 이 문서는 **Stage 1·2의 “React + 연동” 부분**을 채운다.
> Node/Express 기본, `/ping` / `/echo` / `/videos` 정도는 이미 구현되어 있다고 가정한다. (문서 2 참고)

---

## 0. 전제 / 목표

### 전제

* C 개발 경험 있음.
* 문서 2 수준의 JS/TS + Node 이해:

  * `GET /ping`, `POST /echo`, `/videos` 같은 간단 REST API 구현 가능
* 프론트/백엔드가 같은 로컬 머신에서 돌아간다고 가정
  (백엔드: `http://localhost:3000`, 프론트: `http://localhost:5173` 등)

### 이 문서의 목표

**최소 기능 하나를 end-to-end로 완성**하는 것이 목표다.

* React(프론트):

  * 영상 파일 선택 + 업로드 버튼
  * 업로드 진행 상태(`idle` / `uploading` / `processing` / `done` / `error`) 표시
  * 서버에서 생성한 썸네일/클립을 `<img>`, `<video>`로 표시
* Node(백엔드):

  * `/api/upload` 라우트 (업로드 + FFmpeg 처리) – 구현 방향 정의
* TypeScript:

  * 프론트 상태/응답 타입 정의
  * API 호출부 타입 붙이기

실제 시나리오:

1. 브라우저에서 파일 선택
2. `/api/upload`로 POST
3. 서버에서 파일 저장 + FFmpeg로 5초 클립 또는 썸네일 생성
4. JSON 응답
5. 프론트가 결과 URL을 받아 UI에 표시

---

## 1. 전체 구조 (프론트 기준)

### 1.1 디렉터리 예시 (Vite + React + TS 기준)

```text
client/
  package.json
  tsconfig.json
  vite.config.ts
  index.html
  src/
    main.tsx
    App.tsx
    api.ts
    types.ts
    components/
      UploadForm.tsx
      UploadResult.tsx
      VideoList.tsx (선택)
```

* 이 문서에서는 프론트 쪽만 다룬다.
* 백엔드(Node)는 이미 `http://localhost:3000`에서 돌아가고 있다고 가정.

### 1.2 API 계약(Contract) 정의

이 문서는 **백엔드가 다음 API를 제공**한다고 가정하고 진행한다.

1. `GET /ping` → `"pong"` (헬스 체크)
2. `GET /videos` → 업로드된 영상 리스트 (선택)
3. `POST /api/upload` (중요)

`POST /api/upload` 응답 예시(JSON):

```json
{
  "ok": true,
  "videoId": "abc123",
  "originalUrl": "/videos/abc123/original.mp4",
  "clipUrl": "/videos/abc123/clip.mp4",
  "thumbnailUrl": "/videos/abc123/thumbnail.jpg"
}
```

실제 백엔드 구현은 문서 2 + 별도 FFmpeg 문서에서 채운다고 보고,
여기서는 **프론트에서 이 API를 어떻게 소비하는지**에 집중한다.

---

## 2. React / JSX 기초 (보완 섹션)

Stage 1·2에서 실제로 쓰게 될 최소 문법만 정리한다.

### 2-1. JSX 기본 개념

JSX는 “HTML 비슷하게 보이지만, 결국 JS 코드로 컴파일되는 문법 설탕”이다.

```tsx
// JSX
const element = <h1>Hello</h1>;

// 내부적으로 대략 이런 형태로 변환됨
const element2 = React.createElement("h1", null, "Hello");
```

중요 포인트:

* JSX는 **문자열이 아니라 표현식**이다.

  * 변수에 담고, 함수 인자로 넘기고, return 값으로 쓸 수 있다.

---

### 2-2. JSX vs HTML 차이

1. `class` → `className`

```tsx
// X
<div class="box"></div>

// O
<div className="box"></div>
```

2. `for` → `htmlFor`

```tsx
<label htmlFor="file-input">File</label>
<input id="file-input" type="file" />
```

3. self-closing 태그

JSX는 반드시 태그를 닫아야 한다.

```tsx
<input type="file" />        // O
<input type="file"></input>  // 이것도 되긴 함
```

---

### 2-3. JSX에서 style

`style`은 문자열이 아니라 **객체**다.

```tsx
<div style={{ color: "red", fontSize: 16 }}>Text</div>
```

* JS 객체라서, `-` 대신 camelCase 사용 (`background-color` → `backgroundColor`)
* 값은 문자열 또는 number

---

### 2-4. 조건부 렌더링 패턴 2개

1. **일찍 return**

```tsx
if (!video) {
  return <div>Loading...</div>;
}

return <VideoPlayer video={video} />;
```

2. **`&&` 연산자**

```tsx
{error && <div className="error">{error}</div>}
{isUploading && <Spinner />}
```

* `error`가 falsy면 오른쪽 JSX는 렌더링되지 않는다.

이 두 패턴만 알아도 대부분의 단순 조건부 렌더링은 처리 가능하다.

---

### 2-5. `useRef` 기본

DOM에 직접 접근하거나, 렌더 사이에 값 유지할 때 쓴다.

```tsx
import { useRef } from "react";

function VideoPlayer() {
  const videoRef = useRef<HTMLVideoElement | null>(null);

  const handlePlay = () => {
    if (videoRef.current) {
      videoRef.current.play();
    }
  };

  return (
    <div>
      <video ref={videoRef} src="/sample.mp4" />
      <button onClick={handlePlay}>Play</button>
    </div>
  );
}
```

포인트:

* `useRef`는 `{ current: T | null }` 형태의 “박스”를 반환
* `.current`에 넣어둔 값은 컴포넌트가 리렌더되어도 유지
* DOM 조작, 타이머 ID 보관 등에 사용

---

### 2-6. `forwardRef` + `useImperativeHandle`

부모가 자식 컴포넌트 내부 기능을 직접 호출할 수 있게 만드는 패턴.

```tsx
import {
  forwardRef,
  useImperativeHandle,
  useRef,
} from "react";

export interface VideoPlayerRef {
  seekTo: (time: number) => void;
}

interface Props {
  src: string;
}

export const VideoPlayer = forwardRef<VideoPlayerRef, Props>(
  ({ src }, ref) => {
    const videoRef = useRef<HTMLVideoElement | null>(null);

    useImperativeHandle(ref, () => ({
      seekTo(time: number) {
        if (videoRef.current) {
          videoRef.current.currentTime = time;
        }
      },
    }));

    return <video ref={videoRef} src={src} />;
  },
);
```

부모 쪽:

```tsx
const playerRef = useRef<VideoPlayerRef | null>(null);

const jumpTo10 = () => {
  playerRef.current?.seekTo(10);
};

<VideoPlayer ref={playerRef} src="/sample.mp4" />;
<button onClick={jumpTo10}>10초로 이동</button>;
```

타임라인에서 `seekTo()` 같은 API를 제공할 때 이런 패턴을 쓰게 된다.

---

### 2-7. `useEffect` cleanup 패턴

DOM 이벤트 등록/해제의 기본 패턴.

```tsx
import { useEffect, useRef } from "react";

function Player() {
  const videoRef = useRef<HTMLVideoElement | null>(null);

  useEffect(() => {
    const el = videoRef.current;
    if (!el) return;

    const onTimeUpdate = () => {
      console.log("currentTime:", el.currentTime);
    };

    el.addEventListener("timeupdate", onTimeUpdate);

    return () => {
      // cleanup
      el.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, []); // deps

  return <video ref={videoRef} src="/sample.mp4" />;
}
```

패턴:

* 이펙트에서 리스너/타이머 등록
* return 함수에서 해제
* deps 배열에 따라 재실행/정리 시점 결정

---

### 2-8. `useCallback` 기본

함수를 메모이제이션해서, 매 렌더마다 새 함수가 만들어지는 걸 줄이는 용도.

```tsx
import { useCallback } from "react";

interface Props {
  onUploaded: (id: string) => void;
}

function VideoUpload({ onUploaded }: Props) {
  const handleFile = useCallback(
    async (file: File) => {
      const id = await uploadVideo(file);
      onUploaded(id);
    },
    [onUploaded],
  );

  // ...
}
```

* 의존성 배열에 들어간 값이 바뀌지 않으면 동일한 함수 인스턴스 재사용
* `useEffect` 의존성, 자식 컴포넌트에 props로 넘길 때 사용

---

### 2-9. 폼/이벤트 타입 최소 예

React에서 이벤트 타입은 기본적으로 제네릭으로 제공된다.

```tsx
import type {
  ChangeEvent,
  FormEvent,
} from "react";

function NameForm() {
  const [name, setName] = useState("");

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  };

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    console.log("submit:", name);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={name} onChange={handleChange} />
      <button type="submit">Save</button>
    </form>
  );
}
```

이 정도만 알고 있으면, 대부분의 폼/입력 이벤트 타입 에러는 해결 가능하다.

---

## 3. React 프로젝트 기본 (Vite 기준)

### 3.1 프로젝트 생성 (참고용)

Vite + React + TypeScript 예시:

```bash
npm create vite@latest client -- --template react-ts
cd client
npm install
npm run dev
```

브라우저에서 `http://localhost:5173` 접속.

### 3.2 진입점 구조

`src/main.tsx` (기본 템플릿에서 거의 안 건드려도 됨)

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

`App.tsx` 안에 실제 UI를 구성한다.

---

## 4. 타입 정의 & API 모듈

프론트와 백엔드 사이 계약을 TS 타입으로 먼저 고정한다.

### 4.1 `types.ts`

```ts
// 업로드 상태
export type UploadStatus =
  | "idle"
  | "selecting"
  | "uploading"
  | "processing"
  | "done"
  | "error";

// /api/upload 응답
export interface UploadResponse {
  ok: boolean;
  videoId: string;
  originalUrl?: string;
  clipUrl?: string;
  thumbnailUrl?: string;
}

// /videos 리스트 응답 (선택)
export interface VideoMeta {
  id: string;
  title: string;
  duration: number; // seconds
}
```

### 4.2 `api.ts`

```ts
import type { UploadResponse, VideoMeta } from "./types";

const API_BASE = "http://localhost:3000";

export async function ping(): Promise<string> {
  const res = await fetch(`${API_BASE}/ping`);
  if (!res.ok) {
    throw new Error(`ping failed: ${res.status}`);
  }
  return res.text();
}

export async function uploadVideo(file: File): Promise<UploadResponse> {
  const form = new FormData();
  form.append("video", file);

  const res = await fetch(`${API_BASE}/api/upload`, {
    method: "POST",
    body: form,
  });

  if (!res.ok) {
    throw new Error(`upload failed: ${res.status}`);
  }

  const data = (await res.json()) as UploadResponse;
  if (!data.ok) {
    throw new Error("upload response not ok");
  }

  return data;
}

export async function fetchVideos(): Promise<VideoMeta[]> {
  const res = await fetch(`${API_BASE}/videos`);
  if (!res.ok) {
    throw new Error(`fetchVideos failed: ${res.status}`);
  }
  return (await res.json()) as VideoMeta[];
}
```

컴포넌트가 직접 `fetch`를 쓰지 않고, `api.ts`를 통해 호출하게 분리해 두면 코드가 정리된다.

---

## 5. 업로드 상태 관리 컴포넌트

### 5.1 상태 설계

업로드 UI가 가져야 할 상태:

* 현재 선택된 파일 (`File | null`)
* 업로드 진행 상태 (`UploadStatus`)
* 에러 메시지 (`string | null`)
* (결과는 상위 `App`에서 관리)

```ts
import type { UploadStatus, UploadResponse } from "../types";

type UploadFormProps = {
  onUploaded?: (result: UploadResponse) => void;
};
```

### 5.2 `UploadForm` 컴포넌트 (`components/UploadForm.tsx`)

```tsx
import { useState, ChangeEvent, FormEvent } from "react";
import { uploadVideo } from "../api";
import type { UploadStatus, UploadResponse } from "../types";

type UploadFormProps = {
  onUploaded?: (result: UploadResponse) => void;
};

export function UploadForm({ onUploaded }: UploadFormProps) {
  const [file, setFile] = useState<File | null>(null);
  const [status, setStatus] = useState<UploadStatus>("idle");
  const [error, setError] = useState<string | null>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      setFile(null);
      setStatus("idle");
      return;
    }
    setFile(files[0]);
    setStatus("selecting");
    setError(null);
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!file) {
      setError("파일을 선택하세요.");
      return;
    }

    try {
      setStatus("uploading");
      setError(null);

      const result = await uploadVideo(file);

      setStatus("done");
      if (onUploaded) {
        onUploaded(result);
      }
    } catch (err) {
      console.error(err);
      setStatus("error");
      setError("업로드 실패");
    }
  };

  const buttonDisabled =
    status === "uploading" || status === "processing" || !file;

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input type="file" accept="video/*" onChange={handleFileChange} />
      </div>

      <div>
        <button type="submit" disabled={buttonDisabled}>
          {status === "uploading" ? "업로드 중..." : "업로드"}
        </button>
      </div>

      <div>
        <span>상태: {status}</span>
      </div>

      {error && <div style={{ color: "red" }}>{error}</div>}
    </form>
  );
}
```

여기서는 단순화를 위해 `processing` 상태는 시각적으로 따로 표현하지 않았다. 필요하면 백엔드에서 업로드/처리를 분리해도 된다.

---

## 6. 업로드 결과 표시 컴포넌트

### 6.1 `UploadResult` 컴포넌트 (`components/UploadResult.tsx`)

```tsx
import type { UploadResponse } from "../types";

type UploadResultProps = {
  result: UploadResponse | null;
};

export function UploadResult({ result }: UploadResultProps) {
  if (!result) {
    return null;
  }

  const { originalUrl, clipUrl, thumbnailUrl, videoId } = result;

  return (
    <div style={{ marginTop: "16px" }}>
      <h2>업로드 결과</h2>
      <p>videoId: {videoId}</p>

      {thumbnailUrl && (
        <div>
          <h3>썸네일</h3>
          <img src={thumbnailUrl} alt="thumbnail" width={240} />
        </div>
      )}

      {clipUrl && (
        <div>
          <h3>클립 (5초)</h3>
          <video src={clipUrl} controls width={400} />
        </div>
      )}

      {originalUrl && (
        <div>
          <h3>원본</h3>
          <video src={originalUrl} controls width={400} />
        </div>
      )}
    </div>
  );
}
```

단순히 `UploadResponse`에 들어있는 URL들을 `<img>`, `<video>`로 보여주는 역할이다.

---

## 7. 전체 App 구성

### 7.1 `App.tsx`

```tsx
import { useEffect, useState } from "react";
import { ping } from "./api";
import type { UploadResponse } from "./types";
import { UploadForm } from "./components/UploadForm";
import { UploadResult } from "./components/UploadResult";

function App() {
  const [pingResult, setPingResult] = useState<string>("(checking)");
  const [lastUploadResult, setLastUploadResult] =
    useState<UploadResponse | null>(null);

  useEffect(() => {
    ping()
      .then((text) => setPingResult(text))
      .catch((err) => {
        console.error(err);
        setPingResult("error");
      });
  }, []);

  return (
    <div style={{ padding: "16px", fontFamily: "sans-serif" }}>
      <h1>Video Uploader</h1>
      <p>Backend /ping: {pingResult}</p>

      <hr />

      <h2>영상 업로드</h2>
      <UploadForm onUploaded={setLastUploadResult} />

      <UploadResult result={lastUploadResult} />
    </div>
  );
}

export default App;
```

이 상태에서:

1. 백엔드(Node)가 `http://localhost:3000`에서 실행 중이어야 한다.
2. 프론트(Vite)가 `npm run dev`로 실행 중이어야 한다.
3. 업로드 시 `/api/upload`가 응답을 주면 결과가 바로 아래에서 렌더링된다.

---

## 8. 선택: 업로드 이후 리스트 렌더링

실제 서비스라면 “업로드한 영상 전체 리스트” 같은 화면이 필요하다.
문서 2에서 만든 `/videos` API를 붙이면 된다.

### 8.1 `VideoList` 컴포넌트 (`components/VideoList.tsx`)

```tsx
import { useEffect, useState } from "react";
import { fetchVideos } from "../api";
import type { VideoMeta } from "../types";

export function VideoList() {
  const [videos, setVideos] = useState<VideoMeta[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetchVideos()
      .then((data) => {
        setVideos(data);
      })
      .catch((err) => {
        console.error(err);
        setError("영상 목록을 불러오지 못했습니다.");
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  if (loading) {
    return <p>영상 목록 로딩 중...</p>;
  }

  if (error) {
    return <p style={{ color: "red" }}>{error}</p>;
  }

  if (videos.length === 0) {
    return <p>등록된 영상이 없습니다.</p>;
  }

  return (
    <div style={{ marginTop: "16px" }}>
      <h2>영상 목록</h2>
      <ul>
        {videos.map((v) => (
          <li key={v.id}>
            {v.title} ({v.duration}s)
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 8.2 `App.tsx`에 추가

```tsx
import { VideoList } from "./components/VideoList";

// ...
      <UploadResult result={lastUploadResult} />

      <hr />
      <VideoList />
// ...
```

백엔드에서 `/videos`에 업로드 결과를 기록하도록 설계했다면,
새 업로드 후 `VideoList` 갱신 로직을 추가하면 된다(예: “새로고침” 버튼).

---

## 9. React에서 상태/렌더링 모델을 C 관점에서 정리

C 경험자 기준으로, React의 핵심은 **“상태 기반 렌더링”**이다.

* 상태(state)가 바뀌면 컴포넌트 함수가 다시 호출된다고 보면 된다.
* `useState`를 “전역/정적 변수”라 생각하면 틀린다. **렌더링 사이에서 유지되는 값**이다.
* `setState` 호출 → React가 다시 렌더 → JSX 반환 → DOM diff → 필요한 부분만 실제 DOM 갱신.

간단히 대응하면:

| C 개념                               | React 개념                              |
| ---------------------------------- | ------------------------------------- |
| 전역/모듈 상태 + 함수 호출                   | `useState` + 함수형 컴포넌트                 |
| UI 갱신을 직접 그리기 (printf, GUI API 호출) | 상태 변경 → React가 알아서 DOM 패치             |
| 이벤트 핸들러(콜백)                        | `onClick`, `onChange` 등 JSX 속성에 함수 전달 |
| 데이터 구조 배열 반복 출력                    | `array.map()` + JSX 리스트, `key` 필요     |

이 문서에서 작성한 `UploadForm` / `UploadResult` / `VideoList`는:

* 상태(`useState`)를 가지고,
* 이벤트 핸들러(파일 선택, 폼 submit)를 통해 상태를 바꾸고,
* 상태가 바뀔 때마다 JSX(=UI)가 재계산되는 구조로 되어 있다.

---

## 10. Stage 1·2 프론트 측 체크리스트

이 문서 기준으로, 프론트 측에서 아래를 만족하면 Stage 1·2의 “React + 연동”은 최소 수준 통과로 본다.

* [ ] Vite + React + TypeScript를 이용해 기본 프로젝트를 생성하고 실행할 수 있다.
* [ ] `App.tsx`에서 `ping()` API를 호출해 백엔드 `/ping` 결과를 화면에 표시할 수 있다.
* [ ] `UploadForm`처럼, 파일 입력 + 버튼 + 상태 표시를 가진 컴포넌트를 직접 작성할 수 있다.
* [ ] 업로드 상태(`idle` / `uploading` / `done` / `error`)를 유니온 타입으로 관리하고, 상태에 따라 버튼/텍스트 등을 다르게 렌더링할 수 있다.
* [ ] `/api/upload` 결과(JSON)를 `UploadResponse` 타입으로 받고, 썸네일/클립 URL을 `<img>`, `<video>`로 표시할 수 있다.
* [ ] `/videos` 같은 목록 API를 호출해서, 배열을 `map()`으로 렌더링하고 `key`를 적절히 넣을 수 있다.

여기까지가 수정/보완된 문서 3의 범위다.
다음 문서는 C++/FFmpeg C API/애드온으로 내려가는 문서 4다.
