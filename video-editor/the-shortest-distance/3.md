# 문서 3. React + 프론트엔드 ↔ 백엔드 연동 실전

> 이 문서는 **Stage 1·2의 “React + 연동” 부분**을 채운다.
> Node/Express 기본, `/ping` / `/echo` / `/videos` 정도는 이미 구현되어 있다고 가정한다. (문서 2 참고)

---

## 0. 전제 / 목표

### 전제

* C 개발 경험 있음.
* 문서 2 수준의 JS/TS + Node 이해:

  * `GET /ping`, `POST /echo`, `/videos` 같은 간단 REST API 구현 가능
* 프론트/백엔드가 같은 로컬 머신에서 돌아간다고 가정
  (백엔드: `http://localhost:3000`, 프론트: `http://localhost:5173` 등)

### 이 문서의 목표

**최소 기능 하나를 end-to-end로 완성**하는 것이 목표다.

* React(프론트):

  * 영상 파일 선택 + 업로드 버튼
  * 업로드 진행 상태(`idle` / `uploading` / `processing` / `done` / `error`) 표시
  * 서버에서 생성한 썸네일/클립을 `<img>`, `<video>`로 표시
* Node(백엔드):

  * `/api/upload` 라우트 (업로드 + FFmpeg 처리) – 구현 방향 정의
* TypeScript:

  * 프론트 상태/응답 타입 정의
  * API 호출부 타입 붙이기

실제 시나리오:

1. 브라우저에서 파일 선택
2. `/api/upload`로 POST
3. 서버에서 파일 저장 + FFmpeg로 5초 클립 또는 썸네일 생성
4. JSON 응답
5. 프론트가 결과 URL을 받아 UI에 표시

---

## 1. C 프로그래머를 위한 웹 & React 기초

React는 **웹 브라우저에서 동작하는 UI 라이브러리**입니다. C 프로그래머가 React를 배우려면 **웹 기초 개념**을 먼저 이해해야 합니다.

### 1.1 웹 기초: HTML, CSS, DOM

#### 1.1.1 HTML (문서 구조)

**C와 비교**:

```c
// C: printf로 UI 출력
printf("╔═══════════════╗\n");
printf("║ Video Editor  ║\n");
printf("║ [Upload] [X]  ║\n");
printf("╚═══════════════╝\n");
```

**HTML: 선언적 마크업**:

```html
<!-- HTML: 구조를 선언 -->
<div class="container">
  <h1>Video Editor</h1>
  <button>Upload</button>
  <button>×</button>
</div>
```

**주요 HTML 태그**:

```html
<!-- 컨테이너 -->
<div>블록 요소</div>
<span>인라인 요소</span>

<!-- 입력 -->
<input type="file" accept="video/*" />
<input type="text" placeholder="제목" />
<button>업로드</button>

<!-- 미디어 -->
<video src="/sample.mp4" controls></video>
<img src="/thumbnail.jpg" alt="썸네일" />

<!-- 리스트 -->
<ul>
  <li>video1.mp4</li>
  <li>video2.mp4</li>
</ul>
```

#### 1.1.2 CSS (스타일링)

**C GUI 라이브러리와 비교**:

```c
// C (GTK 예시): 코드로 스타일 설정
GtkWidget* button = gtk_button_new_with_label("Upload");
gtk_widget_set_size_request(button, 100, 40);

GdkRGBA color = {0.2, 0.4, 0.8, 1.0};  // RGBA
gtk_widget_override_background_color(button, GTK_STATE_FLAG_NORMAL, &color);
```

**CSS: 선언적 스타일**:

```css
/* CSS: 스타일 시트 */
button {
  width: 100px;
  height: 40px;
  background-color: #3366cc;
  color: white;
  border: none;
  cursor: pointer;
}

button:hover {
  background-color: #2255aa;  /* 마우스 올릴 때 */
}
```

#### 1.1.3 DOM (Document Object Model)

**C 메모리 구조와 비교**:

```c
// C: 트리 구조를 수동으로 관리
typedef struct Node {
    char* tag;
    char* text;
    struct Node** children;
    int child_count;
} Node;

Node* create_node(const char* tag) {
    Node* n = malloc(sizeof(Node));
    n->tag = strdup(tag);
    n->children = NULL;
    n->child_count = 0;
    return n;
}

void add_child(Node* parent, Node* child) {
    parent->children = realloc(parent->children,
                               (parent->child_count + 1) * sizeof(Node*));
    parent->children[parent->child_count++] = child;
}
```

**DOM: 브라우저가 자동 관리**:

```javascript
// JavaScript: DOM API
const div = document.createElement('div');
div.className = 'container';

const button = document.createElement('button');
button.textContent = 'Upload';
button.addEventListener('click', () => {
    console.log('Clicked!');
});

div.appendChild(button);  // C의 add_child와 유사
document.body.appendChild(div);
```

**DOM 트리 구조**:

```
HTML:
<div>
  <h1>Title</h1>
  <button>Upload</button>
</div>

DOM 트리:
div
├─ h1 ("Title")
└─ button ("Upload")
```

### 1.2 JSX: JavaScript 안의 HTML

**C 함수와 비교**:

```c
// C: 문자열로 UI 표현
const char* render_button(const char* label) {
    static char buf[100];
    sprintf(buf, "<button>%s</button>", label);
    return buf;
}
```

**JSX: JavaScript에 HTML 직접 작성**:

```tsx
// JSX: HTML을 JavaScript에 바로 씀
function renderButton(label: string) {
    return <button>{label}</button>;
}

// 사용
const uploadBtn = renderButton("Upload");
```

**변수 사용 (중괄호)**:

```tsx
function VideoInfo({ title, duration }: { title: string; duration: number }) {
    return (
        <div>
            <h2>{title}</h2>
            <p>길이: {duration}초</p>
            <p>분:초 = {Math.floor(duration / 60)}:{duration % 60}</p>
        </div>
    );
}

// 사용
<VideoInfo title="Intro" duration={125} />
```

### 1.3 React 컴포넌트: 재사용 가능한 UI

**C 함수 + 구조체와 비교**:

```c
// C: 구조체 + 렌더링 함수
typedef struct {
    char* id;
    char* title;
    int duration;
} Video;

void render_video_card(Video* video) {
    printf("╔═══════════════╗\n");
    printf("║ %s\n", video->title);
    printf("║ %d초\n", video->duration);
    printf("╚═══════════════╝\n");
}

// 사용
Video v = {"v1", "Intro", 120};
render_video_card(&v);
```

**React 컴포넌트**:

```tsx
// React: 타입 + 컴포넌트 함수
interface VideoCardProps {
    id: string;
    title: string;
    duration: number;
}

function VideoCard({ id, title, duration }: VideoCardProps) {
    return (
        <div className="video-card">
            <h3>{title}</h3>
            <p>{duration}초</p>
        </div>
    );
}

// 사용
<VideoCard id="v1" title="Intro" duration={120} />
```

**컴포넌트 합성**:

```tsx
function VideoList({ videos }: { videos: Video[] }) {
    return (
        <div className="video-list">
            {videos.map(video => (
                <VideoCard key={video.id} {...video} />
            ))}
        </div>
    );
}

// 사용
const videos = [
    { id: "v1", title: "Intro", duration: 120 },
    { id: "v2", title: "Tutorial", duration: 300 }
];

<VideoList videos={videos} />
```

### 1.4 React Hooks: 상태 관리

#### 1.4.1 useState (상태)

**C 전역 변수와 비교**:

```c
// C: 전역 변수 (직접 수정)
typedef enum { IDLE, UPLOADING, PROCESSING, DONE, ERROR } Status;

Status upload_status = IDLE;
int upload_progress = 0;

void start_upload() {
    upload_status = UPLOADING;
    upload_progress = 0;

    // UI를 수동으로 다시 그려야 함!
    redraw_ui();
}
```

**React useState**:

```tsx
import { useState } from 'react';

type UploadStatus = 'idle' | 'uploading' | 'processing' | 'done' | 'error';

function UploadForm() {
    // [현재값, 업데이트함수] = useState(초기값)
    const [status, setStatus] = useState<UploadStatus>('idle');
    const [progress, setProgress] = useState(0);

    const startUpload = () => {
        setStatus('uploading');  // 직접 수정 금지! setter 사용
        setProgress(0);
        // React가 자동으로 UI 재렌더링!
    };

    return (
        <div>
            <p>상태: {status}</p>
            <p>진행: {progress}%</p>
            <button onClick={startUpload}>업로드</button>
        </div>
    );
}
```

**왜 setState를 써야 하는가?**
- **C**: 변수 수정 → `redraw_ui()` 수동 호출
- **React**: `setState` → 자동으로 UI 재렌더링!

#### 1.4.2 useEffect (부수 효과)

**C 초기화/정리와 비교**:

```c
// C: 수동 초기화/정리
int setup_video_player(const char* url) {
    // 1. 초기화
    VideoContext* ctx = malloc(sizeof(VideoContext));
    ctx->url = strdup(url);

    // 2. 리소스 할당
    ctx->decoder = init_decoder(url);

    return ctx;
}

void cleanup_video_player(VideoContext* ctx) {
    // 정리
    close_decoder(ctx->decoder);
    free(ctx->url);
    free(ctx);
}

int main() {
    VideoContext* ctx = setup_video_player("video.mp4");

    // ... 사용

    cleanup_video_player(ctx);
}
```

**React useEffect**:

```tsx
import { useEffect, useState } from 'react';

function VideoPlayer({ videoUrl }: { videoUrl: string }) {
    const [duration, setDuration] = useState(0);

    useEffect(() => {
        // 마운트 시 실행 (초기화)
        console.log('Loading video:', videoUrl);

        const video = document.createElement('video');
        video.src = videoUrl;
        video.onloadedmetadata = () => {
            setDuration(video.duration);
        };

        // 클린업 함수 (정리)
        return () => {
            console.log('Cleanup video:', videoUrl);
            video.src = '';  // 리소스 해제
        };
    }, [videoUrl]);  // videoUrl 변경 시 재실행

    return <div>Duration: {duration}s</div>;
}
```

### 1.5 이벤트 처리

**C 콜백과 비교**:

```c
// C: 함수 포인터로 이벤트 처리
typedef void (*ClickCallback)(void* user_data);

typedef struct {
    ClickCallback on_click;
    void* user_data;
} Button;

void button_clicked(Button* btn) {
    if (btn->on_click) {
        btn->on_click(btn->user_data);
    }
}

// 사용
void handle_upload(void* data) {
    printf("Upload clicked!\n");
}

Button upload_btn = {
    .on_click = handle_upload,
    .user_data = NULL
};
```

**React 이벤트 핸들러**:

```tsx
function UploadButton() {
    const handleClick = () => {
        console.log('Upload clicked!');
    };

    // JSX에서 onClick prop으로 전달
    return <button onClick={handleClick}>Upload</button>;
}

// 또는 인라인
<button onClick={() => console.log('Clicked!')}>Upload</button>
```

**파일 업로드 이벤트**:

```tsx
function FileUploadForm() {
    const [file, setFile] = useState<File | null>(null);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const files = event.target.files;
        if (files && files.length > 0) {
            setFile(files[0]);
        }
    };

    const handleSubmit = async (event: React.FormEvent) => {
        event.preventDefault();  // 기본 동작 방지 (페이지 새로고침 막기)

        if (!file) return;

        // FormData로 파일 전송
        const formData = new FormData();
        formData.append('video', file);

        await fetch('/api/upload', {
            method: 'POST',
            body: formData
        });
    };

    return (
        <form onSubmit={handleSubmit}>
            <input type="file" accept="video/*" onChange={handleFileChange} />
            <button type="submit">Upload</button>
        </form>
    );
}
```

### 1.6 비동기 UI 업데이트 패턴

**C의 동기 처리**:

```c
// C: 동기적으로 처리 (블로킹)
void upload_video(const char* path) {
    printf("Uploading...\n");

    // 업로드 완료까지 대기 (UI 멈춤!)
    int result = upload_file(path);

    if (result == 0) {
        printf("Upload complete!\n");
    } else {
        printf("Upload failed!\n");
    }
}
```

**React 비동기 처리**:

```tsx
function VideoUploader() {
    const [status, setStatus] = useState<'idle' | 'uploading' | 'done' | 'error'>('idle');
    const [progress, setProgress] = useState(0);

    const uploadVideo = async (file: File) => {
        setStatus('uploading');
        setProgress(0);

        try {
            const formData = new FormData();
            formData.append('video', file);

            // 비동기 업로드 (UI 블로킹 안 함!)
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                setStatus('done');
                setProgress(100);
            } else {
                setStatus('error');
            }
        } catch (err) {
            setStatus('error');
        }
    };

    return (
        <div>
            {status === 'uploading' && <p>업로드 중... {progress}%</p>}
            {status === 'done' && <p>완료!</p>}
            {status === 'error' && <p>에러 발생</p>}
        </div>
    );
}
```

---

## 2. 전체 구조 (프론트 기준)

### 2.1 디렉터리 예시 (Vite + React + TS 기준)

```text
client/
  package.json
  tsconfig.json
  vite.config.ts
  index.html
  src/
    main.tsx
    App.tsx
    api.ts
    types.ts
    components/
      UploadForm.tsx
      UploadResult.tsx
      VideoList.tsx (선택)
```

* 이 문서에서는 프론트 쪽만 다룬다.
* 백엔드(Node)는 이미 `http://localhost:3000`에서 돌아가고 있다고 가정.

### 2.2 API 계약(Contract) 정의

이 문서는 **백엔드가 다음 API를 제공**한다고 가정하고 진행한다.

1. `GET /ping` → `"pong"` (헬스 체크)
2. `GET /videos` → 업로드된 영상 리스트 (선택)
3. `POST /api/upload` (중요)

`POST /api/upload` 응답 예시(JSON):

```json
{
  "ok": true,
  "videoId": "abc123",
  "originalUrl": "/videos/abc123/original.mp4",
  "clipUrl": "/videos/abc123/clip.mp4",
  "thumbnailUrl": "/videos/abc123/thumbnail.jpg"
}
```

실제 백엔드 구현은 문서 2 + 별도 FFmpeg 문서에서 채운다고 보고,
여기서는 **프론트에서 이 API를 어떻게 소비하는지**에 집중한다.

---

## 3. React / JSX 기초 (보완 섹션)

Stage 1·2에서 실제로 쓰게 될 최소 문법만 정리한다.

### 3-1. JSX 기본 개념

JSX는 “HTML 비슷하게 보이지만, 결국 JS 코드로 컴파일되는 문법 설탕”이다.

```tsx
// JSX
const element = <h1>Hello</h1>;

// 내부적으로 대략 이런 형태로 변환됨
const element2 = React.createElement("h1", null, "Hello");
```

중요 포인트:

* JSX는 **문자열이 아니라 표현식**이다.

  * 변수에 담고, 함수 인자로 넘기고, return 값으로 쓸 수 있다.

---

### 3-2. JSX vs HTML 차이

1. `class` → `className`

```tsx
// X
<div class="box"></div>

// O
<div className="box"></div>
```

2. `for` → `htmlFor`

```tsx
<label htmlFor="file-input">File</label>
<input id="file-input" type="file" />
```

3. self-closing 태그

JSX는 반드시 태그를 닫아야 한다.

```tsx
<input type="file" />        // O
<input type="file"></input>  // 이것도 되긴 함
```

---

### 3-3. JSX에서 style

`style`은 문자열이 아니라 **객체**다.

```tsx
<div style={{ color: "red", fontSize: 16 }}>Text</div>
```

* JS 객체라서, `-` 대신 camelCase 사용 (`background-color` → `backgroundColor`)
* 값은 문자열 또는 number

---

### 3-4. 조건부 렌더링 패턴 2개

1. **일찍 return**

```tsx
if (!video) {
  return <div>Loading...</div>;
}

return <VideoPlayer video={video} />;
```

2. **`&&` 연산자**

```tsx
{error && <div className="error">{error}</div>}
{isUploading && <Spinner />}
```

* `error`가 falsy면 오른쪽 JSX는 렌더링되지 않는다.

이 두 패턴만 알아도 대부분의 단순 조건부 렌더링은 처리 가능하다.

---

### 3-5. `useRef` 기본

DOM에 직접 접근하거나, 렌더 사이에 값 유지할 때 쓴다.

```tsx
import { useRef } from "react";

function VideoPlayer() {
  const videoRef = useRef<HTMLVideoElement | null>(null);

  const handlePlay = () => {
    if (videoRef.current) {
      videoRef.current.play();
    }
  };

  return (
    <div>
      <video ref={videoRef} src="/sample.mp4" />
      <button onClick={handlePlay}>Play</button>
    </div>
  );
}
```

포인트:

* `useRef`는 `{ current: T | null }` 형태의 “박스”를 반환
* `.current`에 넣어둔 값은 컴포넌트가 리렌더되어도 유지
* DOM 조작, 타이머 ID 보관 등에 사용

---

### 3-6. `forwardRef` + `useImperativeHandle`

부모가 자식 컴포넌트 내부 기능을 직접 호출할 수 있게 만드는 패턴.

```tsx
import {
  forwardRef,
  useImperativeHandle,
  useRef,
} from "react";

export interface VideoPlayerRef {
  seekTo: (time: number) => void;
}

interface Props {
  src: string;
}

export const VideoPlayer = forwardRef<VideoPlayerRef, Props>(
  ({ src }, ref) => {
    const videoRef = useRef<HTMLVideoElement | null>(null);

    useImperativeHandle(ref, () => ({
      seekTo(time: number) {
        if (videoRef.current) {
          videoRef.current.currentTime = time;
        }
      },
    }));

    return <video ref={videoRef} src={src} />;
  },
);
```

부모 쪽:

```tsx
const playerRef = useRef<VideoPlayerRef | null>(null);

const jumpTo10 = () => {
  playerRef.current?.seekTo(10);
};

<VideoPlayer ref={playerRef} src="/sample.mp4" />;
<button onClick={jumpTo10}>10초로 이동</button>;
```

타임라인에서 `seekTo()` 같은 API를 제공할 때 이런 패턴을 쓰게 된다.

---

### 3-7. `useEffect` cleanup 패턴

DOM 이벤트 등록/해제의 기본 패턴.

```tsx
import { useEffect, useRef } from "react";

function Player() {
  const videoRef = useRef<HTMLVideoElement | null>(null);

  useEffect(() => {
    const el = videoRef.current;
    if (!el) return;

    const onTimeUpdate = () => {
      console.log("currentTime:", el.currentTime);
    };

    el.addEventListener("timeupdate", onTimeUpdate);

    return () => {
      // cleanup
      el.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, []); // deps

  return <video ref={videoRef} src="/sample.mp4" />;
}
```

패턴:

* 이펙트에서 리스너/타이머 등록
* return 함수에서 해제
* deps 배열에 따라 재실행/정리 시점 결정

---

### 3-8. `useCallback` 기본

함수를 메모이제이션해서, 매 렌더마다 새 함수가 만들어지는 걸 줄이는 용도.

```tsx
import { useCallback } from "react";

interface Props {
  onUploaded: (id: string) => void;
}

function VideoUpload({ onUploaded }: Props) {
  const handleFile = useCallback(
    async (file: File) => {
      const id = await uploadVideo(file);
      onUploaded(id);
    },
    [onUploaded],
  );

  // ...
}
```

* 의존성 배열에 들어간 값이 바뀌지 않으면 동일한 함수 인스턴스 재사용
* `useEffect` 의존성, 자식 컴포넌트에 props로 넘길 때 사용

---

### 3-9. 폼/이벤트 타입 최소 예

React에서 이벤트 타입은 기본적으로 제네릭으로 제공된다.

```tsx
import type {
  ChangeEvent,
  FormEvent,
} from "react";

function NameForm() {
  const [name, setName] = useState("");

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  };

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    console.log("submit:", name);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={name} onChange={handleChange} />
      <button type="submit">Save</button>
    </form>
  );
}
```

이 정도만 알고 있으면, 대부분의 폼/입력 이벤트 타입 에러는 해결 가능하다.

---

## 4. React 프로젝트 기본 (Vite 기준)

### 3.1 프로젝트 생성 (참고용)

Vite + React + TypeScript 예시:

```bash
npm create vite@latest client -- --template react-ts
cd client
npm install
npm run dev
```

브라우저에서 `http://localhost:5173` 접속.

### 3.2 진입점 구조

`src/main.tsx` (기본 템플릿에서 거의 안 건드려도 됨)

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

`App.tsx` 안에 실제 UI를 구성한다.

---

## 5. 타입 정의 & API 모듈

프론트와 백엔드 사이 계약을 TS 타입으로 먼저 고정한다.

### 4.1 `types.ts`

```ts
// 업로드 상태
export type UploadStatus =
  | "idle"
  | "selecting"
  | "uploading"
  | "processing"
  | "done"
  | "error";

// /api/upload 응답
export interface UploadResponse {
  ok: boolean;
  videoId: string;
  originalUrl?: string;
  clipUrl?: string;
  thumbnailUrl?: string;
}

// /videos 리스트 응답 (선택)
export interface VideoMeta {
  id: string;
  title: string;
  duration: number; // seconds
}
```

### 4.2 `api.ts`

```ts
import type { UploadResponse, VideoMeta } from "./types";

const API_BASE = "http://localhost:3000";

export async function ping(): Promise<string> {
  const res = await fetch(`${API_BASE}/ping`);
  if (!res.ok) {
    throw new Error(`ping failed: ${res.status}`);
  }
  return res.text();
}

export async function uploadVideo(file: File): Promise<UploadResponse> {
  const form = new FormData();
  form.append("video", file);

  const res = await fetch(`${API_BASE}/api/upload`, {
    method: "POST",
    body: form,
  });

  if (!res.ok) {
    throw new Error(`upload failed: ${res.status}`);
  }

  const data = (await res.json()) as UploadResponse;
  if (!data.ok) {
    throw new Error("upload response not ok");
  }

  return data;
}

export async function fetchVideos(): Promise<VideoMeta[]> {
  const res = await fetch(`${API_BASE}/videos`);
  if (!res.ok) {
    throw new Error(`fetchVideos failed: ${res.status}`);
  }
  return (await res.json()) as VideoMeta[];
}
```

컴포넌트가 직접 `fetch`를 쓰지 않고, `api.ts`를 통해 호출하게 분리해 두면 코드가 정리된다.

---

## 6. 업로드 상태 관리 컴포넌트

### 5.1 상태 설계

업로드 UI가 가져야 할 상태:

* 현재 선택된 파일 (`File | null`)
* 업로드 진행 상태 (`UploadStatus`)
* 에러 메시지 (`string | null`)
* (결과는 상위 `App`에서 관리)

```ts
import type { UploadStatus, UploadResponse } from "../types";

type UploadFormProps = {
  onUploaded?: (result: UploadResponse) => void;
};
```

### 5.2 `UploadForm` 컴포넌트 (`components/UploadForm.tsx`)

```tsx
import { useState, ChangeEvent, FormEvent } from "react";
import { uploadVideo } from "../api";
import type { UploadStatus, UploadResponse } from "../types";

type UploadFormProps = {
  onUploaded?: (result: UploadResponse) => void;
};

export function UploadForm({ onUploaded }: UploadFormProps) {
  const [file, setFile] = useState<File | null>(null);
  const [status, setStatus] = useState<UploadStatus>("idle");
  const [error, setError] = useState<string | null>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      setFile(null);
      setStatus("idle");
      return;
    }
    setFile(files[0]);
    setStatus("selecting");
    setError(null);
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!file) {
      setError("파일을 선택하세요.");
      return;
    }

    try {
      setStatus("uploading");
      setError(null);

      const result = await uploadVideo(file);

      setStatus("done");
      if (onUploaded) {
        onUploaded(result);
      }
    } catch (err) {
      console.error(err);
      setStatus("error");
      setError("업로드 실패");
    }
  };

  const buttonDisabled =
    status === "uploading" || status === "processing" || !file;

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input type="file" accept="video/*" onChange={handleFileChange} />
      </div>

      <div>
        <button type="submit" disabled={buttonDisabled}>
          {status === "uploading" ? "업로드 중..." : "업로드"}
        </button>
      </div>

      <div>
        <span>상태: {status}</span>
      </div>

      {error && <div style={{ color: "red" }}>{error}</div>}
    </form>
  );
}
```

여기서는 단순화를 위해 `processing` 상태는 시각적으로 따로 표현하지 않았다. 필요하면 백엔드에서 업로드/처리를 분리해도 된다.

---

## 7. 업로드 결과 표시 컴포넌트

### 6.1 `UploadResult` 컴포넌트 (`components/UploadResult.tsx`)

```tsx
import type { UploadResponse } from "../types";

type UploadResultProps = {
  result: UploadResponse | null;
};

export function UploadResult({ result }: UploadResultProps) {
  if (!result) {
    return null;
  }

  const { originalUrl, clipUrl, thumbnailUrl, videoId } = result;

  return (
    <div style={{ marginTop: "16px" }}>
      <h2>업로드 결과</h2>
      <p>videoId: {videoId}</p>

      {thumbnailUrl && (
        <div>
          <h3>썸네일</h3>
          <img src={thumbnailUrl} alt="thumbnail" width={240} />
        </div>
      )}

      {clipUrl && (
        <div>
          <h3>클립 (5초)</h3>
          <video src={clipUrl} controls width={400} />
        </div>
      )}

      {originalUrl && (
        <div>
          <h3>원본</h3>
          <video src={originalUrl} controls width={400} />
        </div>
      )}
    </div>
  );
}
```

단순히 `UploadResponse`에 들어있는 URL들을 `<img>`, `<video>`로 보여주는 역할이다.

---

## 8. 전체 App 구성

### 7.1 `App.tsx`

```tsx
import { useEffect, useState } from "react";
import { ping } from "./api";
import type { UploadResponse } from "./types";
import { UploadForm } from "./components/UploadForm";
import { UploadResult } from "./components/UploadResult";

function App() {
  const [pingResult, setPingResult] = useState<string>("(checking)");
  const [lastUploadResult, setLastUploadResult] =
    useState<UploadResponse | null>(null);

  useEffect(() => {
    ping()
      .then((text) => setPingResult(text))
      .catch((err) => {
        console.error(err);
        setPingResult("error");
      });
  }, []);

  return (
    <div style={{ padding: "16px", fontFamily: "sans-serif" }}>
      <h1>Video Uploader</h1>
      <p>Backend /ping: {pingResult}</p>

      <hr />

      <h2>영상 업로드</h2>
      <UploadForm onUploaded={setLastUploadResult} />

      <UploadResult result={lastUploadResult} />
    </div>
  );
}

export default App;
```

이 상태에서:

1. 백엔드(Node)가 `http://localhost:3000`에서 실행 중이어야 한다.
2. 프론트(Vite)가 `npm run dev`로 실행 중이어야 한다.
3. 업로드 시 `/api/upload`가 응답을 주면 결과가 바로 아래에서 렌더링된다.

---

## 9. 선택: 업로드 이후 리스트 렌더링

실제 서비스라면 “업로드한 영상 전체 리스트” 같은 화면이 필요하다.
문서 2에서 만든 `/videos` API를 붙이면 된다.

### 8.1 `VideoList` 컴포넌트 (`components/VideoList.tsx`)

```tsx
import { useEffect, useState } from "react";
import { fetchVideos } from "../api";
import type { VideoMeta } from "../types";

export function VideoList() {
  const [videos, setVideos] = useState<VideoMeta[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetchVideos()
      .then((data) => {
        setVideos(data);
      })
      .catch((err) => {
        console.error(err);
        setError("영상 목록을 불러오지 못했습니다.");
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  if (loading) {
    return <p>영상 목록 로딩 중...</p>;
  }

  if (error) {
    return <p style={{ color: "red" }}>{error}</p>;
  }

  if (videos.length === 0) {
    return <p>등록된 영상이 없습니다.</p>;
  }

  return (
    <div style={{ marginTop: "16px" }}>
      <h2>영상 목록</h2>
      <ul>
        {videos.map((v) => (
          <li key={v.id}>
            {v.title} ({v.duration}s)
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 8.2 `App.tsx`에 추가

```tsx
import { VideoList } from "./components/VideoList";

// ...
      <UploadResult result={lastUploadResult} />

      <hr />
      <VideoList />
// ...
```

백엔드에서 `/videos`에 업로드 결과를 기록하도록 설계했다면,
새 업로드 후 `VideoList` 갱신 로직을 추가하면 된다(예: “새로고침” 버튼).

---

## 10. React에서 상태/렌더링 모델을 C 관점에서 정리

C 경험자 기준으로, React의 핵심은 **“상태 기반 렌더링”**이다.

* 상태(state)가 바뀌면 컴포넌트 함수가 다시 호출된다고 보면 된다.
* `useState`를 “전역/정적 변수”라 생각하면 틀린다. **렌더링 사이에서 유지되는 값**이다.
* `setState` 호출 → React가 다시 렌더 → JSX 반환 → DOM diff → 필요한 부분만 실제 DOM 갱신.

간단히 대응하면:

| C 개념                               | React 개념                              |
| ---------------------------------- | ------------------------------------- |
| 전역/모듈 상태 + 함수 호출                   | `useState` + 함수형 컴포넌트                 |
| UI 갱신을 직접 그리기 (printf, GUI API 호출) | 상태 변경 → React가 알아서 DOM 패치             |
| 이벤트 핸들러(콜백)                        | `onClick`, `onChange` 등 JSX 속성에 함수 전달 |
| 데이터 구조 배열 반복 출력                    | `array.map()` + JSX 리스트, `key` 필요     |

이 문서에서 작성한 `UploadForm` / `UploadResult` / `VideoList`는:

* 상태(`useState`)를 가지고,
* 이벤트 핸들러(파일 선택, 폼 submit)를 통해 상태를 바꾸고,
* 상태가 바뀔 때마다 JSX(=UI)가 재계산되는 구조로 되어 있다.

---

## 11. Stage 1·2 프론트 측 체크리스트

이 문서 기준으로, 프론트 측에서 아래를 만족하면 Stage 1·2의 “React + 연동”은 최소 수준 통과로 본다.

* [ ] Vite + React + TypeScript를 이용해 기본 프로젝트를 생성하고 실행할 수 있다.
* [ ] `App.tsx`에서 `ping()` API를 호출해 백엔드 `/ping` 결과를 화면에 표시할 수 있다.
* [ ] `UploadForm`처럼, 파일 입력 + 버튼 + 상태 표시를 가진 컴포넌트를 직접 작성할 수 있다.
* [ ] 업로드 상태(`idle` / `uploading` / `done` / `error`)를 유니온 타입으로 관리하고, 상태에 따라 버튼/텍스트 등을 다르게 렌더링할 수 있다.
* [ ] `/api/upload` 결과(JSON)를 `UploadResponse` 타입으로 받고, 썸네일/클립 URL을 `<img>`, `<video>`로 표시할 수 있다.
* [ ] `/videos` 같은 목록 API를 호출해서, 배열을 `map()`으로 렌더링하고 `key`를 적절히 넣을 수 있다.

여기까지가 수정/보완된 문서 3의 범위다.
다음 문서는 C++/FFmpeg C API/애드온으로 내려가는 문서 4다.
