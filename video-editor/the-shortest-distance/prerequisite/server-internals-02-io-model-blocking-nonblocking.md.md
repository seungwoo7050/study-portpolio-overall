# 🔥 서버 동작 이해 2편 – I/O 모델 정리(블로킹/논블로킹, 동기/비동기, 멀티플렉싱)

서버 성능 구조를 이해하려면 **I/O가 어떻게 작동하는지**부터 확실히 정리해야 한다.
프로세스/스레드 구조보다 이쪽이 실제 병렬성·확장성에 훨씬 더 직접적인 영향을 준다.

이번 편은 블로킹/논블로킹, 동기/비동기, 멀티플렉싱(Select/Poll/epoll)만 명확히 정리한다.
헷갈리는 개념이라 군더더기 없이 정확히 간다.

---

# 1. 블로킹 / 논블로킹

둘 다 **system call이 어떤 타이밍에 리턴하느냐**만 보면 된다.

## 1-1) 블로킹(Blocked)

대표적인 상황:

```c
read(fd, buf, size);
```

커널 recv buffer에 **데이터가 없으면**
→ read는 **반환하지 않고 멈춘다(blocked)**.

즉:

* 호출한 스레드가 멈춘다.
* CPU는 해당 스레드를 스케줄링에서 제외.
* 스레드 하나가 블로킹에 걸리면 그 스레드는 일을 못 한다.

**문제점**

* 연결이 많아질수록 스레드가 필요 이상으로 늘어난다.
* 1만 커넥션 → 블로킹 모델은 1만 스레드가 필요해지는 구조.

## 1-2) 논블로킹(Non-blocking)

논블로킹 소켓에서 `read()` 호출하면:

* 커널 버퍼에 데이터가 있으면 → 읽고 즉시 리턴.
* 데이터 없으면 → 읽지 않고 **즉시 EAGAIN 리턴**.

즉, 멈추지 않는다.

장점:

* 스레드가 멈추지 않고 계속 다른 작업 가능.

단점:

* 데이터 없을 때마다 EAGAIN만 반복해서 돌아온다 → busy loop 위험.
* 이걸 해결하려고 멀티플렉싱이 필요해짐.

---

# 2. 동기 / 비동기

여기서 많은 개발자들이 혼동한다.
**동기/비동기는 “작업 완료 시점에 누가 기다리는가?”**를 기준으로 보면 된다.

## 2-1) 동기(Synchronous)

특징:

* 시스템 콜이 “진짜 I/O 작업”까지 다 끝나야 리턴.
* 즉, user-space로 돌아오는 시점 = I/O 완료 시점.

블로킹/논블로킹과 무관하다.

예:

```c
read(fd, buf, size);
```

* 블로킹 read: 기다림 → 동기
* 논블로킹 read: 기다리지 않고 EAGAIN 바로 리턴 → 그래도 동기
  이유: 작업 완료 시점에 대한 처리를 **사용자 코드가 직접 확인**해야 하기 때문.

요점:

* **동기 = 사용자가 직접 확인·반복해야 함(EAGAIN 체크 등)**

## 2-2) 비동기(Asynchronous)

비동기 I/O는 “진짜 I/O 작업”을 커널이 처리하고,
완료되면 **커널이 나중에 사용자에게 알려준다**.

예: `io_uring`, Windows IOCP, POSIX AIO 등.

특징:

* system call은 요청만 등록하고 바로 돌아감.
* 데이터 준비/전송 완료는 나중에 커널이 알려줌.
* 사용자 스레드는 완료를 기다릴 필요 없음.

그래서 비동기 모델은 CPU 점유 낭비가 없다.

요점:

* **비동기 = 커널이 작업 완료를 알려준다 (콜백/이벤트)**
* 사용자는 완료될 때까지 반복 호출(EAGAIN 체크)할 필요 없음.

---

# 3. 멀티플렉싱(select/poll/epoll)

논블로킹 I/O에서 **“데이터가 준비된 소켓만 알고 싶다”**는 요구가 생기면서
자연스럽게 등장하는 기능.

역할은 단순하다:

> 여러 소켓 중에서 “지금 I/O 가능한 소켓 리스트”만 알려주는 기술.

이걸로 불필요한 read/write 시도를 없앤다.

## 3-1) select

* 가장 오래된 방식.
* FD 개수 제한(보통 1024).
* 매 호출마다 전체 FD bitmap을 커널로 복사 → 비용 큼.

## 3-2) poll

* select 단점 개선.
* FD 개수 제한 없음.
* 하지만 여전히 “모든 FD 리스트를 매번 스캔”해야 해서 O(N).

## 3-3) epoll (리눅스 전용, 현대 서버 기본)

핵심 요약:

* **커널이 “준비된 소켓”만 알려줌 → O(준비된 FD 개수)**
* 유저는 “전체 FD 목록”을 매번 넘길 필요 없음.
* edge-triggered로 하면 이벤트 발생 시점 기준으로만 알려줘서 더 효율적.

epoll 기반 구조:

```
epoll_wait()
   ↓
준비된 소켓 목록 반환
   ↓
소켓마다 read/write 처리
   ↓
반복
```

이게 Node.js, Nginx, Redis, Netty 등이 사용하는 기본 구조다.
이 구조의 이름이 바로 **“이벤트 루프(event loop)”**.

---

# 4. 전체 흐름을 한 문장으로 정리하면

* **블로킹/논블로킹** → system call이 멈추는지 여부
* **동기/비동기** → I/O 완료 시점에 누가 기다리는지
* **멀티플렉싱** → 준비된 소켓만 알려줘서 논블로킹 서버의 비효율 제거

---

# 5. 실제 서버 구조에서 적용되는 패턴

## 5-1) 블로킹 + 멀티스레드

* 스레드 하나가 하나의 요청 담당
* 요청량 많아지면 스레드 폭발
* 옛날 방식, 유지비 비쌈

예: Tomcat의 old connector, Apache old MPM

## 5-2) 논블로킹 + 멀티플렉싱 + 싱글 스레드

* epoll 기반 이벤트 루프 하나
* 수만 커넥션을 단일 스레드가 처리
* CPU bound 작업만 조심하면 매우 효율적

예: Node.js, Nginx, Redis

## 5-3) 이벤트 루프 + 스레드풀 혼합

* I/O는 이벤트 루프
* CPU-heavy 작업은 스레드풀로 던짐

예: Java Netty, Python asyncio + executor

---

# 6. 이번 편 포인트 정리

핵심만 정리한다.

1. **블로킹/논블로킹**

   * 블로킹 = 멈춤
   * 논블로킹 = EAGAIN 즉시 리턴

2. **동기/비동기**

   * 동기 = 완료 여부를 내가 확인해야 함
   * 비동기 = 커널이 완료를 알려줌

3. **멀티플렉싱**

   * 준비된 소켓만 알려줘서 CPU 낭비 최소화
   * 현대 서버는 epoll 기반이 기본

4. 이 모든 것의 결합이 **이벤트 루프 기반 서버 구조**를 만든다.

---

다음 3편에서는 **TCP 연결 내부 동작 + 커널 버퍼 구조**를 다룬다.
여기서 소켓 FD가 어떻게 생성되는지, read/write 호출이 어떤 버퍼를 읽고 쓰는지까지 확실히 정리한다.
