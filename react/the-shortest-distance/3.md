# 문서 3. 인증 & 상태관리 (M3-M4: Auth + Data Fetching)

> 이 문서는 **Milestone 3-4** 용이다.
> 전제:
>
> * M1-M2 완료 (Bootstrap + CRUD UI)
> * React Hook Form, useState/useEffect 사용 경험
> * 이제 **JWT 인증**, **React Query**, **통계 대시보드**를 익힐 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* M1-M2 완료 (Vite + React Router + CRUD UI)
* TypeScript 기본 문법 이해
* API 연동 경험 (fetch/axios)

### 이 문서의 목표

1. **JWT 기반 로그인/로그아웃** 구현 (M3)
2. **Protected Routes**로 인증 보호
3. **React Query**로 서버 상태 관리 (M4)
4. **통계 대시보드** (Recharts)

### 이 문서가 다루는 범위

* **M3**: 로그인/인증/인가 UX
* **M4**: 통계/데이터 패칭 패턴

**다루지 않는 범위** (다음 문서 4에서):

* M5: 검색/필터 UI + 성능 기초
* M6: 테스트 전략 & E2E & 접근성

---

## 1. M3: 로그인/인증/인가 UX

### 1.1 목표

* JWT 토큰 저장 및 사용
* AuthContext로 전역 인증 상태 관리
* Protected Routes 구현
* 역할 기반 UI (OWNER/MANAGER/MEMBER)

### 1.2 AuthContext

```typescript
// src/features/auth/AuthContext.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';

interface User {
  id: number;
  email: string;
  nickname: string;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 페이지 로드 시 토큰 확인
    const token = localStorage.getItem('access_token');
    if (token) {
      // TODO: 토큰으로 사용자 정보 조회
      fetchCurrentUser();
    }
  }, []);

  async function login(email: string, password: string) {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error('Login failed');
    }

    const { access_token, user } = await response.json();
    localStorage.setItem('access_token', access_token);
    setUser(user);
  }

  function logout() {
    localStorage.removeItem('access_token');
    setUser(null);
  }

  async function fetchCurrentUser() {
    try {
      const token = localStorage.getItem('access_token');
      const response = await fetch('/api/users/me', {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (response.ok) {
        const user = await response.json();
        setUser(user);
      } else {
        logout();
      }
    } catch (error) {
      logout();
    }
  }

  return (
    <AuthContext.Provider
      value={{
        user,
        login,
        logout,
        isAuthenticated: !!user,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### 1.3 Login Page

```typescript
// src/features/auth/LoginPage.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useAuth } from './AuthContext';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/shared/components/Button';

const loginSchema = z.object({
  email: z.string().email('유효한 이메일을 입력하세요'),
  password: z.string().min(8, '비밀번호는 최소 8자 이상이어야 합니다'),
});

type LoginFormData = z.infer<typeof loginSchema>;

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  async function onSubmit(data: LoginFormData) {
    try {
      await login(data.email, data.password);
      navigate('/');
    } catch (error) {
      alert('로그인에 실패했습니다.');
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow p-8">
        <h2 className="text-2xl font-bold text-center mb-6">로그인</h2>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              이메일
            </label>
            <input
              id="email"
              type="email"
              {...register('email')}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            />
            {errors.email && (
              <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
            )}
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              비밀번호
            </label>
            <input
              id="password"
              type="password"
              {...register('password')}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            />
            {errors.password && (
              <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
            )}
          </div>

          <Button type="submit" className="w-full" disabled={isSubmitting}>
            {isSubmitting ? '로그인 중...' : '로그인'}
          </Button>
        </form>
      </div>
    </div>
  );
}
```

### 1.4 Protected Routes

```typescript
// src/app/routes/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useAuth } from '@/features/auth/AuthContext';
import { ReactNode } from 'react';

interface ProtectedRouteProps {
  children: ReactNode;
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}
```

**App.tsx에 적용**:

```typescript
// src/App.tsx (수정)
import { ProtectedRoute } from './app/routes/ProtectedRoute';

export default function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route
            element={
              <ProtectedRoute>
                <MainLayout />
              </ProtectedRoute>
            }
          >
            <Route path="/" element={<HomePage />} />
            <Route path="/projects" element={<ProjectListPage />} />
            {/* ... */}
          </Route>
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}
```

---

## 2. M4: 통계/데이터 패칭 패턴

### 2.1 목표

* React Query로 서버 상태 관리
* 캐싱 & Optimistic Update
* 통계 대시보드 (Recharts)

### 2.2 React Query 설정

**설치**:

```bash
npm install @tanstack/react-query
```

**Query Client 설정**:

```typescript
// src/shared/lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5분
      retry: 1,
    },
  },
});
```

**main.tsx에 Provider 추가**:

```typescript
// src/main.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from './shared/lib/queryClient';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </StrictMode>,
);
```

### 2.3 useQuery로 데이터 조회

```typescript
// src/features/issue/hooks/useIssues.ts
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/shared/lib/apiClient';
import { Issue } from '../types';

export function useIssues(projectId: number) {
  return useQuery({
    queryKey: ['projects', projectId, 'issues'],
    queryFn: () => apiRequest<Issue[]>(`/projects/${projectId}/issues`),
  });
}
```

**컴포넌트에서 사용**:

```typescript
// src/features/issue/IssueListPage.tsx (수정)
import { useIssues } from './hooks/useIssues';

export function IssueListPage() {
  const { projectId } = useParams<{ projectId: string }>();
  const { data: issues, isLoading, error } = useIssues(Number(projectId));

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div className="text-red-600">Error: {error.message}</div>;

  return (
    <div>
      {/* 이전과 동일한 렌더링 로직 */}
    </div>
  );
}
```

### 2.4 useMutation으로 데이터 수정

```typescript
// src/features/issue/hooks/useCreateIssue.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/shared/lib/apiClient';
import { CreateIssueDto, Issue } from '../types';

export function useCreateIssue(projectId: number) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateIssueDto) =>
      apiRequest<Issue>(`/projects/${projectId}/issues`, {
        method: 'POST',
        body: JSON.stringify(data),
      }),
    onSuccess: () => {
      // 캐시 무효화 → 자동 재조회
      queryClient.invalidateQueries({ queryKey: ['projects', projectId, 'issues'] });
    },
  });
}
```

**컴포넌트에서 사용**:

```typescript
// src/features/issue/CreateIssuePage.tsx (수정)
import { useCreateIssue } from './hooks/useCreateIssue';

export function CreateIssuePage() {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  const createIssue = useCreateIssue(Number(projectId));

  async function handleSubmit(data: CreateIssueFormData) {
    try {
      await createIssue.mutateAsync(data);
      navigate(`/projects/${projectId}/issues`);
    } catch (error) {
      alert('이슈 생성에 실패했습니다.');
    }
  }

  return <CreateIssueForm projectId={Number(projectId)} onSubmit={handleSubmit} />;
}
```

### 2.5 통계 대시보드 (Recharts)

**설치**:

```bash
npm install recharts
```

**DailyStatsChart 컴포넌트**:

```typescript
// src/features/stats/DailyStatsChart.tsx
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';

interface DailyStats {
  date: string;
  createdCount: number;
  resolvedCount: number;
  commentCount: number;
}

interface DailyStatsChartProps {
  data: DailyStats[];
}

export function DailyStatsChart({ data }: DailyStatsChartProps) {
  return (
    <LineChart width={800} height={400} data={data}>
      <CartesianGrid strokeDasharray="3 3" />
      <XAxis dataKey="date" />
      <YAxis />
      <Tooltip />
      <Legend />
      <Line type="monotone" dataKey="createdCount" stroke="#8884d8" name="생성된 이슈" />
      <Line type="monotone" dataKey="resolvedCount" stroke="#82ca9d" name="해결된 이슈" />
      <Line type="monotone" dataKey="commentCount" stroke="#ffc658" name="댓글 수" />
    </LineChart>
  );
}
```

**StatsPage**:

```typescript
// src/features/stats/StatsPage.tsx
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/shared/lib/apiClient';
import { DailyStatsChart } from './DailyStatsChart';

export function StatsPage() {
  const { data, isLoading } = useQuery({
    queryKey: ['stats', 'daily'],
    queryFn: () =>
      apiRequest('/stats/daily?from=2025-01-01&to=2025-01-31'),
  });

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">통계 대시보드</h1>
      <DailyStatsChart data={data} />
    </div>
  );
}
```

---

## 3. M3-M4 체크리스트

### M3 체크리스트

* [ ] JWT 로그인을 구현하고, 토큰을 localStorage에 저장할 수 있다.
* [ ] AuthContext로 전역 인증 상태를 관리할 수 있다.
* [ ] Protected Routes로 인증되지 않은 사용자를 `/login`으로 리다이렉트할 수 있다.
* [ ] useAuth hook으로 컴포넌트에서 인증 상태를 사용할 수 있다.

### M4 체크리스트

* [ ] React Query를 설정하고, useQuery로 데이터를 조회할 수 있다.
* [ ] useMutation으로 데이터를 생성/수정/삭제하고, 캐시를 자동 갱신할 수 있다.
* [ ] Recharts로 통계 데이터를 차트로 시각화할 수 있다.
* [ ] React Query DevTools로 캐시 상태를 확인할 수 있다.

**다음 단계** (문서 4):

* M5: 검색/필터 UI + 성능 기초
* M6: 테스트 전략 & E2E & 접근성
