# 문서 4. WebSocket (Lab 1.3-1.4)

> 이 문서는 **Stage 1 후반부**를 다룬다.
> TCP 기초 (문서 3)는 이미 마쳤다고 가정한다.

---

## 0. 전제 / 목표

### 전제

* TCP 에코 서버, 턴제 전투 서버 구현 완료 (Lab 1.1-1.2)
* 멀티스레딩, RAII 패턴 숙지
* 타이머 기반 게임 루프 경험

### 이 문서의 목표

**WebSocket 기반 실시간 게임 서버**를 구현한다:

* Lab 1.3: WebSocket 채팅 서버
* Lab 1.4: WebSocket Pong 서버 (60 TPS)

최종적으로 이 정도를 목표로 한다:

* WebSocket 프로토콜 구현 가능
* 60 TPS 고속 게임 루프 구현 가능
* JSON 직렬화/역직렬화
* 실시간 물리 시뮬레이션

---

## 1. WebSocket 프로토콜 기본

### 1.1 왜 WebSocket인가?

**HTTP의 한계**:

* 요청-응답 모델: 서버가 먼저 메시지 전송 불가
* 폴링 (Polling): 비효율적인 대역폭 사용
* Long Polling: 복잡한 구현

**WebSocket의 장점**:

* 양방향 통신: 서버 → 클라이언트 메시지 전송 가능
* 실시간: 지연 최소화
* 효율적: TCP 연결 하나로 지속적인 통신

### 1.2 핸드셰이크 (HTTP Upgrade)

**클라이언트 요청**:

```
GET /chat HTTP/1.1
Host: localhost:8082
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

**서버 응답**:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**Accept 키 계산**:

```cpp
std::string compute_accept_key(const std::string& client_key) {
    const std::string magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    std::string combined = client_key + magic;

    // SHA-1 해시 계산
    unsigned char hash[20];
    SHA1(reinterpret_cast<const unsigned char*>(combined.data()),
         combined.size(), hash);

    // Base64 인코딩
    return base64_encode(hash, 20);
}
```

### 1.3 프레임 구조

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               | Masking-key, if MASK set to 1 |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

**주요 필드**:

* **FIN**: 최종 프레임 여부 (1 = 최종)
* **opcode**: 프레임 타입 (0x1 = 텍스트, 0x2 = 바이너리, 0x8 = close)
* **MASK**: 마스킹 여부 (클라이언트 → 서버는 항상 1)
* **Payload len**: 페이로드 길이

---

## 2. Lab 1.3: WebSocket 채팅 서버

### 2.1 목표

* WebSocket 핸드셰이크 구현
* 프레임 파싱 및 인코딩
* 브로드캐스트 메시지 전송

### 2.2 핵심 구조

**WebSocket 클래스**

```cpp
class WebSocket {
public:
    explicit WebSocket(Socket socket);

    bool handshake();  // HTTP Upgrade 처리
    std::string receive_frame();  // 프레임 수신 & 파싱
    void send_frame(const std::string& message);  // 프레임 전송

private:
    std::string parse_websocket_key(const std::string& request);
    std::string compute_accept_key(const std::string& key);
    std::vector<uint8_t> decode_frame(const std::vector<uint8_t>& data);
    std::vector<uint8_t> encode_frame(const std::string& message);

    Socket socket_;
};
```

**ChatServer 클래스**

```cpp
class ChatServer {
public:
    explicit ChatServer(uint16_t port);

    void run();
    void broadcast(const std::string& message);

private:
    void handle_client(Socket socket);
    void remove_client(std::shared_ptr<WebSocket> client);

    uint16_t port_;
    std::atomic<bool> running_;
    std::vector<std::shared_ptr<WebSocket>> clients_;
    std::mutex clients_mutex_;
};
```

### 2.3 핸드셰이크 구현

```cpp
bool WebSocket::handshake() {
    uint8_t buffer[4096];
    ssize_t n = socket_.receive(buffer, sizeof(buffer));
    if (n <= 0) return false;

    std::string request(reinterpret_cast<char*>(buffer), n);

    // Sec-WebSocket-Key 추출
    std::string key = parse_websocket_key(request);
    if (key.empty()) return false;

    // Accept 키 계산
    std::string accept = compute_accept_key(key);

    // 응답 전송
    std::string response =
        "HTTP/1.1 101 Switching Protocols\r\n"
        "Upgrade: websocket\r\n"
        "Connection: Upgrade\r\n"
        "Sec-WebSocket-Accept: " + accept + "\r\n"
        "\r\n";

    socket_.send_all(reinterpret_cast<const uint8_t*>(response.data()),
                   response.size());

    return true;
}
```

### 2.4 프레임 디코딩 (클라이언트 → 서버)

```cpp
std::string WebSocket::receive_frame() {
    uint8_t header[2];
    ssize_t n = socket_.receive(header, 2);
    if (n != 2) throw std::runtime_error("Frame header read failed");

    bool fin = (header[0] & 0x80) != 0;
    uint8_t opcode = header[0] & 0x0F;
    bool masked = (header[1] & 0x80) != 0;
    uint64_t payload_len = header[1] & 0x7F;

    // Extended payload length
    if (payload_len == 126) {
        uint8_t len_bytes[2];
        socket_.receive(len_bytes, 2);
        payload_len = (len_bytes[0] << 8) | len_bytes[1];
    } else if (payload_len == 127) {
        // 64-bit length (생략)
    }

    // Masking key (클라이언트 → 서버는 항상 마스킹)
    uint8_t mask[4];
    if (masked) {
        socket_.receive(mask, 4);
    }

    // Payload 읽기
    std::vector<uint8_t> payload(payload_len);
    socket_.receive(payload.data(), payload_len);

    // 언마스킹
    if (masked) {
        for (size_t i = 0; i < payload_len; ++i) {
            payload[i] ^= mask[i % 4];
        }
    }

    return std::string(reinterpret_cast<char*>(payload.data()), payload_len);
}
```

### 2.5 프레임 인코딩 (서버 → 클라이언트)

```cpp
void WebSocket::send_frame(const std::string& message) {
    std::vector<uint8_t> frame;

    // FIN + opcode (0x1 = 텍스트)
    frame.push_back(0x81);

    // Payload length
    size_t len = message.size();
    if (len < 126) {
        frame.push_back(static_cast<uint8_t>(len));
    } else if (len < 65536) {
        frame.push_back(126);
        frame.push_back((len >> 8) & 0xFF);
        frame.push_back(len & 0xFF);
    } else {
        // 64-bit length (생략)
    }

    // Payload (서버 → 클라이언트는 마스킹 없음)
    frame.insert(frame.end(), message.begin(), message.end());

    socket_.send_all(frame.data(), frame.size());
}
```

### 2.6 브로드캐스트

```cpp
void ChatServer::broadcast(const std::string& message) {
    std::lock_guard<std::mutex> lock(clients_mutex_);

    for (auto& client : clients_) {
        try {
            client->send_frame(message);
        } catch (const std::exception& e) {
            // 클라이언트 전송 실패 시 무시
        }
    }
}
```

### 2.7 빌드 & 테스트

```bash
# 빌드
cd gameserver-fundamentals/build
make

# 실행
./lab1.3-ws-chat/chat_server.out 8082

# 웹 브라우저 테스트 (개발자 도구 콘솔)
const ws = new WebSocket('ws://localhost:8082');
ws.onmessage = (e) => console.log('Received:', e.data);
ws.send('Hello from browser!');
```

### 2.8 체크리스트

* [ ] WebSocket 핸드셰이크가 정상 동작
* [ ] 클라이언트가 보낸 메시지를 서버가 수신
* [ ] 서버가 보낸 메시지를 모든 클라이언트가 수신 (브로드캐스트)
* [ ] 여러 클라이언트 동시 접속 가능
* [ ] Wireshark로 WebSocket 프레임 구조 확인

---

## 3. Lab 1.4: WebSocket Pong 서버 (60 TPS)

### 3.1 목표

* 60 TPS 게임 루프 구현
* 공/패들 물리 시뮬레이션
* JSON 직렬화/역직렬화
* 실시간 상태 동기화

### 3.2 핵심 구조

**GameState 클래스**

```cpp
struct Vec2 {
    float x{0.0f};
    float y{0.0f};
};

struct Ball {
    Vec2 position;
    Vec2 velocity;
    float radius{10.0f};
};

struct Paddle {
    float y{0.0f};
    float speed{300.0f};  // pixels per second
};

class GameState {
public:
    void update(float dt);  // 물리 업데이트
    std::string to_json() const;  // JSON 직렬화

    void reset_ball();

    Ball ball;
    Paddle paddle1;
    Paddle paddle2;
    int score1{0};
    int score2{0};
};
```

**PongServer 클래스**

```cpp
class PongServer {
public:
    explicit PongServer(uint16_t port);

    void run();  // 60 TPS 게임 루프

private:
    void tick(float dt);
    void process_inputs();
    void broadcast_state();
    void handle_client(Socket socket);

    uint16_t port_;
    std::atomic<bool> running_;
    GameState state_;
    std::vector<std::shared_ptr<WebSocket>> clients_;
    std::mutex clients_mutex_;

    // 입력 큐
    std::map<int, std::string> pending_inputs_;  // client_id -> action
    std::mutex inputs_mutex_;
};
```

### 3.3 60 TPS 게임 루프

```cpp
void PongServer::run() {
    using namespace std::chrono;
    const auto tick_duration = microseconds(16667);  // 60 TPS ≈ 16.67ms

    auto last_tick = steady_clock::now();

    while (running_) {
        auto now = steady_clock::now();
        auto elapsed = duration_cast<microseconds>(now - last_tick);

        if (elapsed >= tick_duration) {
            float dt = elapsed.count() / 1000000.0f;  // 초 단위
            tick(dt);
            last_tick = now;
        } else {
            std::this_thread::sleep_for(tick_duration - elapsed);
        }
    }
}

void PongServer::tick(float dt) {
    process_inputs();
    state_.update(dt);
    broadcast_state();
}
```

### 3.4 물리 업데이트

```cpp
void GameState::update(float dt) {
    // 공 이동
    ball.position.x += ball.velocity.x * dt;
    ball.position.y += ball.velocity.y * dt;

    // 상/하 벽 충돌
    if (ball.position.y - ball.radius < 0) {
        ball.position.y = ball.radius;
        ball.velocity.y *= -1;
    }
    if (ball.position.y + ball.radius > 600) {
        ball.position.y = 600 - ball.radius;
        ball.velocity.y *= -1;
    }

    // 왼쪽 패들 충돌
    if (ball.position.x - ball.radius < 50 &&
        ball.position.y >= paddle1.y - 50 &&
        ball.position.y <= paddle1.y + 50) {
        ball.velocity.x = std::abs(ball.velocity.x);
    }

    // 오른쪽 패들 충돌
    if (ball.position.x + ball.radius > 750 &&
        ball.position.y >= paddle2.y - 50 &&
        ball.position.y <= paddle2.y + 50) {
        ball.velocity.x = -std::abs(ball.velocity.x);
    }

    // 득점 체크
    if (ball.position.x < 0) {
        score2++;
        reset_ball();
    } else if (ball.position.x > 800) {
        score1++;
        reset_ball();
    }
}
```

### 3.5 JSON 직렬화

```cpp
std::string GameState::to_json() const {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2);
    oss << "{";
    oss << "\"ball\":{\"x\":" << ball.position.x
        << ",\"y\":" << ball.position.y << "},";
    oss << "\"paddle1\":{\"y\":" << paddle1.y << "},";
    oss << "\"paddle2\":{\"y\":" << paddle2.y << "},";
    oss << "\"score1\":" << score1 << ",";
    oss << "\"score2\":" << score2;
    oss << "}";
    return oss.str();
}
```

### 3.6 입력 처리

```cpp
void PongServer::process_inputs() {
    std::lock_guard<std::mutex> lock(inputs_mutex_);

    for (const auto& [client_id, action] : pending_inputs_) {
        if (action == "up") {
            if (client_id == 1) {
                state_.paddle1.y -= state_.paddle1.speed * 0.01667f;
            } else {
                state_.paddle2.y -= state_.paddle2.speed * 0.01667f;
            }
        } else if (action == "down") {
            if (client_id == 1) {
                state_.paddle1.y += state_.paddle1.speed * 0.01667f;
            } else {
                state_.paddle2.y += state_.paddle2.speed * 0.01667f;
            }
        }
    }

    pending_inputs_.clear();
}
```

### 3.7 클라이언트 예시 (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:8083');

ws.onmessage = (e) => {
    const state = JSON.parse(e.data);
    drawGame(state);
};

document.addEventListener('keydown', (e) => {
    if (e.key === 'w') {
        ws.send(JSON.stringify({ action: 'up' }));
    } else if (e.key === 's') {
        ws.send(JSON.stringify({ action: 'down' }));
    }
});

function drawGame(state) {
    // Canvas 그리기
    ctx.clearRect(0, 0, 800, 600);

    // 공
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(state.ball.x, state.ball.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // 패들
    ctx.fillRect(40, state.paddle1.y - 50, 10, 100);
    ctx.fillRect(750, state.paddle2.y - 50, 10, 100);

    // 점수
    ctx.font = '30px Arial';
    ctx.fillText(`${state.score1} : ${state.score2}`, 350, 50);
}
```

### 3.8 빌드 & 테스트

```bash
# 빌드
make

# 실행
./lab1.4-ws-pong/pong_server.out 8083

# 웹 브라우저로 접속 (index.html)
# W/S 키로 패들 조작
# 60 FPS로 부드러운 움직임 확인
```

### 3.9 체크리스트

* [ ] 60 TPS 게임 루프가 정확히 동작 (16.67ms 간격)
* [ ] 공/패들 물리 시뮬레이션이 부드럽게 동작
* [ ] JSON 직렬화된 상태가 실시간으로 클라이언트에 전송
* [ ] 키보드 입력이 서버에 즉시 반영
* [ ] 충돌 감지 및 득점 처리가 정확함
* [ ] 2명의 플레이어가 동시에 게임 플레이 가능

---

## 4. Stage 1 후반부 정리

이 문서에서 다룬 내용:

* **Lab 1.3**: WebSocket 채팅 서버 (핸드셰이크, 프레임 파싱, 브로드캐스트)
* **Lab 1.4**: WebSocket Pong 서버 (60 TPS, 물리, JSON)

### 4.1 핵심 학습 포인트

1. **WebSocket 프로토콜** 직접 구현
2. **고속 게임 루프** (60 TPS = 16.67ms)
3. **물리 시뮬레이션** (충돌 감지, 속도 계산)
4. **JSON 직렬화**로 상태 동기화
5. **실시간 입력 처리**

### 4.2 다음 단계

**문서 5 – UDP 코어 (v1.0-1.1)**로 넘어가면:

* **TCP/WebSocket의 한계** 이해
* **UDP 권위 서버** 아키텍처
* **신뢰성 레이어** (seq, ack, 재전송)
* **Protobuf** 메시지 직렬화

Lab 1.1-1.4를 모두 마치면 Stage 1 완료!
이제 실전 네트워크 게임 엔진을 만들 준비가 되었다.
