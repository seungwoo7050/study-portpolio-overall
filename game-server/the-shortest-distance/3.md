# 문서 3. TCP 기초 (Lab 1.1-1.2)

> 이 문서는 **Stage 1 전반부**를 다룬다.
> C++ 기본기 (문서 2)는 이미 갖췄다고 가정한다.

---

## 0. 전제 / 목표

### 전제

* C++ 기본 문법 이해 (참조자, RAII, 스마트 포인터)
* CMake로 프로젝트 빌드 가능
* 소켓 API 기본 개념 파악

### 이 문서의 목표

**TCP 기반 멀티스레드 서버**의 기본 패턴을 익힌다:

* Lab 1.1: TCP 에코 서버 (멀티스레드 기본)
* Lab 1.2: 턴제 전투 서버 (10 TPS 타이머)

최종적으로 이 정도를 목표로 한다:

* 멀티스레드 TCP 서버 작성 가능
* 타이머 기반 게임 루프 구현 가능
* RAII 패턴으로 리소스 관리

---

## 1. Lab 1.1: TCP 에코 서버

### 1.1 목표

* TCP 소켓을 RAII 클래스로 감싸기
* 멀티스레드로 여러 클라이언트 동시 처리
* 명령어 처리 (`exit`, `shutdown`)

### 1.2 핵심 구조

**Socket 클래스**

* 문서 2에서 다룬 RAII 패턴 적용
* `create_tcp()`, `bind()`, `listen()`, `accept()`
* `receive()`, `send_all()`, `close_socket()`

```cpp
class Socket {
public:
    Socket();
    explicit Socket(int fd);
    Socket(const Socket&) = delete;
    Socket& operator=(const Socket&) = delete;
    Socket(Socket&& other) noexcept;
    Socket& operator=(Socket&& other) noexcept;
    ~Socket();

    static Socket create_tcp();
    void set_reuse_address(bool enable);
    void bind(uint16_t port);
    void listen(int backlog = SOMAXCONN);
    Socket accept();
    ssize_t receive(uint8_t* buffer, size_t length);
    void send_all(const uint8_t* data, size_t length);
    void shutdown();
    void close();

private:
    int fd_;
};
```

**EchoServer 클래스**

```cpp
class EchoServer {
public:
    EchoServer(uint16_t port, std::string prefix = {});
    ~EchoServer();

    void run();
    void stop();

private:
    void accept_loop();
    void handle_client(Socket client_socket);
    void wait_for_clients();

    uint16_t port_;
    std::string prefix_;
    std::atomic<bool> running_;
    Socket server_socket_;
    std::vector<std::thread> client_threads_;
    std::mutex threads_mutex_;
};
```

### 1.3 동작 시나리오

1. `main()`에서 `EchoServer server(8080, "SERVER");` 생성
2. `server.run()` 호출
3. `accept_loop()`에서 클라이언트 대기
4. 새 클라이언트 접속 시 `handle_client()` 스레드 생성
5. 클라이언트가 메시지 전송 → prefix 붙여서 에코
6. `exit` 명령 → 해당 클라이언트만 종료
7. `shutdown` 명령 → 서버 전체 종료

### 1.4 핵심 구현

**accept_loop()**

```cpp
void EchoServer::accept_loop() {
    while (running_) {
        try {
            Socket client = server_socket_.accept();

            std::lock_guard<std::mutex> lock(threads_mutex_);
            client_threads_.emplace_back([this, client = std::move(client)]() mutable {
                handle_client(std::move(client));
            });
        } catch (const std::exception& e) {
            if (running_) {
                std::cerr << "Accept error: " << e.what() << "\n";
            }
        }
    }
}
```

**handle_client()**

```cpp
void EchoServer::handle_client(Socket client) {
    try {
        uint8_t buffer[1024];

        while (true) {
            ssize_t n = client.receive(buffer, sizeof(buffer));
            if (n == 0) break;  // 클라이언트 종료

            std::string msg(reinterpret_cast<char*>(buffer), n);

            // 명령어 처리
            if (msg.find("exit") != std::string::npos) {
                break;
            }
            if (msg.find("shutdown") != std::string::npos) {
                stop();
                break;
            }

            // 에코
            std::string response = prefix_.empty() ? msg : "[" + prefix_ + "] " + msg;
            client.send_all(reinterpret_cast<const uint8_t*>(response.data()),
                          response.size());
        }
    } catch (const std::exception& e) {
        std::cerr << "Client handler error: " << e.what() << "\n";
    }
}
```

### 1.5 빌드 & 테스트

```bash
# 빌드
cd gameserver-fundamentals/build
cmake ..
make

# 실행
./lab1.1-tcp-echo/echo_server.out 8080 "SERVER"

# 테스트 (별도 터미널)
telnet localhost 8080
# 입력: hello
# 출력: [SERVER] hello
# 입력: exit
# 연결 종료
```

### 1.6 체크리스트

* [ ] Socket 클래스를 RAII 패턴으로 작성하고, 소멸자에서 자동 close() 호출 확인
* [ ] 여러 클라이언트가 동시 접속하여 독립적으로 메시지 주고받기 가능
* [ ] `exit` 명령으로 개별 클라이언트만 종료
* [ ] `shutdown` 명령으로 서버 전체 종료
* [ ] Valgrind로 메모리 누수 없음을 확인

---

## 2. Lab 1.2: 턴제 전투 서버 (10 TPS)

### 2.1 목표

* 10 TPS (Ticks Per Second) 타이머 구현
* 플레이어 상태 관리 (체력, 공격력)
* 턴제 전투 로직 (공격, 회복, 대기)
* 승패 판정

### 2.2 핵심 구조

**Player 클래스**

```cpp
class Player {
public:
    Player(int id, Socket socket);

    int id() const { return id_; }
    int hp() const { return hp_; }
    bool is_alive() const { return hp_ > 0; }

    void attack(int damage);
    void heal(int amount);
    void send_message(const std::string& msg);

private:
    int id_;
    int hp_{100};
    int max_hp_{100};
    Socket socket_;
};
```

**GameSession 클래스**

```cpp
class GameSession {
public:
    GameSession(Player p1, Player p2);

    void run();  // 10 TPS 게임 루프

private:
    void tick();  // 한 틱 처리
    void process_inputs();
    void apply_turn_action();
    void broadcast_state();
    void announce_winner();

    Player player1_;
    Player player2_;
    int turn_count_{0};
    int current_turn_{1};  // 1 or 2
    std::chrono::steady_clock::time_point last_tick_;

    std::string p1_action_{"wait"};
    std::string p2_action_{"wait"};
};
```

### 2.3 10 TPS 타이머 구현

```cpp
void GameSession::run() {
    using namespace std::chrono;
    const auto tick_duration = milliseconds(100);  // 10 TPS = 100ms per tick

    last_tick_ = steady_clock::now();
    broadcast_state();

    while (player1_.is_alive() && player2_.is_alive()) {
        auto now = steady_clock::now();
        auto elapsed = duration_cast<milliseconds>(now - last_tick_);

        if (elapsed >= tick_duration) {
            tick();
            last_tick_ = now;
        } else {
            // 남은 시간만큼 sleep
            std::this_thread::sleep_for(tick_duration - elapsed);
        }
    }

    announce_winner();
}
```

### 2.4 틱 처리

```cpp
void GameSession::tick() {
    turn_count_++;

    // 입력 수신 (논블로킹)
    process_inputs();

    // 턴 액션 적용
    apply_turn_action();

    // 상태 브로드캐스트
    broadcast_state();

    // 턴 교대
    current_turn_ = (current_turn_ == 1) ? 2 : 1;

    // 액션 초기화
    p1_action_ = "wait";
    p2_action_ = "wait";
}
```

### 2.5 전투 로직

```cpp
void GameSession::apply_turn_action() {
    if (current_turn_ == 1) {
        if (p1_action_ == "attack") {
            int damage = 20;
            player2_.attack(damage);
            player1_.send_message("You attacked! Enemy HP: " +
                                std::to_string(player2_.hp()));
            player2_.send_message("You were attacked! Your HP: " +
                                std::to_string(player2_.hp()));
        } else if (p1_action_ == "heal") {
            int amount = 15;
            player1_.heal(amount);
            player1_.send_message("You healed! Your HP: " +
                                std::to_string(player1_.hp()));
        }
    } else {
        // Player 2 턴
        if (p2_action_ == "attack") {
            int damage = 20;
            player1_.attack(damage);
            player2_.send_message("You attacked! Enemy HP: " +
                                std::to_string(player1_.hp()));
            player1_.send_message("You were attacked! Your HP: " +
                                std::to_string(player1_.hp()));
        } else if (p2_action_ == "heal") {
            int amount = 15;
            player2_.heal(amount);
            player2_.send_message("You healed! Your HP: " +
                                std::to_string(player2_.hp()));
        }
    }
}
```

### 2.6 빌드 & 테스트

```bash
# 빌드
make

# 실행
./lab1.2-turn-combat/game_server.out 8081

# 클라이언트 1 (별도 터미널)
telnet localhost 8081
# 대기: Player 1 매칭 대기
# 접속 후: Player 1로 게임 시작
# 입력: attack (또는 heal, wait)

# 클라이언트 2 (또 다른 터미널)
telnet localhost 8081
# Player 2로 매칭됨
# 턴제 전투 시작
```

### 2.7 체크리스트

* [ ] 10 TPS 타이머가 정확히 동작 (100ms 간격)
* [ ] 2명의 플레이어가 턴을 번갈아 가며 전투
* [ ] 공격/회복/대기 액션이 정확히 적용
* [ ] 체력이 0 이하가 되면 게임 종료
* [ ] 승자 판정 및 결과 메시지 출력

---

## 3. Stage 1 전반부 정리

이 문서에서 다룬 내용:

* **Lab 1.1**: TCP 에코 서버 (멀티스레드, RAII)
* **Lab 1.2**: 턴제 전투 서버 (10 TPS 타이머)

### 3.1 핵심 학습 포인트

1. **RAII 패턴**으로 소켓 리소스 안전하게 관리
2. **멀티스레딩**으로 여러 클라이언트 동시 처리
3. **타이머 기반 게임 루프** 구현 (`std::chrono`)
4. **게임 상태 관리** (플레이어, 턴)
5. **명령어 처리** 및 **브로드캐스트**

### 3.2 다음 단계

**문서 4 – WebSocket (Lab 1.3-1.4)**로 넘어가면:

* WebSocket 프로토콜 이해
* 60 TPS 고속 게임 루프
* 물리 시뮬레이션
* JSON 직렬화

TCP 기초가 탄탄하면 WebSocket도 쉽게 이해할 수 있다.
