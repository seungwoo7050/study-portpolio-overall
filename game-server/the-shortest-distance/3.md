# 문서 3. gameserver-fundamentals (Lab 1.1-1.4)

> 이 문서는 **Stage 1의 "Lab 실습" 부분**을 채운다.
> 문서 2 수준의 C++ 기본기는 이미 갖췄다고 가정한다.

---

## 0. 전제 / 목표

### 전제

* C++ 기본 문법 이해 (참조자, RAII, 스마트 포인터)
* CMake로 프로젝트 빌드 가능
* 소켓 API 기본 개념 파악

### 이 문서의 목표

**4개의 Lab을 순서대로 구현**하면서 게임 서버의 핵심 패턴을 익힌다:

* Lab 1.1: TCP 에코 서버 (멀티스레드 기본)
* Lab 1.2: 턴제 전투 서버 (10 TPS 타이머)
* Lab 1.3: WebSocket 채팅 서버 (WebSocket 프로토콜)
* Lab 1.4: WebSocket Pong 서버 (60 TPS 게임 루프)

최종적으로 이 정도를 목표로 한다:

* 멀티스레드 TCP 서버 작성 가능
* 타이머 기반 게임 루프 구현 가능
* WebSocket 프로토콜 이해 및 구현 가능
* 실시간 게임 서버의 기본 아키텍처 파악

---

## 1. Lab 구성 개요

### 1.1 Lab 구조

```text
gameserver-fundamentals/
├── lab1.1-tcp-echo/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── socket.hpp
│   └── echo_server.hpp
├── lab1.2-turn-combat/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── socket.hpp
│   ├── game_session.hpp
│   └── player.hpp
├── lab1.3-ws-chat/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── websocket.hpp
│   └── chat_server.hpp
└── lab1.4-ws-pong/
    ├── CMakeLists.txt
    ├── main.cpp
    ├── websocket.hpp
    ├── pong_server.hpp
    └── game_state.hpp
```

### 1.2 빌드 방법

```bash
cd gameserver-fundamentals
mkdir build
cd build
cmake ..
make

# 특정 Lab만 빌드
cmake -DENABLE_LAB1_1=ON -DENABLE_LAB1_2=OFF ..
make
```

---

## 2. Lab 1.1: TCP 에코 서버

### 2.1 목표

* TCP 소켓을 RAII 클래스로 감싸기
* 멀티스레드로 여러 클라이언트 동시 처리
* 명령어 처리 (`exit`, `shutdown`)

### 2.2 핵심 구조

**Socket 클래스**

* 문서 2에서 다룬 RAII 패턴 적용
* `create_tcp()`, `bind()`, `listen()`, `accept()`
* `receive()`, `send_all()`, `close_socket()`

**EchoServer 클래스**

```cpp
class EchoServer {
public:
    EchoServer(uint16_t port, std::string prefix = {});
    ~EchoServer();

    void run();
    void stop();

private:
    void accept_loop();
    void handle_client(Socket client_socket);
    void wait_for_clients();

    uint16_t port_;
    std::string prefix_;
    std::atomic<bool> running_;
    Socket server_socket_;
    std::vector<std::thread> client_threads_;
    std::mutex threads_mutex_;
};
```

### 2.3 동작 시나리오

1. `main()`에서 `EchoServer server(8080);` 생성
2. `server.run()` 호출
3. `accept_loop()`에서 클라이언트 대기
4. 새 클라이언트 접속 시 `handle_client()` 스레드 생성
5. 클라이언트가 메시지 전송 → prefix 붙여서 에코
6. `exit` 명령 → 해당 클라이언트만 종료
7. `shutdown` 명령 → 서버 전체 종료

### 2.4 테스트

```bash
# 서버 실행
./lab1.1-tcp-echo/echo_server.out 8080 "SERVER"

# 클라이언트 (별도 터미널)
telnet localhost 8080
# 입력: hello
# 출력: [SERVER] hello
# 입력: exit
# 연결 종료
```

---

## 3. Lab 1.2: 턴제 전투 서버 (10 TPS)

### 3.1 목표

* 10 TPS (Ticks Per Second) 타이머 구현
* 플레이어 상태 관리 (체력, 공격력)
* 턴제 전투 로직 (공격, 회복, 대기)
* 승패 판정

### 3.2 핵심 구조

**Player 클래스**

```cpp
class Player {
public:
    Player(int id, Socket socket);

    int id() const { return id_; }
    int hp() const { return hp_; }
    bool is_alive() const { return hp_ > 0; }

    void attack(int damage);
    void heal(int amount);

private:
    int id_;
    int hp_{100};
    Socket socket_;
};
```

**GameSession 클래스**

```cpp
class GameSession {
public:
    GameSession(Player p1, Player p2);

    void run();  // 10 TPS 게임 루프

private:
    void tick();  // 한 틱 처리
    void process_input();
    void broadcast_state();

    Player player1_;
    Player player2_;
    int turn_count_{0};
    std::chrono::steady_clock::time_point last_tick_;
};
```

### 3.3 타이머 구현 패턴

```cpp
void GameSession::run() {
    using namespace std::chrono;
    const auto tick_duration = milliseconds(100);  // 10 TPS = 100ms per tick

    last_tick_ = steady_clock::now();

    while (player1_.is_alive() && player2_.is_alive()) {
        auto now = steady_clock::now();
        auto elapsed = duration_cast<milliseconds>(now - last_tick_);

        if (elapsed >= tick_duration) {
            tick();
            last_tick_ = now;
        } else {
            // 남은 시간만큼 sleep
            std::this_thread::sleep_for(tick_duration - elapsed);
        }
    }

    // 게임 종료 처리
    announce_winner();
}
```

### 3.4 테스트

```bash
# 서버 실행
./lab1.2-turn-combat/game_server.out 8081

# 클라이언트 1
telnet localhost 8081
# 입력: attack
# 출력: You attacked! Enemy HP: 90

# 클라이언트 2
telnet localhost 8081
# 입력: heal
# 출력: You healed! Your HP: 100
```

---

## 4. Lab 1.3: WebSocket 채팅 서버

### 4.1 목표

* WebSocket 핸드셰이크 구현
* 프레임 파싱 및 인코딩
* 브로드캐스트 메시지 전송

### 4.2 WebSocket 프로토콜 기본

**핸드셰이크 (HTTP Upgrade)**

클라이언트 요청:

```
GET /chat HTTP/1.1
Host: localhost:8082
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

서버 응답:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**프레임 구조**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
```

### 4.3 핵심 구조

**WebSocket 클래스**

```cpp
class WebSocket {
public:
    explicit WebSocket(Socket socket);

    bool handshake();  // HTTP Upgrade 처리
    std::string receive_frame();  // 프레임 수신 & 파싱
    void send_frame(const std::string& message);  // 프레임 전송

private:
    std::string parse_websocket_key(const std::string& request);
    std::string compute_accept_key(const std::string& key);

    Socket socket_;
};
```

**ChatServer 클래스**

```cpp
class ChatServer {
public:
    explicit ChatServer(uint16_t port);

    void run();
    void broadcast(const std::string& message);

private:
    void handle_client(Socket socket);

    uint16_t port_;
    std::atomic<bool> running_;
    std::vector<std::shared_ptr<WebSocket>> clients_;
    std::mutex clients_mutex_;
};
```

### 4.4 테스트

```bash
# 서버 실행
./lab1.3-ws-chat/chat_server.out 8082

# 웹 브라우저에서 접속
# 개발자 도구 콘솔에서:
const ws = new WebSocket('ws://localhost:8082');
ws.onmessage = (e) => console.log('Received:', e.data);
ws.send('Hello from browser!');
```

---

## 5. Lab 1.4: WebSocket Pong 서버 (60 TPS)

### 5.1 목표

* 60 TPS 게임 루프 구현
* 공/패들 물리 시뮬레이션
* JSON 직렬화/역직렬화
* 실시간 상태 동기화

### 5.2 핵심 구조

**GameState 클래스**

```cpp
struct Vec2 {
    float x{0.0f};
    float y{0.0f};
};

struct Ball {
    Vec2 position;
    Vec2 velocity;
    float radius{10.0f};
};

struct Paddle {
    float y{0.0f};
    float speed{300.0f};  // pixels per second
};

class GameState {
public:
    void update(float dt);  // 물리 업데이트
    std::string to_json() const;  // JSON 직렬화

    Ball ball;
    Paddle paddle1;
    Paddle paddle2;
    int score1{0};
    int score2{0};
};
```

**PongServer 클래스**

```cpp
class PongServer {
public:
    explicit PongServer(uint16_t port);

    void run();  // 60 TPS 게임 루프

private:
    void tick(float dt);
    void process_inputs();
    void broadcast_state();

    uint16_t port_;
    std::atomic<bool> running_;
    GameState state_;
    std::vector<std::shared_ptr<WebSocket>> clients_;
    std::mutex clients_mutex_;
};
```

### 5.3 60 TPS 게임 루프

```cpp
void PongServer::run() {
    using namespace std::chrono;
    const auto tick_duration = microseconds(16667);  // 60 TPS ≈ 16.67ms

    auto last_tick = steady_clock::now();

    while (running_) {
        auto now = steady_clock::now();
        auto elapsed = duration_cast<microseconds>(now - last_tick);

        if (elapsed >= tick_duration) {
            float dt = elapsed.count() / 1000000.0f;  // 초 단위
            tick(dt);
            last_tick = now;
        } else {
            std::this_thread::sleep_for(tick_duration - elapsed);
        }
    }
}

void PongServer::tick(float dt) {
    process_inputs();
    state_.update(dt);
    broadcast_state();
}
```

### 5.4 물리 업데이트

```cpp
void GameState::update(float dt) {
    // 공 이동
    ball.position.x += ball.velocity.x * dt;
    ball.position.y += ball.velocity.y * dt;

    // 벽 충돌
    if (ball.position.y < 0 || ball.position.y > 600) {
        ball.velocity.y *= -1;
    }

    // 패들 충돌
    if (ball.position.x < 50 && /* paddle1 범위 체크 */) {
        ball.velocity.x *= -1;
    }

    // 득점 체크
    if (ball.position.x < 0) {
        score2++;
        reset_ball();
    } else if (ball.position.x > 800) {
        score1++;
        reset_ball();
    }
}
```

### 5.5 JSON 직렬화

```cpp
std::string GameState::to_json() const {
    // 간단한 JSON 생성 (실제로는 nlohmann/json 같은 라이브러리 사용 권장)
    std::ostringstream oss;
    oss << "{";
    oss << "\"ball\":{\"x\":" << ball.position.x << ",\"y\":" << ball.position.y << "},";
    oss << "\"paddle1\":{\"y\":" << paddle1.y << "},";
    oss << "\"paddle2\":{\"y\":" << paddle2.y << "},";
    oss << "\"score1\":" << score1 << ",";
    oss << "\"score2\":" << score2;
    oss << "}";
    return oss.str();
}
```

### 5.6 테스트

```bash
# 서버 실행
./lab1.4-ws-pong/pong_server.out 8083

# 웹 브라우저에서 접속 (index.html)
# Canvas로 게임 화면 렌더링
# 키보드 입력으로 패들 이동
```

**클라이언트 예시 (JavaScript)**

```javascript
const ws = new WebSocket('ws://localhost:8083');

ws.onmessage = (e) => {
    const state = JSON.parse(e.data);
    // Canvas에 그리기
    drawBall(state.ball.x, state.ball.y);
    drawPaddle(state.paddle1.y, state.paddle2.y);
    updateScore(state.score1, state.score2);
};

document.addEventListener('keydown', (e) => {
    if (e.key === 'w') {
        ws.send(JSON.stringify({ action: 'move', dir: 'up' }));
    } else if (e.key === 's') {
        ws.send(JSON.stringify({ action: 'move', dir: 'down' }));
    }
});
```

---

## 6. Stage 1 체크리스트

이 문서 기준으로, 아래를 만족하면 Stage 1의 "gameserver-fundamentals"는 통과로 본다.

* [ ] Lab 1.1: TCP 에코 서버를 멀티스레드로 구현하고, `exit`/`shutdown` 명령을 처리할 수 있다.
* [ ] Lab 1.2: 10 TPS 턴제 전투 서버를 구현하고, 타이머가 정확히 동작하는 것을 확인했다.
* [ ] Lab 1.3: WebSocket 핸드셰이크와 프레임 파싱을 구현하고, 브라우저에서 채팅 메시지를 주고받을 수 있다.
* [ ] Lab 1.4: 60 TPS Pong 서버를 구현하고, 물리 시뮬레이션이 정확히 동작하는 것을 확인했다.
* [ ] 모든 Lab에서 RAII 패턴을 적용해서 리소스 누수가 없는 것을 확인했다.
* [ ] 멀티스레드 환경에서 `std::mutex`를 사용해 공유 자원을 보호하는 패턴을 적용했다.

여기까지가 문서 3에서 다루는 범위다.
다음 문서는 **문서 4**로, netcode-core (UDP 권위 서버 + 신뢰성 레이어 + 스냅샷 + 메트릭 + 매칭)로 넘어간다.
