# 문서 5. UDP 코어 (v1.0-1.1: 신뢰성 레이어 & 스냅샷)

> 이 문서는 **Stage 2** 전반부용이다.
> 전제:
>
> * Stage 1까지 (gameserver-fundamentals Lab 1.1-1.4) 구현 완료
> * TCP/WebSocket 기반 서버 구현 경험
> * 이제 **UDP 기반 권위 서버**를 직접 만들고, 신뢰성 레이어를 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* C++ 기본 문법 숙지
* CMake 빌드 시스템 사용 가능
* TCP/WebSocket 서버 구현 경험 (Lab 1.1-1.4)
* 멀티스레딩 기본 개념 이해

### 이 문서의 목표

1. **UDP 권위 서버** 아키텍처 이해
2. **신뢰성 레이어** 구현 (재전송, ACK, 순서 보장)
3. **스냅샷 & 델타 압축**으로 대역폭 최적화
4. **Protobuf** 메시지 직렬화
5. **클라이언트측 예측/보간** 개념 이해

### 이 문서가 다루는 범위

* **v1.0**: UDP 권위 서버 & 신뢰성 레이어
* **v1.1**: 스냅샷 & 델타 압축

**다루지 않는 범위** (다음 문서 6.md에서):

* v1.2: 메트릭 & 모니터링
* v1.3: 매치메이킹 & 방 분리

---

## 1. netcode-core 프로젝트 구조

### 1.1 디렉토리 구조

```text
netcode-core/
├── proto/
│   └── mini.proto           # Protobuf 메시지 정의
├── core/
│   ├── clock.hpp            # 시간 측정
│   └── counters.hpp         # 메트릭 카운터
├── net/
│   ├── endpoint.hpp         # IP:Port 추상화
│   ├── itransport.hpp       # 전송 계층 인터페이스
│   └── udp_transport.hpp    # UDP 구현
├── sync/
│   ├── snapshot.hpp         # 스냅샷 인코딩
│   └── delta.hpp            # 델타 압축
├── match/
│   ├── matcher.hpp          # 매치메이커 (v1.3)
│   └── room.hpp             # 방 관리 (v1.3)
├── metrics/
│   └── prometheus.hpp       # Prometheus 메트릭 (v1.2)
└── apps/
    ├── pong_udp/            # Pong 게임 서버
    ├── matcher/             # 매치 서버 (v1.3)
    └── loadgen/             # 부하 테스트 생성기
```

### 1.2 빌드 방법

```bash
cd netcode-core
mkdir build
cd build
cmake ..
make -j4

# 실행 파일 위치
ls apps/pong_udp/bin/pong_server
```

### 1.3 참조할 design 문서

* `design/netcode-core/1.0-udp-authority-core.md` - v1.0 상세 설계
* `design/netcode-core/1.1-snapshot-delta.md` - v1.1 상세 설계

---

## 2. v1.0: UDP 권위 서버 & 신뢰성 레이어

### 2.1 목표

* UDP 소켓으로 클라이언트 통신
* 시퀀스 번호, ACK, ACK 비트마스크 구현
* 재전송 큐 + 타임아웃 관리
* 패킷 필터링 (중복, 오래된 패킷)

### 2.2 왜 UDP인가?

**TCP/WebSocket의 한계**:

* **Head-of-Line Blocking**: 한 패킷 손실 시 이후 패킷 모두 대기
* 실시간 게임에서는 오래된 상태보다 최신 상태가 중요
* 불필요한 재전송으로 지연 증가

**UDP의 장점**:

* 패킷 단위 독립 처리
* 오래된 상태 패킷은 과감히 버릴 수 있음
* 송신 즉시 전달

**트레이드오프**:

* 패킷 손실, 순서 뒤바뀜, 중복 전달을 직접 처리해야 함
* 최소한의 신뢰성 레이어 필요

### 2.3 UDP 패킷 구조

```text
┌────────────────────────────────────┐
│ UdpHeader (8 bytes)                │
│  - seq      (uint16, 2 bytes)      │
│  - ack      (uint16, 2 bytes)      │
│  - ack_bits (uint32, 4 bytes)      │
├────────────────────────────────────┤
│ Payload (protobuf 직렬화 메시지)    │
│  - Input / World / ServerAck 등    │
└────────────────────────────────────┘
```

### 2.4 시퀀스 번호 & ACK 비트마스크

**시퀀스 번호**:

* 범위: 0 ~ 65535 (uint16)
* 순환: 65535 다음은 0
* 비교 함수: `is_seq_newer(lhs, rhs)`

**ACK 비트마스크**:

* `ack`: 수신한 가장 최신 시퀀스
* `ack_bits`: `ack` 이전 32개 패킷의 수신 비트마스크

```
ack = 100, ack_bits = 0b...1011
-> seq 100 수신 (ack)
-> seq 99 수신 (bit 0 = 1)
-> seq 98 손실 (bit 1 = 0)
-> seq 97 수신 (bit 2 = 1)
-> seq 96 수신 (bit 3 = 1)
```

### 2.5 ITransport 인터페이스

```cpp
class ITransport {
public:
    virtual void start(ReceiveHandler handler) = 0;
    virtual void stop() = 0;
    virtual void send(const Endpoint&, std::vector<uint8_t> data, bool reliable) = 0;
    virtual void update() = 0;  // 재전송 처리 등
    virtual void set_metrics_enabled(bool enabled) = 0;
    virtual Counters sample_counters() const = 0;
};
```

### 2.6 UdpTransport 구현

```cpp
class UdpTransport : public ITransport {
public:
    explicit UdpTransport(uint16_t port);

    void start(ReceiveHandler handler) override;
    void stop() override;
    void send(const Endpoint& ep, std::vector<uint8_t> data, bool reliable) override;
    void update() override;

private:
    void receive_loop();
    void process_acks(const Endpoint& ep, uint16_t ack, uint32_t ack_bits);
    void resend_timed_out_packets();

    int socket_fd_;
    std::atomic<bool> running_;
    std::thread receive_thread_;

    // 클라이언트별 송수신 상태
    std::map<Endpoint, SendState> send_states_;
    std::map<Endpoint, ReceiveState> recv_states_;
    std::mutex states_mutex_;
};
```

### 2.7 재전송 로직

```cpp
void UdpTransport::update() {
    auto now = Clock::now();

    std::lock_guard<std::mutex> lock(states_mutex_);
    for (auto& [ep, state] : send_states_) {
        for (auto& pkt : state.pending_packets) {
            if (now >= pkt.next_send) {
                // 재전송
                send_raw(ep, pkt.payload);
                pkt.last_sent = now;
                pkt.next_send = now + timeout_duration;
                pkt.retries++;

                if (pkt.retries > max_retries) {
                    // 타임아웃
                    counters_.reliable_timeouts_total++;
                    // 패킷 제거
                }
            }
        }
    }
}
```

### 2.8 구현 가이드

**구현 순서**:

1. `Endpoint` 클래스 구현 (IP:Port 추상화)
2. `ITransport` 인터페이스 정의
3. `UdpTransport` 기본 송수신 구현
4. 시퀀스 번호 & ACK 비트마스크 추가
5. 재전송 큐 & 타임아웃 로직 추가
6. 패킷 필터링 (중복, 오래된 패킷) 추가

**테스트 방법**:

```bash
# 3% 패킷 손실 시뮬레이션
sudo tc qdisc add dev lo root netem loss 3%

# 서버 실행
./apps/pong_udp/bin/pong_server 9000

# 클라이언트 실행 후 입력 테스트
# 패킷 손실 환경에서도 입력이 잘 전달되는지 확인
```

**참조 문서**:

* `design/netcode-core/1.0-udp-authority-core.md` - 상세 설계 및 구현 가이드

---

## 3. v1.1: 스냅샷 & 델타 압축

### 3.1 목표

* Protobuf로 메시지 정의
* 전체 스냅샷 vs 델타 스냅샷
* 클라이언트측 예측/보간
* 대역폭 측정

### 3.2 Protobuf 메시지 정의

```protobuf
// proto/mini.proto
syntax = "proto3";

message Vec2 {
    float x = 1;
    float y = 2;
}

message Ball {
    Vec2 position = 1;
    Vec2 velocity = 2;
}

message Paddle {
    float y = 1;
}

message WorldSnapshot {
    uint32 tick = 1;
    Ball ball = 2;
    Paddle paddle1 = 3;
    Paddle paddle2 = 4;
    int32 score1 = 5;
    int32 score2 = 6;
}

message InputMessage {
    uint32 tick = 1;
    string action = 2;  // "up", "down", "none"
}
```

### 3.3 스냅샷 vs 델타

**전체 스냅샷** (Baseline):

* 모든 상태 정보 포함
* 클라이언트 최초 접속 시 전송
* 주기적으로 전송 (예: 1초마다)

**델타 스냅샷**:

* 이전 스냅샷 대비 변경된 필드만 전송
* 대역폭 절약
* 패킷 손실 시 다음 Baseline까지 대기

```cpp
class SnapshotEncoder {
public:
    std::vector<uint8_t> encode_full(const WorldSnapshot& snapshot);
    std::vector<uint8_t> encode_delta(const WorldSnapshot& current, const WorldSnapshot& baseline);
};

class SnapshotDecoder {
public:
    WorldSnapshot decode_full(const std::vector<uint8_t>& data);
    WorldSnapshot decode_delta(const std::vector<uint8_t>& data, const WorldSnapshot& baseline);
};
```

### 3.4 클라이언트측 예측/보간

**예측 (Client-side Prediction)**:

* 클라이언트가 입력을 즉시 로컬에 적용
* 서버 응답 대기 없이 즉각적인 피드백
* 서버 상태 수신 시 조정 (Reconciliation)

**보간 (Interpolation)**:

* 서버에서 받은 스냅샷 사이를 부드럽게 이어줌
* 렌더 시각을 실제보다 약간 지연 (예: 100ms)
* 자연스러운 움직임 제공

```javascript
// 클라이언트 예시 (JavaScript)
function update(dt) {
    // 1. 로컬 입력 예측
    applyInput(localInput);

    // 2. 서버 스냅샷 보간
    const renderTime = now() - 100;  // 100ms 지연
    const s1 = getSnapshotBefore(renderTime);
    const s2 = getSnapshotAfter(renderTime);
    const t = (renderTime - s1.time) / (s2.time - s1.time);
    const interpolated = lerp(s1, s2, t);

    // 3. 렌더링
    render(interpolated);
}
```

### 3.5 대역폭 최적화 비교

**전체 스냅샷** (60 TPS 기준):

* 패킷 크기: ~80 bytes (Protobuf 직렬화)
* 대역폭: 80 bytes × 60 = 4,800 bytes/s = **38.4 kbps**

**델타 스냅샷** (60 TPS 기준):

* Baseline (1초마다): 80 bytes
* Delta (평균 변경 필드 30%): ~25 bytes
* 대역폭: (80 + 25 × 59) / 60 ≈ **1,500 bytes/s = 12 kbps**

**절약률**: 약 **68%** 절약

### 3.6 구현 가이드

**구현 순서**:

1. Protobuf 메시지 정의 (`proto/mini.proto`)
2. `SnapshotEncoder`/`SnapshotDecoder` 구현
3. 전체 스냅샷 인코딩/디코딩
4. 델타 스냅샷 인코딩/디코딩 (필드별 비교)
5. Baseline 주기 설정 (예: 1초마다)
6. 대역폭 측정 및 비교

**테스트 방법**:

```bash
# 대역폭 측정
tcpdump -i lo -n udp port 9000 -w /tmp/capture.pcap

# 서버 실행
./apps/pong_udp/bin/pong_server 9000

# 클라이언트 실행 후 1분간 플레이

# 대역폭 분석
tcpdump -r /tmp/capture.pcap | wc -l  # 패킷 수
tcpdump -r /tmp/capture.pcap -v | grep length  # 패킷 크기
```

**참조 문서**:

* `design/netcode-core/1.1-snapshot-delta.md` - 상세 설계 및 델타 압축 알고리즘

---

## 4. v1.0-1.1 체크리스트

이 문서 기준으로, 아래를 만족하면 UDP 코어 (v1.0-1.1)는 통과로 본다.

### v1.0 체크리스트

* [ ] UDP 소켓으로 클라이언트와 통신하고, 시퀀스 번호/ACK 비트마스크를 구현했다.
* [ ] 재전송 큐를 구현하고, 타임아웃으로 패킷을 재전송할 수 있다.
* [ ] 3% 패킷 손실 환경에서도 중요한 메시지(입력, 점수)가 재전송을 통해 전달되는 것을 확인했다.
* [ ] 중복 패킷과 오래된 패킷을 필터링하여 버릴 수 있다.

### v1.1 체크리스트

* [ ] Protobuf로 메시지를 직렬화하고, 전체 스냅샷을 인코딩/디코딩할 수 있다.
* [ ] 델타 스냅샷으로 대역폭을 절약했다 (최소 50% 이상).
* [ ] Baseline 스냅샷을 주기적으로 전송하여 패킷 손실 시 복구할 수 있다.
* [ ] 대역폭 측정을 통해 전체 스냅샷 vs 델타 스냅샷의 차이를 확인했다.
* [ ] (선택) 클라이언트측 예측/보간을 구현해서 부드러운 움직임을 제공했다.

여기까지 구현하면:

* **TCP/WebSocket 기반 기본 서버** (Lab 1.1-1.4)
* **UDP 기반 권위 서버 + 신뢰성 레이어** (v1.0)
* **스냅샷 & 델타 압축** (v1.1)

까지 완성된 상태다.

**다음 단계** (문서 6.md):

* v1.2: 메트릭 & 모니터링
* v1.3: 매치메이킹 & 방 분리

---

## 5. 추가 학습 자료

### 5.1 네트워크 게임 프로그래밍

* Glenn Fiedler's "Networking for Game Programmers" 시리즈
* Valve's "Source Multiplayer Networking"
* Overwatch의 "Gameplay Architecture and Netcode"

### 5.2 신뢰성 메커니즘

* Enet 라이브러리 (신뢰성 레이어 참고)
* QUIC 프로토콜 (ACK 메커니즘 참고)
* RakNet (상용 게임 네트워크 엔진)

### 5.3 상태 동기화

* Quake III Arena 소스 코드 (스냅샷 시스템)
* Age of Empires II (델타 압축)
* Counter-Strike (예측 & 보간)

---

## 6. 자주 묻는 질문

**Q1: UDP는 신뢰할 수 없는데, 왜 게임 서버에 사용하나요?**

A: TCP는 **모든 패킷의 순서를 보장**하려다가 한 패킷이 손실되면 이후 패킷을 모두 막습니다 (Head-of-Line Blocking). 실시간 게임에서는 100ms 전 상태보다 지금 상태가 더 중요하므로, 오래된 패킷은 버리고 최신 상태를 받는 것이 낫습니다. UDP는 이를 가능하게 하지만, **중요한 메시지** (예: 점수, 게임 종료)는 재전송으로 보장해야 합니다.

**Q2: ACK 비트마스크는 왜 필요한가요? ACK만으로는 부족한가요?**

A: ACK만으로는 **어떤 패킷이 손실되었는지** 알 수 없습니다. 예를 들어 `ack=100`이면 seq 100까지 받았다는 뜻이지만, seq 98이 손실되었는지는 모릅니다. ACK 비트마스크는 `ack` 이전 32개 패킷의 수신 여부를 비트로 표현하여, **선택적 재전송**을 가능하게 합니다.

**Q3: 델타 스냅샷이 손실되면 어떻게 하나요?**

A: 델타 스냅샷은 **Baseline 스냅샷**을 기준으로 변경 사항만 전송합니다. 델타가 손실되면 다음 Baseline까지 대기하거나, 클라이언트가 마지막으로 받은 Baseline을 기준으로 다음 델타를 적용합니다. 보통 **1초마다 Baseline**을 전송하여 복구 시간을 제한합니다.

**Q4: 클라이언트측 예측은 서버와 다른 결과를 만들지 않나요?**

A: 맞습니다. 클라이언트는 로컬에서 입력을 즉시 적용하지만, 서버가 최종 권위를 가집니다. 서버 응답이 오면 **Reconciliation** (조정) 과정을 통해 클라이언트 상태를 서버 상태에 맞춥니다. 이 과정에서 **rubber-banding** (순간 이동)이 발생할 수 있지만, 대부분의 경우 예측이 정확하여 눈에 띄지 않습니다.

**Q5: Protobuf 대신 JSON을 써도 되나요?**

A: 기술적으로는 가능하지만, **대역폭과 CPU 비용**이 훨씬 큽니다. Protobuf는 바이너리 직렬화로 JSON 대비 **5~10배 작은 패킷 크기**를 만들고, 파싱 속도도 훨씬 빠릅니다. 60 TPS 게임 서버에서는 이 차이가 매우 크게 나타납니다.
