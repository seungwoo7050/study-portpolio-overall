# 문서 6. 프로덕션 (v1.2-1.3: 메트릭 & 매치메이킹)

> 이 문서는 **Stage 2** 후반부용이다.
> 전제:
>
> * Stage 1까지 (gameserver-fundamentals Lab 1.1-1.4) 구현 완료
> * UDP 코어 (v1.0-1.1) 구현 완료
> * 이제 **프로덕션 환경**을 위한 모니터링 시스템과 매치메이킹 시스템을 구축할 준비가 된 상태

---

## 0. 전제 / 목표

### 전제

* C++ 기본 문법 숙지
* CMake 빌드 시스템 사용 가능
* TCP/WebSocket/UDP 서버 구현 경험 (Lab 1.1-1.4, v1.0-1.1)
* Protobuf 메시지 직렬화 경험

### 이 문서의 목표

1. **Prometheus 메트릭**으로 서버 성능 모니터링
2. **Grafana 대시보드**로 실시간 시각화
3. **매치메이킹 시스템**으로 플레이어 자동 매칭
4. **PostgreSQL/Redis**를 활용한 매치 큐 & 방 관리

### 이 문서가 다루는 범위

* **v1.2**: 메트릭 & 모니터링
* **v1.3**: 매치메이킹 & 방 분리

**이전 문서들**:

* 문서 5 (5.md): UDP 코어 (v1.0-1.1)
* 문서 4 (4.md): WebSocket (Lab 1.3-1.4)
* 문서 3 (3.md): TCP 기초 (Lab 1.1-1.2)

---

## 1. v1.2: 메트릭 & 모니터링

### 1.1 목표

* Prometheus C++ 클라이언트 통합
* 커스텀 카운터/히스토그램
* `/metrics` HTTP 엔드포인트
* Grafana 대시보드

### 1.2 Prometheus 메트릭

**카운터** (Counter):

* `reliable_retries_total`: 재전송된 패킷 수
* `reliable_timeouts_total`: 타임아웃으로 폐기된 패킷 수
* `dropped_duplicates_total`: 중복 패킷 드롭 수

**히스토그램** (Histogram):

* `server_tick_duration_seconds`: 서버 틱 처리 시간
* `packet_size_bytes`: 패킷 크기 분포

```cpp
#include <prometheus/counter.h>
#include <prometheus/histogram.h>
#include <prometheus/registry.h>

class MetricsCollector {
public:
    MetricsCollector();

    void increment_retries();
    void observe_tick_duration(double seconds);

private:
    prometheus::Registry registry_;
    prometheus::Counter& retries_counter_;
    prometheus::Histogram& tick_histogram_;
};
```

### 1.3 /metrics 엔드포인트

```cpp
#include <prometheus/exposer.h>

int main() {
    // Prometheus Exposer (HTTP 서버)
    prometheus::Exposer exposer{"0.0.0.0:9090"};

    // Registry 등록
    auto registry = std::make_shared<prometheus::Registry>();
    exposer.RegisterCollectable(registry);

    // 게임 서버 실행
    PongServer server(8000, registry);
    server.run();

    return 0;
}
```

**테스트**:

```bash
# 메트릭 확인
curl http://localhost:9090/metrics

# 출력 예시:
# reliable_retries_total 142
# reliable_timeouts_total 3
# server_tick_duration_seconds_bucket{le="0.01"} 9850
# server_tick_duration_seconds_bucket{le="0.015"} 9998
```

### 1.4 Grafana 대시보드

**주요 패널**:

* **서버 처리 지연** (p50/p95/p99)
* **패킷 손실률** (`reliable_timeouts_total / 전체 전송`)
* **재전송 횟수** (`reliable_retries_total`)
* **동시 접속자 수**

**Prometheus 쿼리 예시**:

```promql
# p99 서버 틱 지연
histogram_quantile(0.99, rate(server_tick_duration_seconds_bucket[1m]))

# 패킷 손실률
rate(reliable_timeouts_total[1m]) / rate(packets_sent_total[1m])

# 재전송 횟수
rate(reliable_retries_total[1m])
```

### 1.5 구현 가이드

**구현 순서**:

1. Prometheus C++ 클라이언트 라이브러리 설치
2. `MetricsCollector` 클래스 구현
3. 게임 서버에서 메트릭 수집 코드 추가
4. `/metrics` HTTP 엔드포인트 노출
5. Prometheus 서버 설정 (`prometheus.yml`)
6. Grafana 대시보드 생성

**Prometheus 설정** (`prometheus.yml`):

```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'pong_server'
    static_configs:
      - targets: ['localhost:9090']
```

**Prometheus 실행**:

```bash
docker run -d \
  -p 9091:9090 \
  -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

**Grafana 실행**:

```bash
docker run -d \
  -p 3000:3000 \
  grafana/grafana
```

**참조 문서**:

* `design/netcode-core/1.2-observability.md` - 상세 설계 및 메트릭 수집 가이드

---

## 2. v1.3: 매치메이킹 & 방 분리

### 2.1 목표

* 매치 서버 (별도 프로세스)
* PostgreSQL 매치 큐
* Redis 방 관리
* 게임 서버와 매치 서버 통신

### 2.2 아키텍처

```text
[클라이언트]
    │
    │ HTTP POST /match/request
    ▼
[매치 서버]
    │
    ├─ PostgreSQL (매치 큐, 플레이어 정보)
    ├─ Redis (방 상태, 세션)
    │
    │ 매칭 완료 시
    ▼
[게임 서버]
    │
    │ UDP
    ▼
[클라이언트]
```

### 2.3 매치 서버 API

**매칭 요청**:

```
POST /match/request
Content-Type: application/json

{
    "player_id": "p123",
    "rating": 1500
}
```

**응답**:

```json
{
    "match_id": "m456",
    "room_id": "r789",
    "game_server": "game1.example.com:9000",
    "opponent_id": "p124"
}
```

### 2.4 PostgreSQL 스키마

```sql
CREATE TABLE players (
    id VARCHAR(32) PRIMARY KEY,
    rating INT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE match_queue (
    player_id VARCHAR(32) PRIMARY KEY REFERENCES players(id),
    rating INT NOT NULL,
    queued_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE matches (
    id VARCHAR(32) PRIMARY KEY,
    player1_id VARCHAR(32) NOT NULL,
    player2_id VARCHAR(32) NOT NULL,
    room_id VARCHAR(32) NOT NULL,
    game_server VARCHAR(128) NOT NULL,
    started_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

### 2.5 Redis 방 관리

```cpp
#include <hiredis/hiredis.h>

class RoomManager {
public:
    RoomManager(const std::string& redis_url);

    std::string create_room(const std::string& match_id);
    bool add_player_to_room(const std::string& room_id, const std::string& player_id);
    void close_room(const std::string& room_id);

private:
    redisContext* redis_;
};
```

**Redis 키 구조**:

```
room:<room_id>:players = SET {player1_id, player2_id}
room:<room_id>:match_id = STRING match_id
room:<room_id>:status = STRING "waiting" | "playing" | "finished"
```

**Redis 명령어 예시**:

```bash
# 방 생성
SADD room:r789:players p123
SADD room:r789:players p124
SET room:r789:match_id m456
SET room:r789:status waiting

# 방 상태 확인
SMEMBERS room:r789:players
GET room:r789:status

# 방 종료
DEL room:r789:players
DEL room:r789:match_id
DEL room:r789:status
```

### 2.6 매칭 알고리즘 (간단 버전)

```cpp
void Matcher::tick() {
    auto queued_players = db_.get_queued_players();

    // 레이팅 기준 정렬
    std::sort(queued_players.begin(), queued_players.end(),
              [](const auto& a, const auto& b) { return a.rating < b.rating; });

    // 인접한 플레이어끼리 매칭
    for (size_t i = 0; i + 1 < queued_players.size(); i += 2) {
        const auto& p1 = queued_players[i];
        const auto& p2 = queued_players[i + 1];

        // 레이팅 차이 체크
        if (std::abs(p1.rating - p2.rating) > max_rating_diff) {
            continue;
        }

        // 매칭 생성
        create_match(p1.id, p2.id);

        // 큐에서 제거
        db_.remove_from_queue(p1.id);
        db_.remove_from_queue(p2.id);
    }
}
```

### 2.7 매치 서버 구현 예시

```cpp
#include <httplib.h>  // cpp-httplib

class MatchServer {
public:
    MatchServer(uint16_t port, DatabaseClient& db, RoomManager& rooms);

    void run();

private:
    void handle_match_request(const httplib::Request& req, httplib::Response& res);

    httplib::Server server_;
    DatabaseClient& db_;
    RoomManager& rooms_;
    std::thread matcher_thread_;
};

void MatchServer::run() {
    // HTTP 엔드포인트 등록
    server_.Post("/match/request", [this](const auto& req, auto& res) {
        handle_match_request(req, res);
    });

    // 매칭 루프 시작
    matcher_thread_ = std::thread([this]() {
        while (running_) {
            tick();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });

    // HTTP 서버 시작
    server_.listen("0.0.0.0", port_);
}
```

### 2.8 구현 가이드

**구현 순서**:

1. PostgreSQL 데이터베이스 설정 및 스키마 생성
2. Redis 서버 설정
3. `DatabaseClient` 클래스 구현 (libpqxx 사용)
4. `RoomManager` 클래스 구현 (hiredis 사용)
5. `Matcher` 클래스 구현 (매칭 알고리즘)
6. `MatchServer` HTTP 서버 구현 (cpp-httplib 사용)
7. 게임 서버와 매치 서버 연동

**테스트 방법**:

```bash
# PostgreSQL 실행
docker run -d \
  -e POSTGRES_PASSWORD=password \
  -p 5432:5432 \
  postgres

# Redis 실행
docker run -d \
  -p 6379:6379 \
  redis

# 매치 서버 실행
./apps/matcher/bin/matcher_server 8080

# 매칭 요청 테스트
curl -X POST http://localhost:8080/match/request \
  -H "Content-Type: application/json" \
  -d '{"player_id": "p123", "rating": 1500}'

curl -X POST http://localhost:8080/match/request \
  -H "Content-Type: application/json" \
  -d '{"player_id": "p124", "rating": 1520}'

# 응답 확인 (두 플레이어 매칭됨)
```

**참조 문서**:

* `design/netcode-core/1.3-match-room-split.md` - 상세 설계 및 매칭 알고리즘

---

## 3. v1.2-1.3 체크리스트

이 문서 기준으로, 아래를 만족하면 프로덕션 (v1.2-1.3)는 통과로 본다.

### v1.2 체크리스트

* [ ] Prometheus C++ 클라이언트를 통합하고, 커스텀 메트릭을 수집할 수 있다.
* [ ] `/metrics` HTTP 엔드포인트를 노출하고, Prometheus에서 스크래핑할 수 있다.
* [ ] Grafana 대시보드를 생성하고, 실시간으로 서버 성능을 모니터링할 수 있다.
* [ ] 서버 처리 지연 p99 < 15ms를 달성했다.
* [ ] 패킷 손실률, 재전송 횟수를 실시간으로 확인할 수 있다.

### v1.3 체크리스트

* [ ] 매치 서버에서 플레이어를 자동으로 매칭하고, 게임 서버 주소를 반환하여 게임을 시작할 수 있다.
* [ ] PostgreSQL과 Redis를 사용해서 매치 큐와 방 관리를 구현했다.
* [ ] 레이팅 기반 매칭 알고리즘을 구현했다 (레이팅 차이 < 100).
* [ ] HTTP POST `/match/request` API를 통해 매칭을 요청하고, 응답을 받을 수 있다.
* [ ] 동시에 100명의 플레이어가 매칭을 요청해도 정상적으로 처리된다.

여기까지 구현하면:

* **TCP/WebSocket 기반 기본 서버** (Lab 1.1-1.4)
* **UDP 기반 권위 서버 + 신뢰성 레이어** (v1.0)
* **스냅샷 & 델타 압축** (v1.1)
* **메트릭 & 모니터링** (v1.2)
* **매치메이킹 시스템** (v1.3)

까지 **실전 네트워크 게임 엔진의 전체 그림**이 완성된 상태다.

---

## 4. 프로덕션 배포 고려사항

### 4.1 수평 확장 (Horizontal Scaling)

**게임 서버**:

* 각 게임 서버는 독립적으로 실행
* 로드 밸런서 없이 매치 서버가 직접 서버 할당
* 서버 인스턴스마다 고유한 주소 (IP:Port)

**매치 서버**:

* PostgreSQL과 Redis를 공유하는 다중 매치 서버
* HTTP 로드 밸런서 (Nginx, HAProxy)
* 수평 확장 가능 (stateless)

### 4.2 장애 처리 (Fault Tolerance)

**게임 서버 장애**:

* Health check (매치 서버가 주기적으로 ping)
* 장애 감지 시 플레이어에게 재연결 요청
* 방 상태를 Redis에 저장하여 복구 가능

**매치 서버 장애**:

* PostgreSQL 레플리카로 읽기 분산
* Redis Sentinel로 자동 페일오버
* 매치 서버 다중화로 고가용성 확보

### 4.3 보안

**DDoS 방어**:

* UDP Amplification 공격 방지 (패킷 크기 제한)
* Rate Limiting (플레이어당 초당 패킷 수 제한)
* IP 기반 차단 리스트

**치팅 방지**:

* 서버 권위 (Server Authority) - 클라이언트는 입력만 전송
* 입력 검증 (물리적으로 불가능한 이동 차단)
* 타임스탬프 검증 (미래/과거 입력 차단)

### 4.4 비용 최적화

**대역폭**:

* 델타 스냅샷으로 대역폭 절약 (68% 절약)
* 필요시 추가 압축 (zlib, LZ4)

**인프라**:

* 게임 서버는 CPU 집약적 (c5.xlarge 타입)
* 매치 서버는 I/O 집약적 (t3.medium 타입)
* Auto Scaling으로 수요에 맞춰 조정

---

## 5. 추가 학습 자료

### 5.1 메트릭 & 모니터링

* Prometheus 공식 문서
* Grafana 대시보드 템플릿
* SRE (Site Reliability Engineering) 책

### 5.2 매치메이킹

* Valve의 "Matchmaking in Team Fortress 2"
* Overwatch의 "Skill Rating System"
* Elo Rating System

### 5.3 프로덕션 운영

* Game Server Hosting (AWS GameLift, Agones)
* Kubernetes로 게임 서버 오케스트레이션
* Datadog, New Relic (APM 도구)

---

## 6. 자주 묻는 질문

**Q1: Prometheus vs StatsD, 어떤 것을 써야 하나요?**

A: **Prometheus**는 Pull 방식으로 메트릭을 수집하고, 히스토그램을 지원하여 p99 지연을 측정하기 쉽습니다. **StatsD**는 Push 방식으로 더 간단하지만, 히스토그램 지원이 제한적입니다. 게임 서버처럼 성능 분포가 중요한 경우 Prometheus를 추천합니다.

**Q2: PostgreSQL vs MySQL, 어떤 것을 써야 하나요?**

A: 둘 다 가능하지만, **PostgreSQL**은 JSONB 타입, LISTEN/NOTIFY (pub/sub), 더 강력한 인덱스 등 추가 기능이 많습니다. 매치 큐는 간단하므로 둘 다 무난하지만, 향후 확장성을 고려하면 PostgreSQL이 유리합니다.

**Q3: Redis를 방 관리에만 써도 되나요? 모든 상태를 Redis에 저장해야 하나요?**

A: Redis는 **임시 상태** (방, 세션, 캐시)에 적합합니다. 영구 저장이 필요한 데이터 (플레이어 정보, 매치 기록)는 PostgreSQL에 저장하세요. Redis는 **빠르지만 휘발성**이므로, 중요한 데이터를 잃어도 괜찮은 경우에만 사용합니다.

**Q4: 매칭 알고리즘이 너무 간단한데, 실전에서도 이렇게 하나요?**

A: 이 문서의 알고리즘은 **기본 버전**입니다. 실전에서는 다음을 추가로 고려합니다:
- **대기 시간 확장**: 오래 대기한 플레이어는 레이팅 차이를 점진적으로 확대
- **지역 매칭**: 같은 지역 플레이어 우선 매칭 (핑 최소화)
- **파티 매칭**: 친구와 함께 참여한 그룹 처리
- **공정성**: 연승/연패 고려하여 균형 조정

**Q5: 게임 서버가 100개 이상이 되면 어떻게 관리하나요?**

A: **Kubernetes** 또는 **AWS GameLift** 같은 오케스트레이션 도구를 사용합니다. 주요 기능:
- **Auto Scaling**: 수요에 맞춰 서버 자동 추가/제거
- **Health Check**: 장애 서버 자동 재시작
- **배포 자동화**: 새 버전 무중단 배포 (Rolling Update)
- **로그 집계**: 모든 서버 로그를 중앙화 (ELK Stack, CloudWatch)

**Q6: 서버 처리 지연 p99 < 15ms는 어떻게 달성하나요?**

A: 주요 최적화:
- **불필요한 복사 제거**: `std::move`, `std::vector` 예약
- **메모리 할당 최소화**: 객체 풀링, 재사용
- **잠금 최소화**: Lock-free 자료구조, Read-Write Lock
- **프로파일링**: perf, Valgrind로 병목 지점 파악
- **하드웨어**: 빠른 CPU, 낮은 레이턴시 네트워크

일반적으로 **60 TPS** 게임 서버에서 틱당 10-15ms는 충분히 달성 가능합니다.
