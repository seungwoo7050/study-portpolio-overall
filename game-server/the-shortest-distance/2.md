# 문서 2. C 개발자를 위한 C++ 기본기

> 이 문서는 **Stage 0 중 "C++ 기본기" 부분**을 채우는 문서다.
> CMake, 소켓 API는 Stage 1에서도 계속 사용된다.

---

## 0. 전제 / 목표

### 전제 (이미 알고 있다고 가정하는 것)

* C 문법: 포인터, struct, 함수 포인터, malloc/free
* 프로세스/스레드, 블로킹/논블로킹 I/O 개념
* TCP/UDP 소켓 API를 한 번이라도 써본 경험

### 이 문서의 목표

* C와 C++의 **큰 틀 차이** 파악
* C++에서 꼭 필요한 문법 (참조자, RAII, 스마트 포인터) 이해
* CMake로 멀티 프로젝트 빌드하기
* 소켓 API를 C++ 클래스로 감싸는 패턴 익히기

최종적으로 이 정도를 목표로 한다:

* Socket 클래스를 RAII로 작성할 수 있다
* CMake로 gameserver-fundamentals 빌드 가능
* 멀티스레딩 기본 개념 이해 (`std::thread`, `std::mutex`)

---

## 1. C vs C++ – 큰 틀 차이

### 1.1 타입 / 메모리 관점

* **C**: `malloc/free`, `NULL`, `void*` 캐스팅
* **C++**: `new/delete` (권장하지 않음), **스마트 포인터** (권장)

```cpp
// C 스타일
int* ptr = (int*)malloc(sizeof(int) * 10);
free(ptr);

// C++ 스타일 (옛날)
int* ptr = new int[10];
delete[] ptr;

// C++ 스타일 (현대)
std::unique_ptr<int[]> ptr = std::make_unique<int[]>(10);
// 자동 해제
```

* C++에서는 **RAII**(Resource Acquisition Is Initialization)를 사용해서 리소스 관리를 자동화한다.

### 1.2 함수 / 구조체 관점

* **C**: 함수와 데이터 분리
* **C++**: 클래스로 데이터와 함수를 묶음

```c
// C
typedef struct {
    int fd;
} Socket;

void socket_close(Socket* s) {
    if (s->fd >= 0) {
        close(s->fd);
        s->fd = -1;
    }
}

// C++
class Socket {
public:
    Socket() : fd_(-1) {}
    ~Socket() { close_socket(); }

    void close_socket() {
        if (fd_ >= 0) {
            ::close(fd_);
            fd_ = -1;
        }
    }

private:
    int fd_;
};
```

* C++의 **소멸자**(`~Socket()`)는 객체가 스코프를 벗어날 때 자동으로 호출된다.
* 따라서 `close`를 깜빡해도 리소스 누수가 안 생긴다.

---

## 2. C++에서 꼭 필요한 문법 정리

### 2.1 참조자 (reference)

```cpp
void increment(int& x) {
    x += 1;
}

int main() {
    int a = 10;
    increment(a);
    // a == 11
}
```

* `int& x` = "null이 될 수 없는 포인터" 느낌
* 호출 시 `&a` 같은 건 안 붙이고 그냥 `increment(a);`
* 함수 안에서 `x`를 수정하면 원본 `a`가 수정됨

읽기 전용 참조:

```cpp
void print(const std::string& s) {
    std::cout << s << "\n";
}
```

* 복사 없이, 읽기만 할 때 이런 형태를 많이 쓴다.

---

### 2.2 RAII (생성자 / 소멸자로 자원 관리)

C에서:

* `open` / `close`, `malloc` / `free`, `socket` / `close` 같이 **쌍으로 관리해야 할 자원**이 많다.
* C++에서는 이걸 **"객체의 생명주기"에 붙여 놓는 패턴**을 쓴다.

```cpp
class FileHandle {
public:
    explicit FileHandle(const std::string& path)
        : file_(std::fopen(path.c_str(), "rb")) {
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~FileHandle() {
        if (file_) {
            std::fclose(file_);
        }
    }

    FILE* get() const { return file_; }

private:
    FILE* file_;
};

void example() {
    FileHandle f("test.bin");
    // 여기서 예외가 나거나, return 되거나 상관 없이,
    // f가 스코프를 벗어날 때 ~FileHandle() 자동 호출 → fclose
}
```

소켓도 같은 방식으로 감싼다.

---

### 2.3 `std::string`, `std::vector`

```cpp
#include <string>
#include <vector>

std::string s = "hello";
s += " world";
std::size_t len = s.size();

std::vector<int> nums;
nums.push_back(10);
nums.push_back(20);

for (std::size_t i = 0; i < nums.size(); ++i) {
    std::cout << nums[i] << "\n";
}
```

* `std::string` = `char*` + 길이 + 메모리 관리까지 포함된 객체
* `std::vector<T>` = 동적 배열 (자동 `realloc`)

---

### 2.4 `std::unique_ptr` 기본

```cpp
#include <memory>
#include <iostream>

class Foo {
public:
    Foo() { std::cout << "Foo()\n"; }
    ~Foo() { std::cout << "~Foo()\n"; }
};

void example() {
    std::unique_ptr<Foo> ptr = std::make_unique<Foo>();
    // 스코프 벗어나면 자동으로 delete
}
```

특징:

* "소유자는 딱 한 명"이라는 뜻
* 복사 불가(`=`, 복사 생성자 금지), 이동(`std::move`)만 가능
* 소켓을 RAII로 감쌀 때 **"+ 커스텀 deleter"**와 함께 많이 사용

---

### 2.5 `using` 타입 별칭

긴 템플릿 타입에 별명을 붙인다.

```cpp
#include <map>
#include <string>

using StringMap = std::map<std::string, std::string>;

StringMap metadata;
```

소켓에도 사용:

```cpp
using SocketPtr = std::unique_ptr<Socket>;
```

예전 C 스타일 `typedef`보다 훨씬 읽기 편하다.

---

### 2.6 `std::move`

소유권 이전을 표현.

```cpp
std::unique_ptr<Foo> makeFoo();

void takeOwnership(std::unique_ptr<Foo> ptr);

void example() {
    auto ptr = makeFoo();
    takeOwnership(std::move(ptr));  // 여기서 ptr의 소유권 이동
    // 이후 ptr은 더 이상 유효하다고 기대하면 안 됨 (보통 null)
}
```

* 복사가 아니라 "**이건 이제 저쪽이 가진다**"는 의미
* 특히 `unique_ptr` 같이 "소유자 1개"인 타입에 필수

---

### 2.7 `auto` + range-based for + `std::map`

```cpp
#include <map>
#include <string>
#include <iostream>

int main() {
    std::map<std::string, std::string> metadata;
    metadata["title"] = "My Game";
    metadata["author"] = "Someone";

    for (const auto& pair : metadata) {
        const std::string& key   = pair.first;
        const std::string& value = pair.second;
        std::cout << key << " = " << value << "\n";
    }
}
```

* `auto` : 타입 추론. 템플릿 타입을 일일이 안 써도 된다.
* `const auto&` : 복사 없이 읽기 전용으로 순회

---

### 2.8 예외

```cpp
double divide(double a, double b) {
    if (b == 0.0) {
        throw std::runtime_error("division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 0) << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
    }
}
```

이걸 **소켓 오류 코드 → `std::runtime_error`**로 바꿔 던지는 데 쓴다.

---

### 2.9 namespace (짧게)

```cpp
namespace gameserver {
    struct GameState { /* ... */ };
}

gameserver::GameState state;
```

* 전역 심볼 충돌 방지용
* 라이브러리 코드에 적당한 네임스페이스를 하나 두고 시작하는 게 안전하다.

---

## 3. CMake 기초

### 3.1 CMake란?

* 빌드 시스템 생성 도구
* `Makefile`, `Ninja`, `Visual Studio` 프로젝트 파일 등을 자동 생성
* C에서 Makefile 직접 작성하는 대신, CMake로 크로스 플랫폼 빌드 관리

### 3.2 최소 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(MyProject LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(my_server
    src/main.cpp
    src/socket.cpp
)

target_include_directories(my_server
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)
```

* `cmake_minimum_required`: CMake 최소 버전
* `project`: 프로젝트 이름, 언어
* `set(CMAKE_CXX_STANDARD 17)`: C++17 사용
* `add_executable`: 실행 파일 정의
* `target_include_directories`: 헤더 경로

### 3.3 빌드 명령어

```bash
mkdir build
cd build
cmake ..
make
```

* `cmake ..`: 상위 디렉토리의 CMakeLists.txt 읽어서 Makefile 생성
* `make`: 실제 빌드

### 3.4 서브디렉토리

```cmake
# gameserver-fundamentals/CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(gameserver-fundamentals LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_subdirectory(lab1.1-tcp-echo)
add_subdirectory(lab1.2-turn-combat)
add_subdirectory(lab1.3-ws-chat)
add_subdirectory(lab1.4-ws-pong)
```

* `add_subdirectory`: 하위 디렉토리의 CMakeLists.txt 포함

---

## 4. 네트워크 프로그래밍 기본 (소켓 API)

### 4.1 TCP 소켓 생성 (C 스타일)

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main() {
    // 1. 소켓 생성
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror("socket");
        return 1;
    }

    // 2. 주소 설정
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;

    // 3. 바인드
    if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(fd);
        return 1;
    }

    // 4. 리슨
    if (listen(fd, SOMAXCONN) < 0) {
        perror("listen");
        close(fd);
        return 1;
    }

    // 5. 억셉트
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_fd = accept(fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd < 0) {
        perror("accept");
        close(fd);
        return 1;
    }

    // 6. 통신
    char buf[1024];
    ssize_t n = recv(client_fd, buf, sizeof(buf), 0);
    if (n > 0) {
        send(client_fd, buf, n, 0);
    }

    // 7. 종료
    close(client_fd);
    close(fd);

    return 0;
}
```

### 4.2 C++로 감싸기 (RAII)

```cpp
class Socket {
public:
    Socket() : fd_(-1) {}

    explicit Socket(int fd) : fd_(fd) {}

    Socket(const Socket&) = delete;
    Socket& operator=(const Socket&) = delete;

    Socket(Socket&& other) noexcept : fd_(other.fd_) {
        other.fd_ = -1;
    }

    Socket& operator=(Socket&& other) noexcept {
        if (this != &other) {
            close_socket();
            fd_ = other.fd_;
            other.fd_ = -1;
        }
        return *this;
    }

    ~Socket() {
        close_socket();
    }

    static Socket create_tcp() {
        int fd = ::socket(AF_INET, SOCK_STREAM, 0);
        if (fd < 0) {
            throw std::runtime_error("socket() failed");
        }
        return Socket(fd);
    }

    void bind(uint16_t port) {
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = INADDR_ANY;

        if (::bind(fd_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            throw std::runtime_error("bind() failed");
        }
    }

    void listen(int backlog = SOMAXCONN) {
        if (::listen(fd_, backlog) < 0) {
            throw std::runtime_error("listen() failed");
        }
    }

    Socket accept() {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_fd = ::accept(fd_, (struct sockaddr*)&client_addr, &client_len);
        if (client_fd < 0) {
            throw std::runtime_error("accept() failed");
        }
        return Socket(client_fd);
    }

    ssize_t receive(uint8_t* buffer, size_t length) {
        ssize_t n = ::recv(fd_, buffer, length, 0);
        if (n < 0) {
            throw std::runtime_error("recv() failed");
        }
        return n;
    }

    void send_all(const uint8_t* data, size_t length) {
        size_t sent = 0;
        while (sent < length) {
            ssize_t n = ::send(fd_, data + sent, length - sent, 0);
            if (n < 0) {
                throw std::runtime_error("send() failed");
            }
            sent += n;
        }
    }

    void close_socket() {
        if (fd_ >= 0) {
            ::close(fd_);
            fd_ = -1;
        }
    }

    int fd() const { return fd_; }

private:
    int fd_;
};
```

### 4.3 사용 예시

```cpp
int main() {
    try {
        Socket server = Socket::create_tcp();
        server.bind(8080);
        server.listen();

        std::cout << "Server listening on port 8080\n";

        Socket client = server.accept();
        std::cout << "Client connected\n";

        uint8_t buf[1024];
        ssize_t n = client.receive(buf, sizeof(buf));
        if (n > 0) {
            client.send_all(buf, n);
        }

        // Socket 소멸자가 자동으로 close() 호출
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

---

## 5. 멀티스레딩 기초

### 5.1 `std::thread`

```cpp
#include <thread>
#include <iostream>

void worker(int id) {
    std::cout << "Worker " << id << " started\n";
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Worker " << id << " finished\n";
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);

    t1.join();  // t1이 끝날 때까지 대기
    t2.join();  // t2가 끝날 때까지 대기

    return 0;
}
```

### 5.2 `std::mutex`, `std::lock_guard`

```cpp
#include <thread>
#include <mutex>
#include <iostream>
#include <vector>

std::mutex mtx;
int counter = 0;

void increment() {
    for (int i = 0; i < 1000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Counter: " << counter << "\n";  // 10000

    return 0;
}
```

### 5.3 `std::atomic`

간단한 플래그는 `std::atomic`으로.

```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<bool> running{true};

void worker() {
    while (running) {
        // do work
    }
    std::cout << "Worker stopped\n";
}

int main() {
    std::thread t(worker);

    std::this_thread::sleep_for(std::chrono::seconds(1));
    running = false;  // 안전하게 플래그 변경

    t.join();

    return 0;
}
```

---

## 6. 예외 처리

### 6.1 기본 패턴

```cpp
#include <stdexcept>
#include <iostream>

void risky_operation() {
    throw std::runtime_error("Something went wrong");
}

int main() {
    try {
        risky_operation();
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

### 6.2 소켓 에러 → 예외

```cpp
void Socket::bind(uint16_t port) {
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (::bind(fd_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        throw std::runtime_error(
            std::string("bind() failed: ") + std::strerror(errno)
        );
    }
}
```

---

## 7. Stage 1 체크리스트

이 문서 기준으로, 아래를 스스로 할 수 있으면 Stage 0의 **C++ 기본기** 부분은 통과로 봐도 된다.

* [ ] C++에서 참조자(`int&`)와 포인터(`int*`)의 차이를 설명할 수 있다.
* [ ] RAII 패턴으로 소켓을 감싸서, 소멸자에서 자동으로 `close()`가 호출되게 만들 수 있다.
* [ ] `std::unique_ptr`을 사용해서 동적 메모리를 관리하고, 스코프를 벗어나면 자동으로 해제되는 것을 확인했다.
* [ ] CMake로 프로젝트를 빌드하고, `add_executable`, `target_include_directories`, `target_link_libraries`의 역할을 이해했다.
* [ ] TCP 소켓 API(`socket`, `bind`, `listen`, `accept`, `recv`, `send`)를 C++ 클래스로 감싸는 코드를 작성할 수 있다.
* [ ] `std::thread`로 멀티스레드 프로그램을 작성하고, `std::mutex`로 공유 자원을 보호할 수 있다.
* [ ] 예외 처리(`try/catch`)를 사용해서 소켓 에러를 처리하고, 의미 있는 에러 메시지를 출력할 수 있다.

여기까지가 문서 2에서 다루는 범위다.
이 다음 단계에서, **문서 3**에서 gameserver-fundamentals Lab 1.1-1.4를 실제로 구현하게 된다.
