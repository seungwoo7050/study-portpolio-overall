# 문서 1. 전체 아키텍처 & 로드맵 개요

## 1. 이 문서의 역할

이 문서는 **"전체 그림"만 보여주는 인덱스 문서**다.

* 대상: C로 서버 개발은 해봤지만, 게임 서버는 처음인 개발자
* 목표:

  * C++ 게임 서버의 **핵심 개념과 구조**를 한 번에 이해
  * 어떤 순서(Stage)로 문서 2, 3, 4를 보면 되는지 파악
  * 각 Stage에서 **무엇을 만들고, 통과 기준이 뭔지** 명확히 정리

세부 문법, 코드, 설정은 각각:

* **문서 2**: C 개발자를 위한 C++ 기본기
* **문서 3**: gameserver-fundamentals (Lab 1.1-1.4)
* **문서 4**: netcode-core (실전 네트워크 게임 엔진)

에서 다룬다. 이 문서는 그 위에 얹는 "지도"라고 생각하면 된다.

---

## 2. 최종 목표: 어떤 서버를 만들 것인가

최종적으로 목표하는 것은:

> **UDP 기반 권위 서버 아키텍처를 가진 실시간 멀티플레이어 게임 서버**

구체적으로:

1. **gameserver-fundamentals (Lab 1.1-1.4)**

   * TCP 에코 서버 (Lab 1.1)
   * 턴제 전투 서버 10 TPS (Lab 1.2)
   * WebSocket 채팅 서버 (Lab 1.3)
   * WebSocket Pong 서버 60 TPS (Lab 1.4)

2. **netcode-core (v1.0-1.3)**

   * UDP 권위 서버 + 신뢰성 레이어 (v1.0)
   * 스냅샷 & 델타 압축 (v1.1)
   * 메트릭 & 모니터링 (v1.2)
   * 매치메이킹 & 방 분리 (v1.3)

**이 전체 플로우를 Stage 0 → 1 → 2로 쪼개서 올라간다.**

---

## 3. 전체 아키텍처 한 번에 보기

### 3.1 논리적 구성도

```text
[클라이언트 (웹 브라우저)]
  - WebSocket/UDP 통신
  - 입력 전송 (키보드/마우스)
  - 상태 수신 (게임 월드)
          │  UDP (패킷)
          ▼
[게임 서버 (C++)]
  - 네트워크 레이어 (TCP/UDP/WebSocket)
  - 신뢰성 레이어 (재전송, ACK, 순서 보장)
  - 게임 로직 (물리, 충돌, 점수)
  - 상태 동기화 (스냅샷, 델타)
  - 매칭 시스템 (PostgreSQL, Redis)
          │  메트릭 수집
          ▼
[모니터링 (Prometheus + Grafana)]
  - 서버 처리 지연 (p50/p95/p99)
  - 패킷 손실률
  - 재전송 횟수
  - 동시 접속자 수
```

관점 정리:

* **클라이언트**: 웹 브라우저 기반 (HTML5 Canvas + JavaScript)
* **게임 서버**: C++ 기반 권위 서버, 모든 게임 로직 수행
* **모니터링**: Prometheus로 메트릭 수집, Grafana로 시각화

---

### 3.2 요청–응답 시퀀스 (대표 시나리오)

예시 시나리오: **2명의 플레이어가 Pong 게임을 플레이**

```text
1. 클라이언트 A, B가 매치 서버에 매칭 요청
2. 매치 서버가 방을 생성하고 게임 서버 주소 반환
3. 클라이언트 A, B가 게임 서버에 UDP 연결
4. 게임 서버가 초기 상태(공, 패들 위치) 전송
5. 클라이언트가 입력(패들 이동)을 서버로 전송 (UDP, reliable)
6. 서버가 게임 로직 실행 (60 TPS):
   - 입력 적용
   - 물리 시뮬레이션 (공 이동, 충돌 체크)
   - 점수 계산
7. 서버가 상태 스냅샷을 모든 클라이언트에 전송 (UDP, unreliable)
8. 클라이언트가 상태를 받아 화면에 렌더링
9. 점수가 변경되면 서버가 점수 업데이트 전송 (UDP, reliable)
10. 게임 종료 시 서버가 결과를 PostgreSQL에 저장
```

이 "한 줄 시나리오"를 위해 필요한 지식들을 Stage로 쪼갠 게 뒤에 나오는 로드맵이다.

---

## 4. Stage별 로드맵 개요

Stage는 "기술 이름" 기준이 아니라 **"검증 가능한 기능 단위"** 기준으로 나눈다.

* **Stage 0**: 프로젝트 부트스트랩 (CMake, 빌드 시스템)
* **Stage 1**: gameserver-fundamentals (Lab 1.1-1.4)
* **Stage 2**: netcode-core (v1.0-1.3)

각 Stage마다:

* 필요 기술
* 만들어야 할 최소 기능
* 통과 체크리스트

를 명확하게 정의한다.

---

## 5. Stage 0 – 프로젝트 부트스트랩

### 5.1 Stage 0의 목표

* CMake로 멀티 프로젝트 빌드 시스템 구축
* C++17 표준 설정, 컴파일러 경고 활성화
* 의존성 관리 (Threads, Protobuf, Boost)
* 빌드 및 실행 환경 검증

이 Stage에서는 **실제 게임 로직은 아직 안 건드린다.**
목표는 "빌드 시스템과 개발 환경에 적응하는 것".

### 5.2 다루는 기술

* **CMake**

  * `CMakeLists.txt` 구조
  * `add_executable`, `add_library`
  * `target_link_libraries`, `target_include_directories`
  * 서브디렉토리 관리 (`add_subdirectory`)
* **C++17 설정**

  * `CMAKE_CXX_STANDARD`, `CMAKE_CXX_STANDARD_REQUIRED`
  * 컴파일러 경고 (`-Wall -Wextra -Wpedantic -Werror`)
  * Position Independent Code (공유 라이브러리)
* **의존성 관리**

  * `find_package(Threads)`
  * `find_package(Protobuf)` (netcode-core)
  * `find_package(Boost)` (netcode-core)

### 5.3 이 Stage에서 완성해야 할 기능

최소 기능:

1. **gameserver-fundamentals 빌드**

   * `mkdir build && cd build && cmake .. && make`
   * 4개의 Lab 실행 파일 생성 확인

2. **netcode-core 빌드**

   * Protobuf 코드 자동 생성
   * 공유 라이브러리 + 실행 파일 빌드

### 5.4 통과 체크리스트

아래 항목에 "예"라고 말할 수 있으면 Stage 0 통과로 본다.

* [ ] CMake 3.20 이상이 설치되어 있고, 버전을 확인할 수 있다.
* [ ] `cmake ..` 명령으로 빌드 파일을 생성할 수 있다.
* [ ] `make` 또는 `make -j4`로 프로젝트를 빌드할 수 있다.
* [ ] gameserver-fundamentals의 4개 Lab 실행 파일이 생성되는 것을 확인했다.
* [ ] netcode-core의 Protobuf 코드가 자동 생성되는 것을 확인했다.

Stage 0이 끝나면 **"빌드 시스템 기반이 갖춰진 상태"**가 된다.

---

## 6. Stage 1 – gameserver-fundamentals (Lab 1.1-1.4)

### 6.1 Stage 1의 목표

* C++ RAII로 소켓을 안전하게 관리하고,
* TCP/WebSocket 기반 멀티스레드 서버를 구현하며,
* 게임 로직(턴제 전투, Pong)을 타이머 기반으로 처리하는 수준.

이 Stage에서는 **UDP는 아직 안 건드린다.**
목표는 "네트워크 서버 기본 패턴에 익숙해지는 것".

### 6.2 다루는 기술

* **C++ RAII**

  * Socket 클래스 (생성자/소멸자)
  * 이동 생성자/대입 연산자
  * `std::unique_ptr`, `std::shared_ptr`
* **멀티스레딩**

  * `std::thread`, `std::mutex`, `std::lock_guard`
  * `std::atomic` (플래그 관리)
  * 클라이언트별 스레드 생성
* **네트워크 프로그래밍**

  * TCP 소켓 (`socket`, `bind`, `listen`, `accept`, `recv`, `send`)
  * WebSocket 핸드셰이크, 프레임 파싱
  * 논블로킹 소켓 (`fcntl`, `O_NONBLOCK`)
* **타이머 기반 게임 루프**

  * `std::chrono` (시간 측정)
  * 고정 틱 레이트 (10 TPS, 60 TPS)
  * Delta time 계산

### 6.3 이 Stage에서 완성해야 할 기능

Lab별 목표:

1. **Lab 1.1: TCP 에코 서버**

   * 여러 클라이언트 동시 접속
   * 메시지 에코
   * `exit`, `shutdown` 명령 처리

2. **Lab 1.2: 턴제 전투 서버 (10 TPS)**

   * 2명 플레이어 매칭
   * 10 TPS 게임 루프
   * 전투 로직 (공격, 회복, 체력)
   * 승패 판정

3. **Lab 1.3: WebSocket 채팅 서버**

   * WebSocket 핸드셰이크
   * 프레임 파싱/인코딩
   * 브로드캐스트 메시지

4. **Lab 1.4: WebSocket Pong 서버 (60 TPS)**

   * 60 TPS 게임 루프
   * 공/패들 물리
   * 충돌 감지
   * 점수 계산
   * JSON 직렬화

### 6.4 통과 체크리스트

* [ ] Socket 클래스를 RAII 패턴으로 작성하고, 소멸자에서 자동으로 close()가 호출되는 것을 확인했다.
* [ ] TCP 에코 서버에서 여러 클라이언트가 동시에 접속하고, 각각 독립적으로 메시지를 주고받을 수 있다.
* [ ] 턴제 전투 서버에서 10 TPS 타이머가 정확히 동작하고, 2명의 플레이어가 턴을 번갈아 가며 전투할 수 있다.
* [ ] WebSocket 채팅 서버에서 여러 클라이언트가 브로드캐스트 메시지를 주고받을 수 있다.
* [ ] WebSocket Pong 서버에서 60 TPS 게임 루프가 안정적으로 동작하고, 공/패들 물리가 정확히 계산된다.

Stage 1이 끝나면 **"기본적인 멀티플레이어 게임 서버 골격"이 완성된 상태**다.

---

## 7. Stage 2 – netcode-core (v1.0-1.3)

### 7.1 Stage 2의 목표

이 Stage는 **실전 네트워크 게임 엔진**을 만드는 단계다.

목표는:

* UDP 기반 권위 서버 아키텍처 구현
* 패킷 손실/순서 뒤바뀜/중복 전달을 처리하는 신뢰성 레이어
* 스냅샷 & 델타 압축으로 대역폭 최적화
* Prometheus 메트릭 수집으로 서버 성능 모니터링
* 매치메이킹 시스템으로 플레이어 자동 매칭

### 7.2 다루는 기술

* **UDP 네트워크**

  * `sendto`, `recvfrom`
  * Boost.Asio (비동기 I/O)
  * 논블로킹 소켓
* **신뢰성 레이어**

  * 시퀀스 번호, ACK, ACK 비트마스크
  * 재전송 큐, 타임아웃 관리
  * 패킷 필터링 (중복, 오래된 패킷)
* **Protobuf**

  * 메시지 정의 (`.proto`)
  * 직렬화/역직렬화
  * 델타 인코딩
* **메트릭**

  * Prometheus C++ 클라이언트
  * 커스텀 카운터/히스토그램
  * `/metrics` HTTP 엔드포인트
* **데이터베이스**

  * PostgreSQL (매치 히스토리)
  * Redis (방 관리, 세션)

### 7.3 이 Stage에서 완성해야 할 기능 (예시)

버전별 목표:

1. **v1.0: UDP 권위 서버 & 신뢰성 레이어**

   * UDP 소켓 생성/바인드
   * 클라이언트별 송수신 윈도우
   * 재전송 큐 + 타임아웃
   * ACK 처리
   * 패킷 필터링

2. **v1.1: 스냅샷 & 델타 압축**

   * Protobuf 메시지 정의
   * 전체 스냅샷 vs 델타 스냅샷
   * 클라이언트측 예측/보간
   * 대역폭 측정

3. **v1.2: 메트릭 & 모니터링**

   * Prometheus 메트릭 수집
   * 서버 처리 지연 (p50/p95/p99)
   * 패킷 손실률
   * Grafana 대시보드

4. **v1.3: 매치메이킹 & 방 분리**

   * 매치 서버 (별도 프로세스)
   * PostgreSQL 매치 큐
   * Redis 방 관리
   * 게임 서버와 매치 서버 통신

### 7.4 통과 체크리스트

* [ ] UDP 소켓으로 클라이언트와 통신하고, 패킷 손실이 있어도 중요한 메시지(입력, 점수)는 재전송을 통해 전달된다.
* [ ] ACK 비트마스크를 통해 최근 32개 패킷의 수신 여부를 추적하고, 손실된 패킷만 재전송한다.
* [ ] 3% 패킷 손실 환경에서도 60 TPS 게임 루프가 안정적으로 동작한다.
* [ ] Protobuf로 직렬화된 메시지를 UDP로 전송하고, 클라이언트가 정상적으로 역직렬화한다.
* [ ] Prometheus 메트릭을 `/metrics` 엔드포인트로 노출하고, Grafana에서 실시간으로 모니터링할 수 있다.
* [ ] 매치 서버에서 플레이어를 자동으로 매칭하고, 게임 서버 주소를 반환하여 게임을 시작할 수 있다.

여기까지 구현하면:

* **TCP/WebSocket 기반 기본 서버** (Lab 1.1-1.4)
* **UDP 기반 권위 서버 + 신뢰성 레이어** (v1.0)
* **스냅샷 & 델타 압축** (v1.1)
* **메트릭 & 모니터링** (v1.2)
* **매치메이킹 시스템** (v1.3)

까지 전체 그림이 연결된 상태라고 보면 된다.

---

## 8. 정리: 학습 순서 요약

추천 순서는 아래와 같다.

1. **문서 1 (지금 이 문서)**

   * 전체 구조/Stage/목표 확인

2. **문서 2 – C 개발자를 위한 C++ 기본기**

   * Stage 0 내용을 채우는 문서
   * C++ 문법 + CMake + 소켓 API까지

3. **문서 3 – gameserver-fundamentals (Lab 1.1-1.4)**

   * Stage 1의 Lab 부분
   * TCP/WebSocket 서버 + 게임 로직 구현

4. **문서 4 – netcode-core (실전 네트워크 게임 엔진)**

   * Stage 2에 해당
   * UDP 권위 서버 + 신뢰성 레이어 + 스냅샷 + 메트릭 + 매칭

이 문서는 여기까지.
다음 단계로는 **문서 2**에서 Stage 0 내용을 실제 코드/예제로 채우면 된다.
