# UDP 권위 서버 & 신뢰성 레이어 설계 일지 (v1.0)
> WebSocket/TCP에서 UDP 기반 권위 서버로 전환하고, 최소 신뢰성 레이어를 구현한 설계 기록

## 1. 문제 정의 & 요구사항

### 1.1 목표

Lab 1.4의 WebSocket/TCP 기반 Pong 서버를 **UDP 권위 서버**로 전환하면서:
- 패킷 손실을 허용하면서도 중요한 메시지는 재전송
- 순서가 뒤바뀐 패킷을 감지하고 처리
- 중복 패킷을 필터링
- 전송 계층의 신뢰성 메트릭 수집

동시에 **CI/CD 파이프라인과 품질 게이트를 확립**하여 이후 모든 버전의 기준으로 삼는다.

### 1.2 기능 요구사항

#### 1.2.1 UDP 전송 계층
1. **커스텀 헤더 구조**
   - `seq` (16bit): 현재 패킷의 시퀀스 번호
   - `ack` (16bit): 수신 확인한 가장 최신 시퀀스
   - `ack_bits` (32bit): 최근 32개 패킷의 수신 비트마스크

2. **신뢰성 보장**
   - 각 클라이언트별 송신 윈도우 관리 (최대 32개)
   - ACK 받지 못한 패킷은 재전송 큐에 보관
   - 재전송 타임아웃: 200ms (초기값)
   - 최대 재전송 횟수: 5회

3. **패킷 필터링**
   - 중복 패킷 감지 및 드롭
   - 오래된 패킷(윈도우 범위 밖) 드롭
   - 순서가 너무 앞선 패킷 처리

#### 1.2.2 ITransport 인터페이스
모든 전송 구현이 따라야 할 공통 인터페이스:
```cpp
class ITransport {
public:
    virtual void start(ReceiveHandler handler) = 0;
    virtual void stop() = 0;
    virtual void send(const Endpoint&, std::vector<uint8_t> data, bool reliable) = 0;
    virtual void update() = 0;  // 재전송 처리 등
    virtual void set_metrics_enabled(bool enabled) = 0;
    virtual Counters sample_counters() const = 0;
};
```

#### 1.2.3 메트릭 카운터
전송 계층이 제공해야 할 통계:
- `reliable_retries_total`: 재전송된 패킷 수
- `reliable_timeouts_total`: 타임아웃으로 폐기된 패킷 수
- `dropped_duplicates_total`: 중복 패킷 드롭 수
- `dropped_old_total`: 오래된 패킷 드롭 수
- `dropped_window_total`: 윈도우 범위 초과 패킷 드롭 수

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 60 TPS (Ticks Per Second) 유지
- 서버 처리 지연 p99 < 15ms
- 3% 패킷 손실 환경에서도 세션 안정성 보장

#### 1.3.2 코드 품질 (CI/CD 기준선)
- 테스트 커버리지 ≥ 70% (유닛 + 통합)
- clang-format + clang-tidy 린트 통과
- ASan/UBSan으로 메모리 안전성 검증
- 모든 PR에 자동 빌드 및 테스트 실행

#### 1.3.3 확장성
- 100 동시 클라이언트 처리 가능
- 클라이언트별 독립적인 송수신 윈도우
- 메모리 사용량 예측 가능 (클라이언트당 ~4KB)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 왜 UDP인가?

**TCP/WebSocket의 한계 (Lab 1.4에서 발견):**
- **Head-of-Line Blocking**: 한 패킷이 손실되면 이후 패킷도 모두 대기
  - 실시간 게임에서는 오래된 상태보다 최신 상태가 중요
- **불필요한 재전송**: 모든 바이트를 보장하지만, 게임 상태는 다음 틱에 덮어씀
- **지연 예측 불가**: 네트워크 혼잡 시 지연이 급격히 증가

**UDP의 장점:**
- 패킷 단위 독립 처리
- 송신 즉시 전달 (재전송 제어는 애플리케이션 레벨)
- 오래된 상태 패킷은 과감히 버릴 수 있음

**트레이드오프:**
- 패킷 손실, 순서 뒤바뀜, 중복 전달을 직접 처리해야 함
- 최소한의 신뢰성 레이어 필요 (중요 메시지: 접속/종료/점수 등)

### 2.2 선택적 신뢰성 (Selective Reliability)

모든 메시지를 재전송할 필요는 없다:
- **Reliable**: 입력 ACK, 접속/종료 이벤트, 점수 업데이트
- **Unreliable**: 게임 상태 스냅샷 (60Hz로 계속 보내므로 하나 손실돼도 무방)

`send()` 함수의 `reliable` 플래그로 구분.

---

## 3. UDP 헤더 & 신뢰성 프로토콜

### 3.1 패킷 구조

```text
┌────────────────────────────────────┐
│ UdpHeader (8 bytes)                │
│  - seq      (uint16, 2 bytes)      │
│  - ack      (uint16, 2 bytes)      │
│  - ack_bits (uint32, 4 bytes)      │
├────────────────────────────────────┤
│ Payload (protobuf 직렬화 메시지)    │
│  - Input / World / ServerAck 등    │
└────────────────────────────────────┘
```

### 3.2 시퀀스 번호 체계

- **범위**: 0 ~ 65535 (uint16)
- **순환**: 65535 다음은 0
- **비교 함수**: `is_seq_newer(lhs, rhs)`
  - `lhs`와 `rhs`의 거리가 32768 이하일 때:
    - `(lhs - rhs) & 0xFFFF < 32768` 이면 `lhs`가 더 최신

### 3.3 ACK 비트마스크

`ack_bits`는 `ack` 이전 32개 패킷의 수신 여부를 비트로 표현:
- bit 0 (LSB): `ack - 1` 번 패킷 수신 여부
- bit 1: `ack - 2` 번 패킷
- ...
- bit 31: `ack - 32` 번 패킷

**예시:**
```
ack = 100, ack_bits = 0b...1011
-> seq 100 수신 (ack)
-> seq 99 수신 (bit 0 = 1)
-> seq 98 손실 (bit 1 = 0)
-> seq 97 수신 (bit 2 = 1)
-> seq 96 수신 (bit 3 = 1)
```

이 정보를 바탕으로 송신측은 어떤 패킷이 손실됐는지 알 수 있다.

### 3.4 ReceiveState 구조

각 클라이언트마다 수신 상태 추적:
```cpp
struct ReceiveState {
    bool has_last_seq{false};
    uint16_t last_seq{0};      // 받은 가장 최신 seq
    uint32_t ack_bits{0};      // last_seq 이전 32개 비트마스크
};
```

**패킷 수신 시 갱신 로직:**
```cpp
void update_receive_state(ReceiveState& state, uint16_t seq) {
    if (!state.has_last_seq) {
        state.last_seq = seq;
        state.has_last_seq = true;
        state.ack_bits = 0;
        return;
    }

    if (is_seq_newer(seq, state.last_seq)) {
        uint16_t diff = (seq - state.last_seq) & 0xFFFF;
        if (diff < 32) {
            state.ack_bits = (state.ack_bits << diff) | ((1u << (diff - 1)) - 1);
        } else {
            state.ack_bits = 0xFFFFFFFF;
        }
        state.last_seq = seq;
    } else {
        uint16_t dist = (state.last_seq - seq) & 0xFFFF;
        if (dist <= 32) {
            state.ack_bits |= (1u << (dist - 1));
        }
    }
}
```

### 3.5 송신측 PendingPacket 관리

```cpp
struct PendingPacket {
    uint16_t seq;
    std::vector<uint8_t> payload;
    Clock::time_point first_sent;
    Clock::time_point last_sent;
    Clock::time_point next_send;  // 다음 재전송 시각
    uint32_t retries{0};
};
```

**송신 로직:**
1. `send(reliable=true)` 호출 시:
   - 새 `seq` 할당: `client.next_send_seq++`
   - `PendingPacket` 생성, `client.pending[seq]` 에 저장
   - 즉시 전송

2. `update()` 호출 시 (매 틱마다):
   - 각 클라이언트의 `pending` 맵 순회
   - `now >= next_send` 이면 재전송:
     - `retries++`
     - `next_send = now + timeout * (1 << retries)` (지수 백오프)
     - 최대 재전송 5회 초과 시 패킷 폐기, `reliable_timeouts_total++`

3. ACK 수신 시:
   - `is_seq_acked(seq, ack, ack_bits)` 체크
   - 확인된 seq는 `pending`에서 제거

---

## 4. UdpTransport 클래스 설계

### 4.1 주요 책임

- UDP 소켓 생성 및 비동기 수신 루프 (boost.asio)
- 클라이언트별 상태 관리 (`ClientState`)
- 패킷 송수신 시 헤더 조립/분해
- 재전송 큐 관리 및 타임아웃 처리
- 메트릭 카운터 업데이트

### 4.2 클래스 구조

```cpp
class UdpTransport : public ITransport {
public:
    UdpTransport(boost::asio::io_context& io_context,
                 const boost::asio::ip::udp::endpoint& endpoint);
    ~UdpTransport() override;

    void start(ReceiveHandler handler) override;
    void stop() override;
    void send(const Endpoint& endpoint, std::vector<uint8_t> data, bool reliable) override;
    void update() override;
    void set_metrics_enabled(bool enabled) override;
    Counters sample_counters() const override;

private:
    struct ClientState {
        Endpoint endpoint;
        uint16_t next_send_seq{0};
        ReceiveState receive_state{};
        std::map<uint16_t, PendingPacket> pending;
        Clock::time_point last_heard{};
    };

    boost::asio::io_context& io_context_;
    boost::asio::ip::udp::socket socket_;
    ReceiveHandler handler_;
    std::array<uint8_t, 2048> recv_buffer_;
    boost::asio::ip::udp::endpoint remote_endpoint_;

    std::mutex mutex_;
    std::unordered_map<std::string, ClientState> clients_;
    std::atomic<bool> running_{false};

    // 메트릭 카운터들
    std::atomic<uint64_t> reliable_retries_total_{0};
    std::atomic<uint64_t> reliable_timeouts_total_{0};
    std::atomic<uint64_t> dropped_duplicates_total_{0};
    std::atomic<uint64_t> dropped_old_total_{0};
    std::atomic<uint64_t> dropped_window_total_{0};

    void do_receive();
    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred);
    void process_packet(const Endpoint& endpoint, const UdpHeader& header, std::vector<uint8_t>&& payload);
    void handle_ack(ClientState& client, uint16_t ack, uint32_t ack_bits);
};
```

### 4.3 수신 흐름

```text
socket.async_receive_from
    ↓
handle_receive
    ↓
헤더 파싱 (seq, ack, ack_bits)
    ↓
┌─────────────────────────┐
│ ClientState 조회/생성    │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 중복 체크                │  has_received(seq)?
│ -> 드롭, dropped_dup++  │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 오래된 패킷 체크         │  seq << last_seq - 32?
│ -> 드롭, dropped_old++  │
└─────────────────────────┘
    ↓
update_receive_state(seq)
    ↓
handle_ack(ack, ack_bits)  // 송신 pending 정리
    ↓
handler_(endpoint, payload)  // 애플리케이션에 전달
```

### 4.4 송신 흐름

```text
send(endpoint, data, reliable=true)
    ↓
mutex lock
    ↓
ClientState& client = ensure_client_locked(endpoint)
    ↓
seq = client.next_send_seq++
    ↓
if (reliable):
    PendingPacket 생성 및 client.pending[seq] 저장
    ↓
UdpHeader 조립:
    header.seq = seq
    header.ack = client.receive_state.last_seq
    header.ack_bits = client.receive_state.ack_bits
    ↓
buffer = [header(8) | payload]
    ↓
socket.async_send_to(buffer, endpoint)
```

### 4.5 재전송 로직 (update)

```cpp
void UdpTransport::update() {
    auto now = Clock::now();
    std::lock_guard<std::mutex> lock(mutex_);

    for (auto& [key, client] : clients_) {
        std::vector<uint16_t> expired;
        for (auto& [seq, pkt] : client.pending) {
            if (now < pkt.next_send) continue;

            if (pkt.retries >= MAX_RETRIES) {
                expired.push_back(seq);
                reliable_timeouts_total_++;
                continue;
            }

            // 재전송
            auto buffer = compose_packet(client, seq, pkt.payload);
            post_send_buffer(buffer, endpoint);

            pkt.last_sent = now;
            pkt.retries++;
            pkt.next_send = now + timeout * (1 << pkt.retries);
            reliable_retries_total_++;
        }

        // 타임아웃 패킷 제거
        for (auto seq : expired) {
            client.pending.erase(seq);
        }
    }
}
```

---

## 5. CI/CD 파이프라인 & 품질 게이트 (v1.0 베이스라인)

### 5.1 GitHub Actions Workflow

`.github/workflows/ci.yml`:
```yaml
jobs:
  netcode-core:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake libboost-all-dev \
            protobuf-compiler libprotobuf-dev libhiredis-dev

      - name: Configure (Debug + ASan/UBSan)
        run: |
          cmake -S netcode-core -B build/netcode-core \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_CXX_FLAGS="-fsanitize=address,undefined -g"

      - name: Build
        run: cmake --build build/netcode-core --config Debug

      - name: Run tests
        run: |
          cd build/netcode-core
          ctest --output-on-failure

      - name: Lint (clang-tidy)
        run: |
          clang-tidy netcode-core/**/*.cpp -- -I netcode-core
```

### 5.2 로컬 품질 게이트 스크립트

`netcode-core/scripts/quality-gate.sh`:
```bash
#!/bin/bash
set -e

echo "=== Quality Gate v1.0 ==="

# 1. Build Debug + ASan
cmake -S netcode-core -B build/debug \
  -DCMAKE_BUILD_TYPE=Debug \
  -DCMAKE_CXX_FLAGS="-fsanitize=address,undefined -g"
cmake --build build/debug

# 2. Run tests
cd build/debug && ctest --output-on-failure

# 3. Build Release
cd ../..
cmake -S netcode-core -B build/release -DCMAKE_BUILD_TYPE=Release
cmake --build build/release

# 4. Performance test: 60 TPS, p99 < 15ms
./build/release/apps/pong_udp/pong_udp &
SERVER_PID=$!
sleep 2
./build/release/apps/loadgen/loadgen --clients 50 --duration 60
kill $SERVER_PID

# 5. Network experiment: 3% loss
sudo tc qdisc add dev lo root netem loss 3%
./build/release/apps/pong_udp/pong_udp &
SERVER_PID=$!
./build/release/apps/loadgen/loadgen --clients 10 --duration 30
kill $SERVER_PID
sudo tc qdisc del dev lo root

echo "=== All checks passed ==="
```

### 5.3 품질 기준 (v1.0 이후 모든 버전 공통)

| 항목 | 기준 |
|------|------|
| 테스트 커버리지 | ≥ 70% (라인 기준) |
| 성능 | 60 TPS ±1, p99 < 15ms |
| 메모리 안전 | ASan/UBSan 통과, valgrind 릭 0 |
| 린트 | clang-format, clang-tidy 경고 0 |
| 네트워크 내성 | 3% 손실 환경 세션 안정성 |

---

## 6. 검증 전략

### 6.1 유닛 테스트

**대상**: `netcode-core/net/udp/udp_transport_test.cpp`

1. **시퀀스 비교 함수**
   ```cpp
   TEST(UdpTransport, IsSeqNewer) {
       EXPECT_TRUE(is_seq_newer(10, 5));
       EXPECT_FALSE(is_seq_newer(5, 10));
       EXPECT_TRUE(is_seq_newer(0, 65535));  // 순환
   }
   ```

2. **ACK 비트 체크**
   ```cpp
   TEST(UdpTransport, IsSeqAcked) {
       EXPECT_TRUE(is_seq_acked(100, 100, 0));
       EXPECT_TRUE(is_seq_acked(99, 100, 0b1));
       EXPECT_FALSE(is_seq_acked(98, 100, 0b1));
   }
   ```

3. **ReceiveState 갱신**
   ```cpp
   TEST(UdpTransport, UpdateReceiveState) {
       ReceiveState state;
       update_receive_state(state, 10);
       EXPECT_EQ(state.last_seq, 10);
       update_receive_state(state, 12);
       EXPECT_EQ(state.last_seq, 12);
       EXPECT_EQ(state.ack_bits, 0b01);  // seq 11 빠짐
   }
   ```

### 6.2 통합 테스트

**시나리오**: 2 클라이언트, 서버 1개, 로컬 루프백

1. **정상 송수신**
   - 클라이언트 A → 서버: Input 10개
   - 서버 → 클라이언트 A: 모든 Input에 대한 ServerAck
   - 손실 0, 재전송 0 확인

2. **패킷 손실 시뮬레이션**
   - `netem loss 5%` 적용
   - 100개 Input 전송
   - 모든 Input에 대해 ACK 또는 재전송 확인
   - `reliable_retries_total > 0`, `reliable_timeouts_total == 0`

3. **중복 패킷**
   - 같은 seq를 2번 전송
   - 서버가 첫 패킷만 처리, `dropped_duplicates_total++`

4. **순서 뒤바뀜**
   - seq 10, 11, 12를 12, 10, 11 순으로 전송
   - 서버가 모두 올바르게 수신 확인

### 6.3 네트워크 실험 (pcap)

**목표**: 실제 패킷을 캡처하여 헤더 검증

```bash
# 3% 손실, 50ms 지연 환경
sudo tc qdisc add dev lo root netem loss 3% delay 50ms

# pcap 캡처
sudo tcpdump -i lo -w /tmp/udp_test.pcap udp port 7777 &
TCPDUMP_PID=$!

# 서버 + 클라이언트 실행
./pong_udp &
SERVER_PID=$!
./loadgen --clients 5 --duration 60

# 종료
kill $SERVER_PID
kill $TCPDUMP_PID

# pcap 분석
tshark -r /tmp/udp_test.pcap -T fields -e udp.srcport -e udp.dstport -e data
```

**확인 사항:**
- 헤더가 올바르게 조립되었는지 (seq, ack, ack_bits)
- 재전송 패킷의 seq가 동일한지
- ACK 수신 후 재전송이 멈추는지

---

## 7. 성능 예산 (60 TPS 기준)

**틱당 시간 예산: 16.67ms**

| 단계 | 예상 시간 | 비고 |
|------|----------|------|
| 입력 수신 및 파싱 | ~0.5ms | UDP recv + protobuf decode |
| 게임 로직 업데이트 | ~6ms | 물리, 충돌, 점수 (lab1.4 동일) |
| 상태 직렬화 | ~1ms | protobuf encode |
| 송신 (클라 N명) | ~0.5ms | N=10 가정, 각 50µs |
| 재전송 처리 (update) | ~0.3ms | pending 맵 순회 |
| **여유 (headroom)** | **~7.4ms** | 버퍼 |

재전송 처리가 추가되었지만, 대부분 클라이언트는 ACK를 잘 받으므로 pending 맵 크기가 작다 (< 10개). O(N) 순회도 충분히 빠르다.

---

## 8. 이후 버전과의 연결

### v1.0에서 확립된 것
- UDP 전송 및 신뢰성 레이어
- ITransport 인터페이스
- 메트릭 카운터 구조
- CI/CD 파이프라인 & 품질 게이트

### v1.1에서 추가될 것
- 스냅샷/델타 압축 (현재는 전체 World를 매번 전송)
- 클라이언트 예측 & 서버 리컨실리에이션
- 전송 바이트 최적화 (50% 절감 목표)

### v1.2에서 추가될 것
- Prometheus 메트릭 exporter
- Grafana 대시보드
- 부하 테스트 자동화 (loadgen)

### v1.3에서 추가될 것
- Match/Room 서버 분리
- Redis 세션 관리 및 재접속

---

## 9. 알려진 제약 & 향후 개선점

### 9.1 현재 제약

1. **고정 타임아웃**: 200ms 고정, RTT에 따른 적응 없음
   - 개선: RTT 측정 후 `timeout = RTT * 1.5` 같은 동적 조정

2. **재전송 전략 단순**: 지수 백오프만 사용
   - 개선: Fast Retransmit (동일 ACK 3회 수신 시 즉시 재전송)

3. **흐름 제어 없음**: 송신 윈도우가 무한정 커질 수 있음
   - 개선: 윈도우 크기 제한 (예: 32개), 윈도우 가득 차면 송신 대기

4. **혼잡 제어 없음**: 네트워크 혼잡 시에도 계속 재전송
   - 개선: AIMD (Additive Increase Multiplicative Decrease) 같은 혼잡 제어

### 9.2 보안 고려사항 (v1.4+)

현재 v1.0에서는 다루지 않지만 이후 필요:
- 입력 검증 (seq 순서, payload 크기)
- 레이트 리미팅 (클라이언트당 초당 패킷 수 제한)
- 접속 토큰 검증 (현재는 누구나 UDP로 접속 가능)

---

## 10. 체크리스트 (v1.0 완료 기준)

- [ ] `UdpTransport` 클래스 구현 완료
- [ ] `ITransport` 인터페이스 정의 및 문서화
- [ ] 시퀀스 번호, ACK 비트 로직 유닛 테스트 통과
- [ ] 재전송 로직 검증 (패킷 손실 환경)
- [ ] 중복 패킷 필터링 동작 확인
- [ ] 메트릭 카운터 정확성 검증
- [ ] CI/CD 파이프라인 GitHub Actions 설정
- [ ] `quality-gate.sh` 로컬 스크립트 작성 및 통과
- [ ] 3% 손실 환경에서 60초 이상 안정 동작
- [ ] pcap 캡처 및 헤더 구조 검증
- [ ] 성능: 60 TPS ±1, p99 < 15ms 달성
- [ ] ASan/UBSan 메모리 안전 통과
- [ ] 문서화: 아키텍처, 프로토콜, 테스트 가이드 작성
