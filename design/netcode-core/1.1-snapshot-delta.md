# 스냅샷/델타 압축 & 클라이언트 예측 설계 일지 (v1.1)
> UDP 전송을 효율화하고 클라이언트 반응성을 높이기 위한 상태 동기화 최적화

## 1. 문제 정의 & 요구사항

### 1.1 v1.0의 한계

v1.0에서는 **매 틱마다 전체 WorldState를 전송**:
```cpp
struct WorldState {
    uint64_t tick;
    double ball_x, ball_y, ball_vx, ball_vy;    // 32 bytes
    double left_paddle_y, right_paddle_y;       // 16 bytes
    int left_direction, right_direction;        // 8 bytes
    uint32_t left_score, right_score;           // 8 bytes
    // 총 ~64 bytes
};
```

**60 TPS × 64 bytes = 3.84 KB/s per client**

10명이면 38.4 KB/s. 작아 보이지만:
- 대부분의 필드가 틱마다 조금씩만 변함 (패들 위치, 공 위치)
- 점수는 거의 안 바뀜
- **불필요한 중복 전송**

**클라이언트 입력 지연:**
- 클라이언트가 입력 → 서버로 전송 → 서버 처리 → 상태 수신까지 **RTT + 틱 지연**
- RTT 60ms 환경에서 입력 반영까지 ~76ms (60ms + 16ms)
- **조작감이 뭉툭함**

### 1.2 목표

#### 1.2.1 델타 압축 (Delta Encoding)
- N 틱마다 **키프레임** (전체 상태) 전송
- 나머지 틱은 **델타** (이전 상태 대비 변경분만) 전송
- **전송 바이트 수 ≥ 50% 절감** 목표

#### 1.2.2 클라이언트 예측 (Client-Side Prediction)
- 클라이언트가 자신의 입력을 **즉시 로컬 시뮬레이션**
- 서버 응답을 기다리지 않고 화면 업데이트
- 지연 체감 < 10ms (로컬 시뮬 오버헤드만)

#### 1.2.3 서버 리컨실리에이션 (Server Reconciliation)
- 서버로부터 권위 상태 수신 시:
  - 서버 상태와 클라이언트 예측 비교
  - 불일치 발견 시 서버 상태로 **리셋 + 재시뮬레이션** (resim)
- 리심 깊이 ≤ 2 틱 유지 (예측이 정확하면 리심 불필요)

### 1.3 비기능 요구사항

#### 1.3.1 성능
- 60 TPS 유지 (v1.0과 동일)
- 델타 인코딩 오버헤드 < 2ms per tick
- 리컨실리에이션 resim < 1ms (2 틱 재시뮬)

#### 1.3.2 네트워크 조건 대응
- RTT 20/60/120ms에서 모두 조작감 허용 범위
- 손실 0/3% 조합에서도 델타 디코딩 성공률 > 99%

#### 1.3.3 확장성
- 상태 히스토리 메모리: 클라이언트당 ~120 틱 × 64 bytes = 7.68 KB
- 총 10 클라이언트 = 76.8 KB (여전히 작음)

---

## 2. 기술적 배경 & 설계 동기

### 2.1 델타 인코딩이란?

**키프레임 (Keyframe):**
- 전체 상태를 protobuf로 직렬화
- 새 클라이언트 접속, 또는 N 틱마다 (예: 20틱 = 0.33초)

**델타 (Delta):**
- 베이스 상태 대비 **변경된 필드만** 인코딩
- 예: 공의 위치만 바뀌면 8 bytes, 패들 위치만 바뀌면 8 bytes

**예시:**
```
Tick 0: [Keyframe] 64 bytes
Tick 1: [Delta vs Tick 0] ball_x, ball_y 변경 -> 16 bytes
Tick 2: [Delta vs Tick 1] ball_x, ball_y, left_paddle_y 변경 -> 24 bytes
...
Tick 20: [Keyframe] 64 bytes
```

**수신측:**
- 키프레임은 그대로 디코딩
- 델타는 **베이스 상태 + 델타 = 현재 상태**
- 베이스 상태를 히스토리에서 찾아야 함 → 최근 120 틱 보관

### 2.2 클라이언트 예측이란?

**전통적 동기화 (v1.0):**
```
t=0: 클라 입력 → 송신
t=30ms: 서버 수신 → 처리 → 다음 틱 반영
t=60ms: 클라 상태 수신 → 화면 업데이트
=> 총 지연 60ms
```

**클라이언트 예측:**
```
t=0: 클라 입력 → 송신 + 즉시 로컬 시뮬
t=0.1ms: 화면 업데이트 (예측 결과)
t=60ms: 서버 상태 수신 → 예측과 비교 → 불일치 시 보정
=> 체감 지연 ~0.1ms
```

**트레이드오프:**
- 예측이 틀리면 **텔레포트** (순간 이동) 또는 **끊김** 발생
- 결정론적 시뮬레이션 필요 (클라/서버 물리 동일)
- 예측 히스토리 보관 필요 (서버 틱과 매칭)

### 2.3 리컨실리에이션이란?

서버로부터 틱 T의 권위 상태 수신 시:

1. **예측 히스토리에서 틱 T 찾기**
   - 없으면 서버 상태 그대로 적용 (키프레임으로 간주)

2. **예측 상태와 서버 상태 비교**
   - 패들 위치, 공 위치 차이가 임계값(예: 0.01) 이하면 **일치**
   - 일치하면 아무것도 안 함 (예측 성공)

3. **불일치 시 리셋 + 재시뮬레이션 (resim)**
   - 서버 상태를 틱 T 시점으로 설정
   - 틱 T+1부터 현재까지의 입력을 다시 적용
   - 예: 현재 틱 102, 서버 상태 틱 100 → 100, 101, 102 재시뮬

**리심 깊이 (Resim Depth):**
- 재시뮬해야 하는 틱 수
- 깊이가 크면 CPU 오버헤드 증가
- 목표: 평균 0 틱, 최대 2 틱

---

## 3. 스냅샷 프로토콜 설계

### 3.1 EncodedSnapshot 구조

```cpp
struct EncodedSnapshot {
    uint64_t tick;              // 스냅샷의 틱 번호
    uint64_t base_tick;         // 델타인 경우 베이스 틱, 키프레임은 0
    bool is_keyframe;           // true면 전체 상태, false면 델타
    std::vector<uint8_t> payload;  // protobuf 직렬화 데이터
};
```

**protobuf 스키마 (proto/snapshot.proto):**
```protobuf
message Snapshot {
    uint64 tick = 1;
    uint64 base_tick = 2;
    bool is_keyframe = 3;
    bytes state = 4;       // WorldState 또는 DeltaState 직렬화
    string role = 5;       // "left" | "right" | "spectator"
}

message WorldState {
    uint64 tick = 1;
    double ball_x = 2;
    double ball_y = 3;
    double ball_vx = 4;
    double ball_vy = 5;
    double left_paddle_y = 6;
    double right_paddle_y = 7;
    int32 left_direction = 8;
    int32 right_direction = 9;
    uint32 left_score = 10;
    uint32 right_score = 11;
}

message DeltaState {
    uint64 tick = 1;
    optional double ball_x = 2;
    optional double ball_y = 3;
    optional double ball_vx = 4;
    optional double ball_vy = 5;
    optional double left_paddle_y = 6;
    optional double right_paddle_y = 7;
    optional int32 left_direction = 8;
    optional int32 right_direction = 9;
    optional uint32 left_score = 10;
    optional uint32 right_score = 11;
}
```

**설계 포인트:**
- `optional` 키워드로 변경된 필드만 직렬화 (protobuf3)
- 점수는 거의 안 바뀌므로 델타에서 생략 → 평균 바이트 절감

### 3.2 SnapshotGenerator (서버)

```cpp
class SnapshotGenerator {
public:
    SnapshotGenerator(uint32_t keyframe_interval = 20,
                      size_t history_size = 120);

    EncodedSnapshot encode(const WorldState& state);
    EncodedSnapshot encode_keyframe(const WorldState& state);

private:
    void store_state(const WorldState& state);
    void prune_history(uint64_t min_tick);

    uint32_t keyframe_interval_;  // 20 틱마다 키프레임
    size_t history_size_;         // 최근 120 틱 보관
    std::deque<WorldState> history_;
    uint64_t last_keyframe_tick_{0};
    bool has_keyframe_{false};
    DeltaCodec codec_;
};
```

**encode 로직:**
```cpp
EncodedSnapshot SnapshotGenerator::encode(const WorldState& state) {
    store_state(state);

    // 키프레임 조건
    if (!has_keyframe_ || (state.tick - last_keyframe_tick_) >= keyframe_interval_) {
        return encode_keyframe(state);
    }

    // 델타 생성: 직전 틱 대비
    auto base_opt = find_state(state.tick - 1);
    if (!base_opt) {
        return encode_keyframe(state);  // 히스토리 없으면 키프레임
    }

    EncodedSnapshot snap;
    snap.tick = state.tick;
    snap.base_tick = state.tick - 1;
    snap.is_keyframe = false;
    snap.payload = codec_.encode_delta(*base_opt, state);
    return snap;
}

EncodedSnapshot SnapshotGenerator::encode_keyframe(const WorldState& state) {
    last_keyframe_tick_ = state.tick;
    has_keyframe_ = true;

    EncodedSnapshot snap;
    snap.tick = state.tick;
    snap.base_tick = 0;
    snap.is_keyframe = true;
    snap.payload = codec_.encode_keyframe(state);
    return snap;
}
```

### 3.3 DeltaCodec

```cpp
class DeltaCodec {
public:
    std::vector<uint8_t> encode_keyframe(const WorldState& state) const;
    WorldState decode_keyframe(const std::vector<uint8_t>& data, uint64_t tick) const;

    std::vector<uint8_t> encode_delta(const WorldState& base, const WorldState& state) const;
    WorldState apply_delta(const WorldState& base, const std::vector<uint8_t>& delta, uint64_t tick) const;
};
```

**encode_delta 구현 (간단한 예시):**
```cpp
std::vector<uint8_t> DeltaCodec::encode_delta(const WorldState& base, const WorldState& state) const {
    DeltaState delta_msg;
    delta_msg.set_tick(state.tick);

    constexpr double threshold = 1e-6;
    if (std::abs(state.ball_x - base.ball_x) > threshold)
        delta_msg.set_ball_x(state.ball_x);
    if (std::abs(state.ball_y - base.ball_y) > threshold)
        delta_msg.set_ball_y(state.ball_y);
    // 나머지 필드도 동일...

    if (state.left_score != base.left_score)
        delta_msg.set_left_score(state.left_score);
    if (state.right_score != base.right_score)
        delta_msg.set_right_score(state.right_score);

    return serialize_protobuf(delta_msg);
}
```

**apply_delta 구현:**
```cpp
WorldState DeltaCodec::apply_delta(const WorldState& base, const std::vector<uint8_t>& delta, uint64_t tick) const {
    DeltaState delta_msg = parse_protobuf<DeltaState>(delta);
    WorldState result = base;
    result.tick = tick;

    if (delta_msg.has_ball_x()) result.ball_x = delta_msg.ball_x();
    if (delta_msg.has_ball_y()) result.ball_y = delta_msg.ball_y();
    // 나머지 필드도 동일...

    return result;
}
```

### 3.4 SnapshotDecoder (클라이언트)

```cpp
class SnapshotDecoder {
public:
    explicit SnapshotDecoder(size_t history_size = 120);

    WorldState apply(const EncodedSnapshot& snapshot);

private:
    std::optional<WorldState> find_state(uint64_t tick) const;
    void store_state(const WorldState& state);

    size_t history_size_;
    std::deque<WorldState> history_;
    DeltaCodec codec_;
};
```

**apply 로직:**
```cpp
WorldState SnapshotDecoder::apply(const EncodedSnapshot& snapshot) {
    if (snapshot.is_keyframe) {
        WorldState state = codec_.decode_keyframe(snapshot.payload, snapshot.tick);
        store_state(state);
        return state;
    }

    // 델타: 베이스 상태 찾기
    auto base_opt = find_state(snapshot.base_tick);
    if (!base_opt) {
        throw std::runtime_error("Base state not found for delta");
    }

    WorldState state = codec_.apply_delta(*base_opt, snapshot.payload, snapshot.tick);
    store_state(state);
    return state;
}
```

---

## 4. 클라이언트 예측 & 리컨실리에이션

### 4.1 클라이언트 구조

```cpp
class PredictiveClient {
public:
    PredictiveClient();

    // 입력 처리
    void on_input(int direction);

    // 서버 상태 수신
    void on_server_state(const WorldState& server_state);

    // 로컬 시뮬레이션 (매 프레임)
    void tick(double dt);

    WorldState get_display_state() const;

private:
    struct PendingInput {
        uint64_t seq;
        uint64_t predicted_tick;
        int direction;
    };

    struct PredictedState {
        uint64_t tick;
        WorldState state;
    };

    // 서버로부터 마지막으로 확인된 상태
    WorldState last_server_state_;
    uint64_t last_server_tick_{0};

    // 예측 히스토리
    std::deque<PredictedState> predicted_history_;

    // 전송했지만 아직 ACK 안 받은 입력들
    std::deque<PendingInput> pending_inputs_;

    uint64_t next_input_seq_{0};
    uint64_t local_tick_{0};

    void predict_next_state(double dt);
    void reconcile(const WorldState& server_state);
};
```

### 4.2 입력 처리

```cpp
void PredictiveClient::on_input(int direction) {
    // 1. 서버로 입력 전송
    PendingInput input;
    input.seq = next_input_seq_++;
    input.predicted_tick = local_tick_ + 1;  // 다음 틱에 적용될 것으로 예상
    input.direction = direction;
    pending_inputs_.push_back(input);

    send_input_to_server(input.seq, direction);

    // 2. 로컬 시뮬레이션 (즉시 반영)
    // 실제 predict_next_state는 tick()에서 호출되지만,
    // 입력을 pending에 저장해두면 다음 틱에 자동 반영됨
}
```

### 4.3 로컬 시뮬레이션

```cpp
void PredictiveClient::tick(double dt) {
    local_tick_++;

    // 현재 상태 (서버 확인 또는 마지막 예측)
    WorldState current = predicted_history_.empty()
        ? last_server_state_
        : predicted_history_.back().state;

    // pending_inputs에서 이번 틱에 적용할 입력 찾기
    int direction = 0;
    for (auto& inp : pending_inputs_) {
        if (inp.predicted_tick == local_tick_) {
            direction = inp.direction;
            break;
        }
    }

    // 물리 시뮬레이션 (서버와 동일한 로직)
    WorldState next = simulate_physics(current, direction, dt);
    next.tick = local_tick_;

    // 예측 히스토리에 저장
    PredictedState pred;
    pred.tick = local_tick_;
    pred.state = next;
    predicted_history_.push_back(pred);

    // 히스토리 크기 제한 (120 틱)
    if (predicted_history_.size() > 120) {
        predicted_history_.pop_front();
    }
}
```

### 4.4 서버 상태 수신 & 리컨실리에이션

```cpp
void PredictiveClient::on_server_state(const WorldState& server_state) {
    last_server_state_ = server_state;
    last_server_tick_ = server_state.tick;

    // pending_inputs에서 서버가 처리한 입력 제거
    while (!pending_inputs_.empty()) {
        auto& inp = pending_inputs_.front();
        if (inp.predicted_tick <= server_state.tick) {
            pending_inputs_.pop_front();
        } else {
            break;
        }
    }

    reconcile(server_state);
}

void PredictiveClient::reconcile(const WorldState& server_state) {
    // 예측 히스토리에서 서버 틱 찾기
    auto it = std::find_if(predicted_history_.begin(), predicted_history_.end(),
        [&](const PredictedState& p) { return p.tick == server_state.tick; });

    if (it == predicted_history_.end()) {
        // 히스토리에 없음 → 서버 상태로 리셋
        predicted_history_.clear();
        PredictedState pred;
        pred.tick = server_state.tick;
        pred.state = server_state;
        predicted_history_.push_back(pred);
        return;
    }

    // 예측과 서버 상태 비교
    constexpr double pos_threshold = 0.01;
    bool mismatch = false;
    if (std::abs(it->state.ball_x - server_state.ball_x) > pos_threshold ||
        std::abs(it->state.ball_y - server_state.ball_y) > pos_threshold ||
        std::abs(it->state.left_paddle_y - server_state.left_paddle_y) > pos_threshold) {
        mismatch = true;
    }

    if (!mismatch) {
        // 예측 성공 → 아무것도 안 함
        return;
    }

    // 불일치 → 리셋 + 재시뮬레이션
    uint64_t resim_start = server_state.tick;
    predicted_history_.erase(predicted_history_.begin(), it + 1);

    WorldState current = server_state;
    for (uint64_t tick = resim_start + 1; tick <= local_tick_; ++tick) {
        // 해당 틱의 입력 찾기
        int direction = 0;
        for (auto& inp : pending_inputs_) {
            if (inp.predicted_tick == tick) {
                direction = inp.direction;
                break;
            }
        }

        current = simulate_physics(current, direction, TICK_DT);
        current.tick = tick;

        PredictedState pred;
        pred.tick = tick;
        pred.state = current;
        predicted_history_.push_back(pred);
    }

    // 메트릭: 리심 깊이 기록
    uint64_t resim_depth = local_tick_ - resim_start;
    record_resim_depth(resim_depth);
}
```

---

## 5. 성능 예산 & 최적화

### 5.1 틱당 시간 예산 (서버, 60 TPS)

| 단계 | v1.0 | v1.1 (델타) | 증감 |
|------|------|-------------|------|
| 입력 수신 | 0.5ms | 0.5ms | - |
| 게임 로직 | 6ms | 6ms | - |
| **상태 직렬화** | 1ms | **1.5ms** | +0.5ms (델타 인코딩) |
| 히스토리 저장 | - | **0.3ms** | +0.3ms |
| 송신 | 0.5ms | 0.3ms | -0.2ms (델타 작음) |
| 재전송 처리 | 0.3ms | 0.3ms | - |
| **여유** | 7.4ms | **7.1ms** | -0.3ms |

**결론**: 델타 인코딩 오버헤드는 1ms 미만으로, 여전히 60 TPS 안정.

### 5.2 전송 바이트 절감

**키프레임 주기 20 틱 기준:**
- 20 틱마다 1 키프레임(64 bytes) + 19 델타(평균 24 bytes)
- **평균**: (64 + 19×24) / 20 = 26 bytes/tick
- **v1.0 대비**: 64 → 26 bytes, **약 59% 절감**

**RTT 60ms 환경에서 10 클라이언트:**
- v1.0: 60 TPS × 64 bytes × 10 = 38.4 KB/s
- v1.1: 60 TPS × 26 bytes × 10 = 15.6 KB/s
- **절감**: 22.8 KB/s

### 5.3 클라이언트 CPU 오버헤드

**리컨실리에이션 (worst case: 2 틱 리심):**
- 1 틱 시뮬레이션: ~0.3ms (물리, 충돌)
- 2 틱 리심: 0.6ms
- 60 FPS 기준 프레임당 예산 16.67ms → 충분

**메모리:**
- 예측 히스토리 120 틱 × 64 bytes = 7.68 KB
- pending_inputs 최대 10개 × 16 bytes = 160 bytes
- 총 ~8 KB per client

---

## 6. 검증 전략

### 6.1 유닛 테스트

**DeltaCodec 테스트:**
```cpp
TEST(DeltaCodec, EncodeDecodeKeyframe) {
    DeltaCodec codec;
    WorldState original = make_test_state();
    auto encoded = codec.encode_keyframe(original);
    WorldState decoded = codec.decode_keyframe(encoded, original.tick);
    EXPECT_EQ(original, decoded);
}

TEST(DeltaCodec, EncodeDelta) {
    WorldState base = make_test_state();
    WorldState next = base;
    next.ball_x += 0.1;
    next.ball_y += 0.05;

    DeltaCodec codec;
    auto delta = codec.encode_delta(base, next);
    EXPECT_LT(delta.size(), 64);  // 델타가 전체보다 작음

    WorldState result = codec.apply_delta(base, delta, next.tick);
    EXPECT_NEAR(result.ball_x, next.ball_x, 1e-6);
    EXPECT_NEAR(result.ball_y, next.ball_y, 1e-6);
}
```

**SnapshotGenerator 테스트:**
```cpp
TEST(SnapshotGenerator, KeyframeInterval) {
    SnapshotGenerator gen(20);  // 20 틱마다 키프레임
    for (int i = 0; i < 40; ++i) {
        WorldState state = make_test_state();
        state.tick = i;
        auto snap = gen.encode(state);

        if (i % 20 == 0) {
            EXPECT_TRUE(snap.is_keyframe);
        } else {
            EXPECT_FALSE(snap.is_keyframe);
        }
    }
}
```

### 6.2 통합 테스트

**시나리오 1: 델타 수신 & 디코딩**
1. 서버 시작, 클라이언트 접속
2. 서버가 20 틱 전송 (0번 키프레임, 1-19번 델타)
3. 클라이언트가 모든 스냅샷 디코딩 성공 확인
4. 디코딩된 상태가 서버 상태와 동일한지 검증

**시나리오 2: 패킷 손실 환경**
1. `netem loss 3%` 적용
2. 100 틱 동안 서버 → 클라이언트 스냅샷 전송
3. 클라이언트가 손실된 델타를 건너뛰고 다음 키프레임에서 복구
4. 최종 상태 일치 확인

**시나리오 3: 클라이언트 예측 & 리컨실리에이션**
1. 클라이언트가 입력 10개 전송
2. 각 입력 직후 로컬 시뮬레이션 실행
3. 서버 상태 수신 시 리컨실리에이션
4. 리심 깊이 평균 < 1 틱, 최대 2 틱 확인

### 6.3 성능 벤치마크

**바이트 절감률 측정:**
```cpp
TEST(DeltaCodec, ByteSavings) {
    SnapshotGenerator gen(20);
    size_t total_bytes = 0;
    size_t keyframe_count = 0;
    size_t delta_count = 0;

    for (int i = 0; i < 100; ++i) {
        WorldState state = make_realistic_state(i);
        auto snap = gen.encode(state);
        total_bytes += snap.payload.size();
        if (snap.is_keyframe) keyframe_count++;
        else delta_count++;
    }

    size_t avg_bytes = total_bytes / 100;
    EXPECT_LT(avg_bytes, 40);  // 평균 < 40 bytes
    double savings = (64.0 - avg_bytes) / 64.0;
    EXPECT_GE(savings, 0.5);  // ≥ 50% 절감
}
```

**리컨실리에이션 오버헤드 측정:**
```cpp
TEST(PredictiveClient, ReconciliationPerformance) {
    PredictiveClient client;
    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < 1000; ++i) {
        WorldState server_state = make_test_state();
        client.on_server_state(server_state);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    double avg_us = duration.count() / 1000.0;
    EXPECT_LT(avg_us, 500);  // 평균 < 500µs per reconciliation
}
```

---

## 7. 알려진 제약 & 향후 개선점

### 7.1 현재 제약

1. **델타 체인 길이 제한**
   - 현재: 직전 틱 대비 델타만 지원
   - 패킷 손실 시 델타 체인이 끊어지면 다음 키프레임까지 대기
   - 개선: 여러 베이스 틱 후보 지원 (예: tick-1, tick-5, tick-10)

2. **결정론적 시뮬레이션 요구**
   - 클라이언트와 서버의 물리 로직이 완전히 동일해야 함
   - 부동소수점 연산 차이, 플랫폼 차이 주의
   - 개선: 정수 기반 시뮬레이션, 또는 허용 오차 내 보정

3. **고지연 환경 예측 실패**
   - RTT 200ms+ 환경에서 예측 히스토리가 부족할 수 있음
   - 개선: 히스토리 크기 동적 조정 (RTT × 2 정도)

### 7.2 최적화 기회

1. **적응형 키프레임 주기**
   - 손실률이 높으면 키프레임 주기 단축 (예: 10 틱)
   - 손실률이 낮으면 주기 연장 (예: 60 틱)

2. **선택적 필드 인코딩**
   - 점수는 변경 시에만 전송 (플래그 기반)
   - 방향은 변경 시에만 (0일 때 생략)

3. **압축 알고리즘 추가**
   - LZ4, Zstd 같은 경량 압축 적용 (지연 < 1ms)
   - 델타에만 선택적으로 적용

---

## 8. v1.2와의 연결

v1.1에서 확립된 것:
- 스냅샷/델타 인코딩 프레임워크
- 클라이언트 예측 & 리컨실리에이션 패턴
- 전송 바이트 최적화 (50%+ 절감)

v1.2에서 추가될 것:
- **메트릭 수집**: 델타 크기, 리심 깊이, 예측 정확도
- **Prometheus exporter**: 메트릭을 Prometheus 형식으로 export
- **Grafana 대시보드**: 실시간 모니터링 및 알람
- **부하 테스트 자동화**: loadgen으로 200 클라이언트 시뮬레이션

---

## 9. 체크리스트 (v1.1 완료 기준)

- [ ] `DeltaCodec` 구현 및 유닛 테스트 통과
- [ ] `SnapshotGenerator` / `SnapshotDecoder` 구현
- [ ] 키프레임 주기 20 틱으로 설정 및 동작 확인
- [ ] 델타 인코딩 바이트 절감 ≥ 50% 달성
- [ ] `PredictiveClient` 구현 (입력 예측, 로컬 시뮬)
- [ ] 리컨실리에이션 로직 구현 및 테스트
- [ ] 리심 깊이 평균 < 1 틱, 최대 2 틱 달성
- [ ] RTT 20/60/120ms 환경에서 조작감 테스트 통과
- [ ] 3% 손실 환경에서 델타 디코딩 성공률 > 99%
- [ ] 성능: 60 TPS 유지, p99 < 15ms
- [ ] 메모리: 클라이언트당 < 10 KB 히스토리
- [ ] 문서화: 델타 프로토콜, 예측/리컨실리에이션 가이드
